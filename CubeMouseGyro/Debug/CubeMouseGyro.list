
CubeMouseGyro.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001ac  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000062cc  080001ac  080001ac  000101ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00001b28  08006478  08006478  00016478  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08007fa0  08007fa0  00017fa0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08007fa4  08007fa4  00017fa4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000234  20000000  08007fa8  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ccmram       00000000  10000000  10000000  00020234  2**0
                  CONTENTS
  7 .bss          00000af8  20000234  20000234  00020234  2**2
                  ALLOC
  8 ._user_heap_stack 00000600  20000d2c  20000d2c  00020234  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00020234  2**0
                  CONTENTS, READONLY
 10 .debug_info   0002982e  00000000  00000000  00020264  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00005b1b  00000000  00000000  00049a92  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000108e5  00000000  00000000  0004f5ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 000014f8  00000000  00000000  0005fe98  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00001708  00000000  00000000  00061390  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000c18a  00000000  00000000  00062a98  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00006ff3  00000000  00000000  0006ec22  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007c  00000000  00000000  00075c15  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00003d2c  00000000  00000000  00075c94  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001ac <__do_global_dtors_aux>:
 80001ac:	b510      	push	{r4, lr}
 80001ae:	4c05      	ldr	r4, [pc, #20]	; (80001c4 <__do_global_dtors_aux+0x18>)
 80001b0:	7823      	ldrb	r3, [r4, #0]
 80001b2:	b933      	cbnz	r3, 80001c2 <__do_global_dtors_aux+0x16>
 80001b4:	4b04      	ldr	r3, [pc, #16]	; (80001c8 <__do_global_dtors_aux+0x1c>)
 80001b6:	b113      	cbz	r3, 80001be <__do_global_dtors_aux+0x12>
 80001b8:	4804      	ldr	r0, [pc, #16]	; (80001cc <__do_global_dtors_aux+0x20>)
 80001ba:	f3af 8000 	nop.w
 80001be:	2301      	movs	r3, #1
 80001c0:	7023      	strb	r3, [r4, #0]
 80001c2:	bd10      	pop	{r4, pc}
 80001c4:	20000234 	.word	0x20000234
 80001c8:	00000000 	.word	0x00000000
 80001cc:	08006460 	.word	0x08006460

080001d0 <frame_dummy>:
 80001d0:	b508      	push	{r3, lr}
 80001d2:	4b03      	ldr	r3, [pc, #12]	; (80001e0 <frame_dummy+0x10>)
 80001d4:	b11b      	cbz	r3, 80001de <frame_dummy+0xe>
 80001d6:	4903      	ldr	r1, [pc, #12]	; (80001e4 <frame_dummy+0x14>)
 80001d8:	4803      	ldr	r0, [pc, #12]	; (80001e8 <frame_dummy+0x18>)
 80001da:	f3af 8000 	nop.w
 80001de:	bd08      	pop	{r3, pc}
 80001e0:	00000000 	.word	0x00000000
 80001e4:	20000238 	.word	0x20000238
 80001e8:	08006460 	.word	0x08006460

080001ec <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80001ec:	490f      	ldr	r1, [pc, #60]	; (800022c <SystemInit+0x40>)
 80001ee:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 80001f2:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80001f6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80001fa:	4b0d      	ldr	r3, [pc, #52]	; (8000230 <SystemInit+0x44>)
 80001fc:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80001fe:	2000      	movs	r0, #0
  RCC->CR |= (uint32_t)0x00000001;
 8000200:	f042 0201 	orr.w	r2, r2, #1
 8000204:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 8000206:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000208:	681a      	ldr	r2, [r3, #0]
 800020a:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 800020e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000212:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000214:	4a07      	ldr	r2, [pc, #28]	; (8000234 <SystemInit+0x48>)
 8000216:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000218:	681a      	ldr	r2, [r3, #0]
 800021a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800021e:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8000220:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000222:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000226:	608b      	str	r3, [r1, #8]
 8000228:	4770      	bx	lr
 800022a:	bf00      	nop
 800022c:	e000ed00 	.word	0xe000ed00
 8000230:	40023800 	.word	0x40023800
 8000234:	24003010 	.word	0x24003010

08000238 <HAL_MspInit>:
 8000238:	4770      	bx	lr

0800023a <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800023a:	b510      	push	{r4, lr}
 800023c:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 800023e:	f002 f81b 	bl	8002278 <HAL_RCC_GetHCLKFreq>
 8000242:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000246:	fbb0 f0f3 	udiv	r0, r0, r3
 800024a:	f000 f891 	bl	8000370 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 800024e:	2200      	movs	r2, #0
 8000250:	4621      	mov	r1, r4
 8000252:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000256:	f000 f84b 	bl	80002f0 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 800025a:	2000      	movs	r0, #0
 800025c:	bd10      	pop	{r4, pc}
	...

08000260 <HAL_Init>:
{
 8000260:	b508      	push	{r3, lr}
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8000262:	4b0b      	ldr	r3, [pc, #44]	; (8000290 <HAL_Init+0x30>)
 8000264:	681a      	ldr	r2, [r3, #0]
 8000266:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800026a:	601a      	str	r2, [r3, #0]
   __HAL_FLASH_DATA_CACHE_ENABLE();
 800026c:	681a      	ldr	r2, [r3, #0]
 800026e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000272:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000274:	681a      	ldr	r2, [r3, #0]
 8000276:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800027a:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800027c:	2003      	movs	r0, #3
 800027e:	f000 f825 	bl	80002cc <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8000282:	200f      	movs	r0, #15
 8000284:	f7ff ffd9 	bl	800023a <HAL_InitTick>
  HAL_MspInit();
 8000288:	f7ff ffd6 	bl	8000238 <HAL_MspInit>
}
 800028c:	2000      	movs	r0, #0
 800028e:	bd08      	pop	{r3, pc}
 8000290:	40023c00 	.word	0x40023c00

08000294 <HAL_IncTick>:
  * @param None
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000294:	4a02      	ldr	r2, [pc, #8]	; (80002a0 <HAL_IncTick+0xc>)
 8000296:	6813      	ldr	r3, [r2, #0]
 8000298:	3301      	adds	r3, #1
 800029a:	6013      	str	r3, [r2, #0]
 800029c:	4770      	bx	lr
 800029e:	bf00      	nop
 80002a0:	20000250 	.word	0x20000250

080002a4 <HAL_GetTick>:
  * @param None
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80002a4:	4b01      	ldr	r3, [pc, #4]	; (80002ac <HAL_GetTick+0x8>)
 80002a6:	6818      	ldr	r0, [r3, #0]
}
 80002a8:	4770      	bx	lr
 80002aa:	bf00      	nop
 80002ac:	20000250 	.word	0x20000250

080002b0 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 80002b0:	b513      	push	{r0, r1, r4, lr}
 80002b2:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
 80002b4:	f7ff fff6 	bl	80002a4 <HAL_GetTick>
 80002b8:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 80002ba:	f7ff fff3 	bl	80002a4 <HAL_GetTick>
 80002be:	9b01      	ldr	r3, [sp, #4]
 80002c0:	1b00      	subs	r0, r0, r4
 80002c2:	4298      	cmp	r0, r3
 80002c4:	d3f9      	bcc.n	80002ba <HAL_Delay+0xa>
  {
  }
}
 80002c6:	b002      	add	sp, #8
 80002c8:	bd10      	pop	{r4, pc}
	...

080002cc <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80002cc:	4a07      	ldr	r2, [pc, #28]	; (80002ec <HAL_NVIC_SetPriorityGrouping+0x20>)
 80002ce:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 80002d0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80002d4:	041b      	lsls	r3, r3, #16
 80002d6:	0c1b      	lsrs	r3, r3, #16
 80002d8:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
 80002dc:	0200      	lsls	r0, r0, #8
 80002de:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80002e2:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                 |
 80002e6:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 80002e8:	60d3      	str	r3, [r2, #12]
 80002ea:	4770      	bx	lr
 80002ec:	e000ed00 	.word	0xe000ed00

080002f0 <HAL_NVIC_SetPriority>:

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
 80002f0:	4b17      	ldr	r3, [pc, #92]	; (8000350 <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80002f2:	b530      	push	{r4, r5, lr}
 80002f4:	68dc      	ldr	r4, [r3, #12]
 80002f6:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
 80002fa:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
 80002fe:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
 8000300:	2b04      	cmp	r3, #4
 8000302:	bf28      	it	cs
 8000304:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
 8000306:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
 8000308:	f04f 0501 	mov.w	r5, #1
 800030c:	fa05 f303 	lsl.w	r3, r5, r3
 8000310:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
 8000314:	bf8c      	ite	hi
 8000316:	3c03      	subhi	r4, #3
 8000318:	2400      	movls	r4, #0
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
 800031a:	4019      	ands	r1, r3
 800031c:	40a1      	lsls	r1, r4
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
 800031e:	fa05 f404 	lsl.w	r4, r5, r4
 8000322:	3c01      	subs	r4, #1
 8000324:	4022      	ands	r2, r4
  if(IRQn < 0) {
 8000326:	2800      	cmp	r0, #0
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
 8000328:	ea42 0201 	orr.w	r2, r2, r1
 800032c:	ea4f 1202 	mov.w	r2, r2, lsl #4
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 8000330:	bfaf      	iteee	ge
 8000332:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8000336:	f000 000f 	andlt.w	r0, r0, #15
 800033a:	4b06      	ldrlt	r3, [pc, #24]	; (8000354 <HAL_NVIC_SetPriority+0x64>)
 800033c:	b2d2      	uxtblt	r2, r2
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 800033e:	bfa5      	ittet	ge
 8000340:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 8000344:	b2d2      	uxtbge	r2, r2
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8000346:	541a      	strblt	r2, [r3, r0]
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 8000348:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 800034c:	bd30      	pop	{r4, r5, pc}
 800034e:	bf00      	nop
 8000350:	e000ed00 	.word	0xe000ed00
 8000354:	e000ed14 	.word	0xe000ed14

08000358 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 8000358:	0942      	lsrs	r2, r0, #5
 800035a:	2301      	movs	r3, #1
 800035c:	f000 001f 	and.w	r0, r0, #31
 8000360:	fa03 f000 	lsl.w	r0, r3, r0
 8000364:	4b01      	ldr	r3, [pc, #4]	; (800036c <HAL_NVIC_EnableIRQ+0x14>)
 8000366:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 800036a:	4770      	bx	lr
 800036c:	e000e100 	.word	0xe000e100

08000370 <HAL_SYSTICK_Config>:
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
 8000370:	3801      	subs	r0, #1
 8000372:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000376:	d20a      	bcs.n	800038e <HAL_SYSTICK_Config+0x1e>

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
 8000378:	4b06      	ldr	r3, [pc, #24]	; (8000394 <HAL_SYSTICK_Config+0x24>)
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 800037a:	4a07      	ldr	r2, [pc, #28]	; (8000398 <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
 800037c:	6058      	str	r0, [r3, #4]
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 800037e:	21f0      	movs	r1, #240	; 0xf0
 8000380:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8000384:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000386:	2207      	movs	r2, #7
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8000388:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800038a:	601a      	str	r2, [r3, #0]
 800038c:	4770      	bx	lr
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
 800038e:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000390:	4770      	bx	lr
 8000392:	bf00      	nop
 8000394:	e000e010 	.word	0xe000e010
 8000398:	e000ed00 	.word	0xe000ed00

0800039c <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
 800039c:	b530      	push	{r4, r5, lr}
  uint32_t tmp = 0;
  
  /* Check the DMA peripheral state */
  if(hdma == NULL)
 800039e:	2800      	cmp	r0, #0
 80003a0:	d032      	beq.n	8000408 <HAL_DMA_Init+0x6c>

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;

  /* Get the CR register value */
  tmp = hdma->Instance->CR;
 80003a2:	6801      	ldr	r1, [r0, #0]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR and CT bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 80003a4:	4d19      	ldr	r5, [pc, #100]	; (800040c <HAL_DMA_Init+0x70>)
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT  ));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 80003a6:	6842      	ldr	r2, [r0, #4]
  if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
 80003a8:	6a44      	ldr	r4, [r0, #36]	; 0x24
  hdma->State = HAL_DMA_STATE_BUSY;
 80003aa:	2302      	movs	r3, #2
 80003ac:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
  tmp = hdma->Instance->CR;
 80003b0:	680b      	ldr	r3, [r1, #0]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 80003b2:	401d      	ands	r5, r3
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 80003b4:	6883      	ldr	r3, [r0, #8]
 80003b6:	4313      	orrs	r3, r2
 80003b8:	68c2      	ldr	r2, [r0, #12]
 80003ba:	4313      	orrs	r3, r2
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80003bc:	6902      	ldr	r2, [r0, #16]
 80003be:	4313      	orrs	r3, r2
 80003c0:	6942      	ldr	r2, [r0, #20]
 80003c2:	4313      	orrs	r3, r2
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80003c4:	6982      	ldr	r2, [r0, #24]
 80003c6:	4313      	orrs	r3, r2
 80003c8:	69c2      	ldr	r2, [r0, #28]
 80003ca:	4313      	orrs	r3, r2
          hdma->Init.Mode                | hdma->Init.Priority;
 80003cc:	6a02      	ldr	r2, [r0, #32]

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 80003ce:	2c04      	cmp	r4, #4
          hdma->Init.Mode                | hdma->Init.Priority;
 80003d0:	ea43 0302 	orr.w	r3, r3, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 80003d4:	ea43 0305 	orr.w	r3, r3, r5
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 80003d8:	bf01      	itttt	eq
 80003da:	6ac2      	ldreq	r2, [r0, #44]	; 0x2c
 80003dc:	6b05      	ldreq	r5, [r0, #48]	; 0x30
 80003de:	432a      	orreq	r2, r5
 80003e0:	4313      	orreq	r3, r2
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 80003e2:	600b      	str	r3, [r1, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 80003e4:	694b      	ldr	r3, [r1, #20]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;

  /* the FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 80003e6:	2c04      	cmp	r4, #4
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 80003e8:	bf08      	it	eq
 80003ea:	6a82      	ldreq	r2, [r0, #40]	; 0x28
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 80003ec:	f023 0307 	bic.w	r3, r3, #7
  tmp |= hdma->Init.FIFOMode;
 80003f0:	ea43 0304 	orr.w	r3, r3, r4
    tmp |= hdma->Init.FIFOThreshold;
 80003f4:	bf08      	it	eq
 80003f6:	4313      	orreq	r3, r2
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
 80003f8:	614b      	str	r3, [r1, #20]

  /* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 80003fa:	2201      	movs	r2, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80003fc:	2300      	movs	r3, #0
 80003fe:	64c3      	str	r3, [r0, #76]	; 0x4c
  hdma->State = HAL_DMA_STATE_READY;
 8000400:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35

  return HAL_OK;
 8000404:	4618      	mov	r0, r3
 8000406:	bd30      	pop	{r4, r5, pc}
    return HAL_ERROR;
 8000408:	2001      	movs	r0, #1
}
 800040a:	bd30      	pop	{r4, r5, pc}
 800040c:	f014803f 	.word	0xf014803f

08000410 <HAL_DMA_DeInit>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
 8000410:	b510      	push	{r4, lr}
  /* Check the DMA peripheral state */
  if(hdma == NULL)
 8000412:	2800      	cmp	r0, #0
 8000414:	f000 81be 	beq.w	8000794 <HAL_DMA_DeInit+0x384>
  {
    return HAL_ERROR;
  }
  
  /* Check the DMA peripheral state */
  if(hdma->State == HAL_DMA_STATE_BUSY)
 8000418:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 800041c:	2b02      	cmp	r3, #2
 800041e:	f000 81b9 	beq.w	8000794 <HAL_DMA_DeInit+0x384>
  {
     return HAL_ERROR;
  }

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
 8000422:	6803      	ldr	r3, [r0, #0]
 8000424:	681a      	ldr	r2, [r3, #0]
 8000426:	f022 0201 	bic.w	r2, r2, #1
 800042a:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx control register */
  hdma->Instance->CR   = 0;
 800042c:	2200      	movs	r2, #0
 800042e:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx number of data to transfer register */
  hdma->Instance->NDTR = 0;
 8000430:	605a      	str	r2, [r3, #4]

  /* Reset DMA Streamx peripheral address register */
  hdma->Instance->PAR  = 0;
 8000432:	609a      	str	r2, [r3, #8]

  /* Reset DMA Streamx memory 0 address register */
  hdma->Instance->M0AR = 0;
 8000434:	60da      	str	r2, [r3, #12]

  /* Reset DMA Streamx memory 1 address register */
  hdma->Instance->M1AR = 0;
 8000436:	611a      	str	r2, [r3, #16]

  /* Reset DMA Streamx FIFO control register */
  hdma->Instance->FCR  = (uint32_t)0x00000021;
 8000438:	2221      	movs	r2, #33	; 0x21
 800043a:	615a      	str	r2, [r3, #20]

  /* Clear all flags */
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 800043c:	4ab4      	ldr	r2, [pc, #720]	; (8000710 <HAL_DMA_DeInit+0x300>)
 800043e:	4293      	cmp	r3, r2
 8000440:	d931      	bls.n	80004a6 <HAL_DMA_DeInit+0x96>
 8000442:	3218      	adds	r2, #24
 8000444:	4293      	cmp	r3, r2
 8000446:	d029      	beq.n	800049c <HAL_DMA_DeInit+0x8c>
 8000448:	49b2      	ldr	r1, [pc, #712]	; (8000714 <HAL_DMA_DeInit+0x304>)
 800044a:	428b      	cmp	r3, r1
 800044c:	d028      	beq.n	80004a0 <HAL_DMA_DeInit+0x90>
 800044e:	3118      	adds	r1, #24
 8000450:	428b      	cmp	r3, r1
 8000452:	bf0c      	ite	eq
 8000454:	f44f 2180 	moveq.w	r1, #262144	; 0x40000
 8000458:	f04f 7180 	movne.w	r1, #16777216	; 0x1000000
 800045c:	4cae      	ldr	r4, [pc, #696]	; (8000718 <HAL_DMA_DeInit+0x308>)
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800045e:	4293      	cmp	r3, r2
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8000460:	60e1      	str	r1, [r4, #12]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8000462:	f040 80a2 	bne.w	80005aa <HAL_DMA_DeInit+0x19a>
 8000466:	2120      	movs	r1, #32
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8000468:	4293      	cmp	r3, r2
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800046a:	60e1      	str	r1, [r4, #12]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800046c:	f040 80d5 	bne.w	800061a <HAL_DMA_DeInit+0x20a>
 8000470:	2108      	movs	r1, #8
 8000472:	4ca9      	ldr	r4, [pc, #676]	; (8000718 <HAL_DMA_DeInit+0x308>)
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8000474:	4293      	cmp	r3, r2
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8000476:	60e1      	str	r1, [r4, #12]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8000478:	f040 8107 	bne.w	800068a <HAL_DMA_DeInit+0x27a>
 800047c:	49a7      	ldr	r1, [pc, #668]	; (800071c <HAL_DMA_DeInit+0x30c>)
 800047e:	60e1      	str	r1, [r4, #12]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8000480:	4293      	cmp	r3, r2
 8000482:	f040 8136 	bne.w	80006f2 <HAL_DMA_DeInit+0x2e2>
 8000486:	2310      	movs	r3, #16
 8000488:	4aa3      	ldr	r2, [pc, #652]	; (8000718 <HAL_DMA_DeInit+0x308>)
 800048a:	60d3      	str	r3, [r2, #12]

  /* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800048c:	2300      	movs	r3, #0
 800048e:	64c3      	str	r3, [r0, #76]	; 0x4c

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hdma);
 8000490:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
  hdma->State = HAL_DMA_STATE_RESET;
 8000494:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35

  return HAL_OK;
 8000498:	4618      	mov	r0, r3
 800049a:	bd10      	pop	{r4, pc}
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 800049c:	49a0      	ldr	r1, [pc, #640]	; (8000720 <HAL_DMA_DeInit+0x310>)
 800049e:	e7dd      	b.n	800045c <HAL_DMA_DeInit+0x4c>
 80004a0:	f44f 7180 	mov.w	r1, #256	; 0x100
 80004a4:	e7da      	b.n	800045c <HAL_DMA_DeInit+0x4c>
 80004a6:	4a9f      	ldr	r2, [pc, #636]	; (8000724 <HAL_DMA_DeInit+0x314>)
 80004a8:	4293      	cmp	r3, r2
 80004aa:	d92a      	bls.n	8000502 <HAL_DMA_DeInit+0xf2>
 80004ac:	f502 7256 	add.w	r2, r2, #856	; 0x358
 80004b0:	4293      	cmp	r3, r2
 80004b2:	d021      	beq.n	80004f8 <HAL_DMA_DeInit+0xe8>
 80004b4:	499c      	ldr	r1, [pc, #624]	; (8000728 <HAL_DMA_DeInit+0x318>)
 80004b6:	428b      	cmp	r3, r1
 80004b8:	d020      	beq.n	80004fc <HAL_DMA_DeInit+0xec>
 80004ba:	3118      	adds	r1, #24
 80004bc:	428b      	cmp	r3, r1
 80004be:	bf0c      	ite	eq
 80004c0:	f44f 2180 	moveq.w	r1, #262144	; 0x40000
 80004c4:	f04f 7180 	movne.w	r1, #16777216	; 0x1000000
 80004c8:	4c93      	ldr	r4, [pc, #588]	; (8000718 <HAL_DMA_DeInit+0x308>)
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80004ca:	4293      	cmp	r3, r2
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80004cc:	60a1      	str	r1, [r4, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80004ce:	d17a      	bne.n	80005c6 <HAL_DMA_DeInit+0x1b6>
 80004d0:	2120      	movs	r1, #32
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80004d2:	4293      	cmp	r3, r2
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80004d4:	60a1      	str	r1, [r4, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80004d6:	f040 80ae 	bne.w	8000636 <HAL_DMA_DeInit+0x226>
 80004da:	2108      	movs	r1, #8
 80004dc:	4c8e      	ldr	r4, [pc, #568]	; (8000718 <HAL_DMA_DeInit+0x308>)
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80004de:	4293      	cmp	r3, r2
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80004e0:	60a1      	str	r1, [r4, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 80004e2:	f040 80df 	bne.w	80006a4 <HAL_DMA_DeInit+0x294>
 80004e6:	498d      	ldr	r1, [pc, #564]	; (800071c <HAL_DMA_DeInit+0x30c>)
 80004e8:	60a1      	str	r1, [r4, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80004ea:	4293      	cmp	r3, r2
 80004ec:	f040 8128 	bne.w	8000740 <HAL_DMA_DeInit+0x330>
 80004f0:	2310      	movs	r3, #16
 80004f2:	4a89      	ldr	r2, [pc, #548]	; (8000718 <HAL_DMA_DeInit+0x308>)
 80004f4:	6093      	str	r3, [r2, #8]
 80004f6:	e7c9      	b.n	800048c <HAL_DMA_DeInit+0x7c>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80004f8:	4989      	ldr	r1, [pc, #548]	; (8000720 <HAL_DMA_DeInit+0x310>)
 80004fa:	e7e5      	b.n	80004c8 <HAL_DMA_DeInit+0xb8>
 80004fc:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000500:	e7e2      	b.n	80004c8 <HAL_DMA_DeInit+0xb8>
 8000502:	4a8a      	ldr	r2, [pc, #552]	; (800072c <HAL_DMA_DeInit+0x31c>)
 8000504:	4293      	cmp	r3, r2
 8000506:	d928      	bls.n	800055a <HAL_DMA_DeInit+0x14a>
 8000508:	3218      	adds	r2, #24
 800050a:	4293      	cmp	r3, r2
 800050c:	d020      	beq.n	8000550 <HAL_DMA_DeInit+0x140>
 800050e:	4988      	ldr	r1, [pc, #544]	; (8000730 <HAL_DMA_DeInit+0x320>)
 8000510:	428b      	cmp	r3, r1
 8000512:	d01f      	beq.n	8000554 <HAL_DMA_DeInit+0x144>
 8000514:	3118      	adds	r1, #24
 8000516:	428b      	cmp	r3, r1
 8000518:	bf0c      	ite	eq
 800051a:	f44f 2180 	moveq.w	r1, #262144	; 0x40000
 800051e:	f04f 7180 	movne.w	r1, #16777216	; 0x1000000
 8000522:	4c84      	ldr	r4, [pc, #528]	; (8000734 <HAL_DMA_DeInit+0x324>)
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8000524:	4293      	cmp	r3, r2
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8000526:	60e1      	str	r1, [r4, #12]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8000528:	d15b      	bne.n	80005e2 <HAL_DMA_DeInit+0x1d2>
 800052a:	2120      	movs	r1, #32
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800052c:	4293      	cmp	r3, r2
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800052e:	60e1      	str	r1, [r4, #12]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8000530:	f040 808f 	bne.w	8000652 <HAL_DMA_DeInit+0x242>
 8000534:	2108      	movs	r1, #8
 8000536:	4c7f      	ldr	r4, [pc, #508]	; (8000734 <HAL_DMA_DeInit+0x324>)
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8000538:	4293      	cmp	r3, r2
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800053a:	60e1      	str	r1, [r4, #12]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 800053c:	f040 80bf 	bne.w	80006be <HAL_DMA_DeInit+0x2ae>
 8000540:	4976      	ldr	r1, [pc, #472]	; (800071c <HAL_DMA_DeInit+0x30c>)
 8000542:	60e1      	str	r1, [r4, #12]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8000544:	4293      	cmp	r3, r2
 8000546:	f040 8109 	bne.w	800075c <HAL_DMA_DeInit+0x34c>
 800054a:	2310      	movs	r3, #16
 800054c:	4a79      	ldr	r2, [pc, #484]	; (8000734 <HAL_DMA_DeInit+0x324>)
 800054e:	e79c      	b.n	800048a <HAL_DMA_DeInit+0x7a>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8000550:	4973      	ldr	r1, [pc, #460]	; (8000720 <HAL_DMA_DeInit+0x310>)
 8000552:	e7e6      	b.n	8000522 <HAL_DMA_DeInit+0x112>
 8000554:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000558:	e7e3      	b.n	8000522 <HAL_DMA_DeInit+0x112>
 800055a:	4a77      	ldr	r2, [pc, #476]	; (8000738 <HAL_DMA_DeInit+0x328>)
 800055c:	4293      	cmp	r3, r2
 800055e:	d01f      	beq.n	80005a0 <HAL_DMA_DeInit+0x190>
 8000560:	4976      	ldr	r1, [pc, #472]	; (800073c <HAL_DMA_DeInit+0x32c>)
 8000562:	428b      	cmp	r3, r1
 8000564:	d01e      	beq.n	80005a4 <HAL_DMA_DeInit+0x194>
 8000566:	3118      	adds	r1, #24
 8000568:	428b      	cmp	r3, r1
 800056a:	bf0c      	ite	eq
 800056c:	f44f 2180 	moveq.w	r1, #262144	; 0x40000
 8000570:	f04f 7180 	movne.w	r1, #16777216	; 0x1000000
 8000574:	4c6f      	ldr	r4, [pc, #444]	; (8000734 <HAL_DMA_DeInit+0x324>)
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8000576:	4293      	cmp	r3, r2
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8000578:	60a1      	str	r1, [r4, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800057a:	d140      	bne.n	80005fe <HAL_DMA_DeInit+0x1ee>
 800057c:	2120      	movs	r1, #32
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800057e:	4293      	cmp	r3, r2
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8000580:	60a1      	str	r1, [r4, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8000582:	d174      	bne.n	800066e <HAL_DMA_DeInit+0x25e>
 8000584:	2108      	movs	r1, #8
 8000586:	4c6b      	ldr	r4, [pc, #428]	; (8000734 <HAL_DMA_DeInit+0x324>)
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8000588:	4293      	cmp	r3, r2
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800058a:	60a1      	str	r1, [r4, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 800058c:	f040 80a4 	bne.w	80006d8 <HAL_DMA_DeInit+0x2c8>
 8000590:	4962      	ldr	r1, [pc, #392]	; (800071c <HAL_DMA_DeInit+0x30c>)
 8000592:	60a1      	str	r1, [r4, #8]
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8000594:	4293      	cmp	r3, r2
 8000596:	f040 80ef 	bne.w	8000778 <HAL_DMA_DeInit+0x368>
 800059a:	2310      	movs	r3, #16
 800059c:	4a65      	ldr	r2, [pc, #404]	; (8000734 <HAL_DMA_DeInit+0x324>)
 800059e:	e7a9      	b.n	80004f4 <HAL_DMA_DeInit+0xe4>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 80005a0:	495f      	ldr	r1, [pc, #380]	; (8000720 <HAL_DMA_DeInit+0x310>)
 80005a2:	e7e7      	b.n	8000574 <HAL_DMA_DeInit+0x164>
 80005a4:	f44f 7180 	mov.w	r1, #256	; 0x100
 80005a8:	e7e4      	b.n	8000574 <HAL_DMA_DeInit+0x164>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80005aa:	495a      	ldr	r1, [pc, #360]	; (8000714 <HAL_DMA_DeInit+0x304>)
 80005ac:	428b      	cmp	r3, r1
 80005ae:	d007      	beq.n	80005c0 <HAL_DMA_DeInit+0x1b0>
 80005b0:	3118      	adds	r1, #24
 80005b2:	428b      	cmp	r3, r1
 80005b4:	bf0c      	ite	eq
 80005b6:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 80005ba:	f04f 6100 	movne.w	r1, #134217728	; 0x8000000
 80005be:	e753      	b.n	8000468 <HAL_DMA_DeInit+0x58>
 80005c0:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80005c4:	e750      	b.n	8000468 <HAL_DMA_DeInit+0x58>
 80005c6:	4958      	ldr	r1, [pc, #352]	; (8000728 <HAL_DMA_DeInit+0x318>)
 80005c8:	428b      	cmp	r3, r1
 80005ca:	d007      	beq.n	80005dc <HAL_DMA_DeInit+0x1cc>
 80005cc:	3118      	adds	r1, #24
 80005ce:	428b      	cmp	r3, r1
 80005d0:	bf0c      	ite	eq
 80005d2:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 80005d6:	f04f 6100 	movne.w	r1, #134217728	; 0x8000000
 80005da:	e77a      	b.n	80004d2 <HAL_DMA_DeInit+0xc2>
 80005dc:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80005e0:	e777      	b.n	80004d2 <HAL_DMA_DeInit+0xc2>
 80005e2:	4953      	ldr	r1, [pc, #332]	; (8000730 <HAL_DMA_DeInit+0x320>)
 80005e4:	428b      	cmp	r3, r1
 80005e6:	d007      	beq.n	80005f8 <HAL_DMA_DeInit+0x1e8>
 80005e8:	3118      	adds	r1, #24
 80005ea:	428b      	cmp	r3, r1
 80005ec:	bf0c      	ite	eq
 80005ee:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 80005f2:	f04f 6100 	movne.w	r1, #134217728	; 0x8000000
 80005f6:	e799      	b.n	800052c <HAL_DMA_DeInit+0x11c>
 80005f8:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80005fc:	e796      	b.n	800052c <HAL_DMA_DeInit+0x11c>
 80005fe:	494f      	ldr	r1, [pc, #316]	; (800073c <HAL_DMA_DeInit+0x32c>)
 8000600:	428b      	cmp	r3, r1
 8000602:	d007      	beq.n	8000614 <HAL_DMA_DeInit+0x204>
 8000604:	3118      	adds	r1, #24
 8000606:	428b      	cmp	r3, r1
 8000608:	bf0c      	ite	eq
 800060a:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 800060e:	f04f 6100 	movne.w	r1, #134217728	; 0x8000000
 8000612:	e7b4      	b.n	800057e <HAL_DMA_DeInit+0x16e>
 8000614:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8000618:	e7b1      	b.n	800057e <HAL_DMA_DeInit+0x16e>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800061a:	493e      	ldr	r1, [pc, #248]	; (8000714 <HAL_DMA_DeInit+0x304>)
 800061c:	428b      	cmp	r3, r1
 800061e:	d007      	beq.n	8000630 <HAL_DMA_DeInit+0x220>
 8000620:	3118      	adds	r1, #24
 8000622:	428b      	cmp	r3, r1
 8000624:	bf0c      	ite	eq
 8000626:	f44f 2100 	moveq.w	r1, #524288	; 0x80000
 800062a:	f04f 7100 	movne.w	r1, #33554432	; 0x2000000
 800062e:	e720      	b.n	8000472 <HAL_DMA_DeInit+0x62>
 8000630:	f44f 7100 	mov.w	r1, #512	; 0x200
 8000634:	e71d      	b.n	8000472 <HAL_DMA_DeInit+0x62>
 8000636:	493c      	ldr	r1, [pc, #240]	; (8000728 <HAL_DMA_DeInit+0x318>)
 8000638:	428b      	cmp	r3, r1
 800063a:	d007      	beq.n	800064c <HAL_DMA_DeInit+0x23c>
 800063c:	3118      	adds	r1, #24
 800063e:	428b      	cmp	r3, r1
 8000640:	bf0c      	ite	eq
 8000642:	f44f 2100 	moveq.w	r1, #524288	; 0x80000
 8000646:	f04f 7100 	movne.w	r1, #33554432	; 0x2000000
 800064a:	e747      	b.n	80004dc <HAL_DMA_DeInit+0xcc>
 800064c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8000650:	e744      	b.n	80004dc <HAL_DMA_DeInit+0xcc>
 8000652:	4937      	ldr	r1, [pc, #220]	; (8000730 <HAL_DMA_DeInit+0x320>)
 8000654:	428b      	cmp	r3, r1
 8000656:	d007      	beq.n	8000668 <HAL_DMA_DeInit+0x258>
 8000658:	3118      	adds	r1, #24
 800065a:	428b      	cmp	r3, r1
 800065c:	bf0c      	ite	eq
 800065e:	f44f 2100 	moveq.w	r1, #524288	; 0x80000
 8000662:	f04f 7100 	movne.w	r1, #33554432	; 0x2000000
 8000666:	e766      	b.n	8000536 <HAL_DMA_DeInit+0x126>
 8000668:	f44f 7100 	mov.w	r1, #512	; 0x200
 800066c:	e763      	b.n	8000536 <HAL_DMA_DeInit+0x126>
 800066e:	4933      	ldr	r1, [pc, #204]	; (800073c <HAL_DMA_DeInit+0x32c>)
 8000670:	428b      	cmp	r3, r1
 8000672:	d007      	beq.n	8000684 <HAL_DMA_DeInit+0x274>
 8000674:	3118      	adds	r1, #24
 8000676:	428b      	cmp	r3, r1
 8000678:	bf0c      	ite	eq
 800067a:	f44f 2100 	moveq.w	r1, #524288	; 0x80000
 800067e:	f04f 7100 	movne.w	r1, #33554432	; 0x2000000
 8000682:	e780      	b.n	8000586 <HAL_DMA_DeInit+0x176>
 8000684:	f44f 7100 	mov.w	r1, #512	; 0x200
 8000688:	e77d      	b.n	8000586 <HAL_DMA_DeInit+0x176>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 800068a:	4922      	ldr	r1, [pc, #136]	; (8000714 <HAL_DMA_DeInit+0x304>)
 800068c:	428b      	cmp	r3, r1
 800068e:	d007      	beq.n	80006a0 <HAL_DMA_DeInit+0x290>
 8000690:	3118      	adds	r1, #24
 8000692:	428b      	cmp	r3, r1
 8000694:	bf0c      	ite	eq
 8000696:	f44f 3180 	moveq.w	r1, #65536	; 0x10000
 800069a:	f44f 0180 	movne.w	r1, #4194304	; 0x400000
 800069e:	e6ee      	b.n	800047e <HAL_DMA_DeInit+0x6e>
 80006a0:	2140      	movs	r1, #64	; 0x40
 80006a2:	e6ec      	b.n	800047e <HAL_DMA_DeInit+0x6e>
 80006a4:	4920      	ldr	r1, [pc, #128]	; (8000728 <HAL_DMA_DeInit+0x318>)
 80006a6:	428b      	cmp	r3, r1
 80006a8:	d007      	beq.n	80006ba <HAL_DMA_DeInit+0x2aa>
 80006aa:	3118      	adds	r1, #24
 80006ac:	428b      	cmp	r3, r1
 80006ae:	bf0c      	ite	eq
 80006b0:	f44f 3180 	moveq.w	r1, #65536	; 0x10000
 80006b4:	f44f 0180 	movne.w	r1, #4194304	; 0x400000
 80006b8:	e716      	b.n	80004e8 <HAL_DMA_DeInit+0xd8>
 80006ba:	2140      	movs	r1, #64	; 0x40
 80006bc:	e714      	b.n	80004e8 <HAL_DMA_DeInit+0xd8>
 80006be:	491c      	ldr	r1, [pc, #112]	; (8000730 <HAL_DMA_DeInit+0x320>)
 80006c0:	428b      	cmp	r3, r1
 80006c2:	d007      	beq.n	80006d4 <HAL_DMA_DeInit+0x2c4>
 80006c4:	3118      	adds	r1, #24
 80006c6:	428b      	cmp	r3, r1
 80006c8:	bf0c      	ite	eq
 80006ca:	f44f 3180 	moveq.w	r1, #65536	; 0x10000
 80006ce:	f44f 0180 	movne.w	r1, #4194304	; 0x400000
 80006d2:	e736      	b.n	8000542 <HAL_DMA_DeInit+0x132>
 80006d4:	2140      	movs	r1, #64	; 0x40
 80006d6:	e734      	b.n	8000542 <HAL_DMA_DeInit+0x132>
 80006d8:	4918      	ldr	r1, [pc, #96]	; (800073c <HAL_DMA_DeInit+0x32c>)
 80006da:	428b      	cmp	r3, r1
 80006dc:	d007      	beq.n	80006ee <HAL_DMA_DeInit+0x2de>
 80006de:	3118      	adds	r1, #24
 80006e0:	428b      	cmp	r3, r1
 80006e2:	bf0c      	ite	eq
 80006e4:	f44f 3180 	moveq.w	r1, #65536	; 0x10000
 80006e8:	f44f 0180 	movne.w	r1, #4194304	; 0x400000
 80006ec:	e751      	b.n	8000592 <HAL_DMA_DeInit+0x182>
 80006ee:	2140      	movs	r1, #64	; 0x40
 80006f0:	e74f      	b.n	8000592 <HAL_DMA_DeInit+0x182>
  __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80006f2:	4a08      	ldr	r2, [pc, #32]	; (8000714 <HAL_DMA_DeInit+0x304>)
 80006f4:	4293      	cmp	r3, r2
 80006f6:	d007      	beq.n	8000708 <HAL_DMA_DeInit+0x2f8>
 80006f8:	3218      	adds	r2, #24
 80006fa:	4293      	cmp	r3, r2
 80006fc:	bf0c      	ite	eq
 80006fe:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 8000702:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8000706:	e6bf      	b.n	8000488 <HAL_DMA_DeInit+0x78>
 8000708:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800070c:	e6bc      	b.n	8000488 <HAL_DMA_DeInit+0x78>
 800070e:	bf00      	nop
 8000710:	40026458 	.word	0x40026458
 8000714:	40026488 	.word	0x40026488
 8000718:	40026400 	.word	0x40026400
 800071c:	00800001 	.word	0x00800001
 8000720:	00800004 	.word	0x00800004
 8000724:	400260b8 	.word	0x400260b8
 8000728:	40026428 	.word	0x40026428
 800072c:	40026058 	.word	0x40026058
 8000730:	40026088 	.word	0x40026088
 8000734:	40026000 	.word	0x40026000
 8000738:	40026010 	.word	0x40026010
 800073c:	40026028 	.word	0x40026028
 8000740:	4a15      	ldr	r2, [pc, #84]	; (8000798 <HAL_DMA_DeInit+0x388>)
 8000742:	4293      	cmp	r3, r2
 8000744:	d007      	beq.n	8000756 <HAL_DMA_DeInit+0x346>
 8000746:	3218      	adds	r2, #24
 8000748:	4293      	cmp	r3, r2
 800074a:	bf0c      	ite	eq
 800074c:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 8000750:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8000754:	e6cd      	b.n	80004f2 <HAL_DMA_DeInit+0xe2>
 8000756:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800075a:	e6ca      	b.n	80004f2 <HAL_DMA_DeInit+0xe2>
 800075c:	4a0f      	ldr	r2, [pc, #60]	; (800079c <HAL_DMA_DeInit+0x38c>)
 800075e:	4293      	cmp	r3, r2
 8000760:	d007      	beq.n	8000772 <HAL_DMA_DeInit+0x362>
 8000762:	3218      	adds	r2, #24
 8000764:	4293      	cmp	r3, r2
 8000766:	bf0c      	ite	eq
 8000768:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 800076c:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8000770:	e6ec      	b.n	800054c <HAL_DMA_DeInit+0x13c>
 8000772:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000776:	e6e9      	b.n	800054c <HAL_DMA_DeInit+0x13c>
 8000778:	4a09      	ldr	r2, [pc, #36]	; (80007a0 <HAL_DMA_DeInit+0x390>)
 800077a:	4293      	cmp	r3, r2
 800077c:	d007      	beq.n	800078e <HAL_DMA_DeInit+0x37e>
 800077e:	3218      	adds	r2, #24
 8000780:	4293      	cmp	r3, r2
 8000782:	bf0c      	ite	eq
 8000784:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 8000788:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 800078c:	e706      	b.n	800059c <HAL_DMA_DeInit+0x18c>
 800078e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000792:	e703      	b.n	800059c <HAL_DMA_DeInit+0x18c>
    return HAL_ERROR;
 8000794:	2001      	movs	r0, #1
}
 8000796:	bd10      	pop	{r4, pc}
 8000798:	40026428 	.word	0x40026428
 800079c:	40026088 	.word	0x40026088
 80007a0:	40026028 	.word	0x40026028

080007a4 <DMA2D_SetConfig>:
  * @param  Width:      The width of data to be transferred from source to destination.
  * @param  Heigh:      The heigh of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width, uint32_t Heigh)
{  
 80007a4:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmp4 = 0;
  
  tmp = Width << 16;
  
  /* Configure DMA2D data size */
  hdma2d->Instance->NLR = (Heigh | tmp);
 80007a6:	9d04      	ldr	r5, [sp, #16]
 80007a8:	6804      	ldr	r4, [r0, #0]
 80007aa:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 80007ae:	6463      	str	r3, [r4, #68]	; 0x44
  
  /* Configure DMA2D destination address */
  hdma2d->Instance->OMAR = DstAddress;
 
  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
 80007b0:	6843      	ldr	r3, [r0, #4]
  hdma2d->Instance->OMAR = DstAddress;
 80007b2:	63e2      	str	r2, [r4, #60]	; 0x3c
  if (hdma2d->Init.Mode == DMA2D_R2M)
 80007b4:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 80007b8:	d130      	bne.n	800081c <DMA2D_SetConfig+0x78>
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
    
    /* Prepare the value to be wrote to the OCOLR register according to the color mode */
    if (hdma2d->Init.ColorMode == DMA2D_ARGB8888)
 80007ba:	6886      	ldr	r6, [r0, #8]
 80007bc:	b11e      	cbz	r6, 80007c6 <DMA2D_SetConfig+0x22>
    {
      tmp = (tmp3 | tmp2 | tmp1| tmp4);
    }
    else if (hdma2d->Init.ColorMode == DMA2D_RGB888)
 80007be:	2e01      	cmp	r6, #1
 80007c0:	d103      	bne.n	80007ca <DMA2D_SetConfig+0x26>
    {
      tmp = (tmp3 | tmp2 | tmp4);  
 80007c2:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
      tmp3 = (tmp3 >> 12);
      tmp4 = (tmp4 >> 4 );
      tmp  = ((tmp3 << 4) | (tmp2 << 8) | (tmp1 << 12) | tmp4);
    }    
    /* Write to DMA2D OCOLR register */
    hdma2d->Instance->OCOLR = tmp;
 80007c6:	63a1      	str	r1, [r4, #56]	; 0x38
 80007c8:	bd70      	pop	{r4, r5, r6, pc}
    else if (hdma2d->Init.ColorMode == DMA2D_RGB565)
 80007ca:	2e02      	cmp	r6, #2
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
 80007cc:	f401 037f 	and.w	r3, r1, #16711680	; 0xff0000
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
 80007d0:	f401 457f 	and.w	r5, r1, #65280	; 0xff00
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
 80007d4:	b2c8      	uxtb	r0, r1
    else if (hdma2d->Init.ColorMode == DMA2D_RGB565)
 80007d6:	d107      	bne.n	80007e8 <DMA2D_SetConfig+0x44>
      tmp2 = (tmp2 >> 19);
 80007d8:	0cd9      	lsrs	r1, r3, #19
      tmp3 = (tmp3 >> 10);
 80007da:	0aad      	lsrs	r5, r5, #10
      tmp  = ((tmp3 << 5) | (tmp2 << 11) | tmp4); 
 80007dc:	02c9      	lsls	r1, r1, #11
 80007de:	ea41 1145 	orr.w	r1, r1, r5, lsl #5
 80007e2:	ea41 01d0 	orr.w	r1, r1, r0, lsr #3
 80007e6:	e7ee      	b.n	80007c6 <DMA2D_SetConfig+0x22>
    else if (hdma2d->Init.ColorMode == DMA2D_ARGB1555)
 80007e8:	2e03      	cmp	r6, #3
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
 80007ea:	f001 427f 	and.w	r2, r1, #4278190080	; 0xff000000
    else if (hdma2d->Init.ColorMode == DMA2D_ARGB1555)
 80007ee:	d10a      	bne.n	8000806 <DMA2D_SetConfig+0x62>
      tmp2 = (tmp2 >> 19);
 80007f0:	0cdb      	lsrs	r3, r3, #19
      tmp3 = (tmp3 >> 11);
 80007f2:	0aed      	lsrs	r5, r5, #11
      tmp  = ((tmp3 << 5) | (tmp2 << 10) | (tmp1 << 15) | tmp4);    
 80007f4:	029b      	lsls	r3, r3, #10
 80007f6:	ea43 1345 	orr.w	r3, r3, r5, lsl #5
 80007fa:	ea43 03d0 	orr.w	r3, r3, r0, lsr #3
      tmp1 = (tmp1 >> 31);
 80007fe:	0fd1      	lsrs	r1, r2, #31
      tmp  = ((tmp3 << 5) | (tmp2 << 10) | (tmp1 << 15) | tmp4);    
 8000800:	ea43 31c1 	orr.w	r1, r3, r1, lsl #15
 8000804:	e7df      	b.n	80007c6 <DMA2D_SetConfig+0x22>
      tmp2 = (tmp2 >> 20);
 8000806:	0d19      	lsrs	r1, r3, #20
      tmp3 = (tmp3 >> 12);
 8000808:	0b2d      	lsrs	r5, r5, #12
      tmp  = ((tmp3 << 4) | (tmp2 << 8) | (tmp1 << 12) | tmp4);
 800080a:	0209      	lsls	r1, r1, #8
 800080c:	ea41 1105 	orr.w	r1, r1, r5, lsl #4
 8000810:	ea41 1110 	orr.w	r1, r1, r0, lsr #4
      tmp1 = (tmp1 >> 28);
 8000814:	0f13      	lsrs	r3, r2, #28
      tmp  = ((tmp3 << 4) | (tmp2 << 8) | (tmp1 << 12) | tmp4);
 8000816:	ea41 3103 	orr.w	r1, r1, r3, lsl #12
 800081a:	e7d4      	b.n	80007c6 <DMA2D_SetConfig+0x22>
  } 
  else /* M2M, M2M_PFC or M2M_Blending DMA2D Mode */
  {
    /* Configure DMA2D source address */
    hdma2d->Instance->FGMAR = pdata;
 800081c:	60e1      	str	r1, [r4, #12]
 800081e:	bd70      	pop	{r4, r5, r6, pc}

08000820 <HAL_DMA2D_MspInit>:
 8000820:	4770      	bx	lr

08000822 <HAL_DMA2D_Init>:
{ 
 8000822:	b510      	push	{r4, lr}
  if(hdma2d == NULL)
 8000824:	4604      	mov	r4, r0
 8000826:	b310      	cbz	r0, 800086e <HAL_DMA2D_Init+0x4c>
  if(hdma2d->State == HAL_DMA2D_STATE_RESET)
 8000828:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 800082c:	b90b      	cbnz	r3, 8000832 <HAL_DMA2D_Init+0x10>
    HAL_DMA2D_MspInit(hdma2d);
 800082e:	f7ff fff7 	bl	8000820 <HAL_DMA2D_MspInit>
  tmp = hdma2d->Instance->CR;
 8000832:	6822      	ldr	r2, [r4, #0]
  tmp |= hdma2d->Init.Mode;
 8000834:	6861      	ldr	r1, [r4, #4]
  hdma2d->State = HAL_DMA2D_STATE_BUSY;  
 8000836:	2302      	movs	r3, #2
 8000838:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  tmp = hdma2d->Instance->CR;
 800083c:	6813      	ldr	r3, [r2, #0]
  tmp &= (uint32_t)~DMA2D_CR_MODE;
 800083e:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
  tmp |= hdma2d->Init.Mode;
 8000842:	430b      	orrs	r3, r1
  hdma2d->Instance->CR = tmp;
 8000844:	6013      	str	r3, [r2, #0]
  tmp = hdma2d->Instance->OPFCCR;
 8000846:	6b53      	ldr	r3, [r2, #52]	; 0x34
  tmp |= hdma2d->Init.ColorMode;
 8000848:	68a1      	ldr	r1, [r4, #8]
  tmp &= (uint32_t)~DMA2D_OPFCCR_CM;
 800084a:	f023 0307 	bic.w	r3, r3, #7
  tmp |= hdma2d->Init.ColorMode;
 800084e:	430b      	orrs	r3, r1
  hdma2d->Instance->OPFCCR = tmp;
 8000850:	6353      	str	r3, [r2, #52]	; 0x34
  tmp = hdma2d->Instance->OOR;
 8000852:	6c13      	ldr	r3, [r2, #64]	; 0x40
  tmp |= hdma2d->Init.OutputOffset;
 8000854:	68e1      	ldr	r1, [r4, #12]
  tmp &= (uint32_t)~DMA2D_OOR_LO;
 8000856:	f423 537f 	bic.w	r3, r3, #16320	; 0x3fc0
 800085a:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
  tmp |= hdma2d->Init.OutputOffset;
 800085e:	430b      	orrs	r3, r1
  hdma2d->Instance->OOR = tmp;
 8000860:	6413      	str	r3, [r2, #64]	; 0x40
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 8000862:	2000      	movs	r0, #0
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 8000864:	2301      	movs	r3, #1
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 8000866:	63e0      	str	r0, [r4, #60]	; 0x3c
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 8000868:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  return HAL_OK;
 800086c:	bd10      	pop	{r4, pc}
     return HAL_ERROR;
 800086e:	2001      	movs	r0, #1
}
 8000870:	bd10      	pop	{r4, pc}

08000872 <HAL_DMA2D_Start>:
{
 8000872:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __HAL_LOCK(hdma2d);
 8000874:	f890 4038 	ldrb.w	r4, [r0, #56]	; 0x38
 8000878:	2c01      	cmp	r4, #1
{
 800087a:	4605      	mov	r5, r0
 800087c:	f04f 0402 	mov.w	r4, #2
  __HAL_LOCK(hdma2d);
 8000880:	d015      	beq.n	80008ae <HAL_DMA2D_Start+0x3c>
 8000882:	2601      	movs	r6, #1
 8000884:	f880 6038 	strb.w	r6, [r0, #56]	; 0x38
  __HAL_DMA2D_DISABLE(hdma2d);
 8000888:	6806      	ldr	r6, [r0, #0]
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 800088a:	f880 4039 	strb.w	r4, [r0, #57]	; 0x39
  __HAL_DMA2D_DISABLE(hdma2d);
 800088e:	6834      	ldr	r4, [r6, #0]
 8000890:	f024 0401 	bic.w	r4, r4, #1
 8000894:	6034      	str	r4, [r6, #0]
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Heigh);
 8000896:	9c06      	ldr	r4, [sp, #24]
 8000898:	9400      	str	r4, [sp, #0]
 800089a:	f7ff ff83 	bl	80007a4 <DMA2D_SetConfig>
  __HAL_DMA2D_ENABLE(hdma2d);
 800089e:	682a      	ldr	r2, [r5, #0]
 80008a0:	6813      	ldr	r3, [r2, #0]
 80008a2:	f043 0301 	orr.w	r3, r3, #1
 80008a6:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 80008a8:	2000      	movs	r0, #0
}
 80008aa:	b002      	add	sp, #8
 80008ac:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hdma2d);
 80008ae:	4620      	mov	r0, r4
 80008b0:	e7fb      	b.n	80008aa <HAL_DMA2D_Start+0x38>

080008b2 <HAL_DMA2D_PollForTransfer>:
  if((hdma2d->Instance->CR & DMA2D_CR_START) != 0)
 80008b2:	6803      	ldr	r3, [r0, #0]
 80008b4:	681b      	ldr	r3, [r3, #0]
 80008b6:	07db      	lsls	r3, r3, #31
{
 80008b8:	b570      	push	{r4, r5, r6, lr}
 80008ba:	4604      	mov	r4, r0
 80008bc:	460d      	mov	r5, r1
  if((hdma2d->Instance->CR & DMA2D_CR_START) != 0)
 80008be:	d416      	bmi.n	80008ee <HAL_DMA2D_PollForTransfer+0x3c>
  if((hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START) != 0)
 80008c0:	6823      	ldr	r3, [r4, #0]
 80008c2:	69db      	ldr	r3, [r3, #28]
 80008c4:	069e      	lsls	r6, r3, #26
 80008c6:	d506      	bpl.n	80008d6 <HAL_DMA2D_PollForTransfer+0x24>
    tickstart = HAL_GetTick();
 80008c8:	f7ff fcec 	bl	80002a4 <HAL_GetTick>
 80008cc:	4606      	mov	r6, r0
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == RESET)
 80008ce:	6823      	ldr	r3, [r4, #0]
 80008d0:	685a      	ldr	r2, [r3, #4]
 80008d2:	06d2      	lsls	r2, r2, #27
 80008d4:	d539      	bpl.n	800094a <HAL_DMA2D_PollForTransfer+0x98>
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC);
 80008d6:	6823      	ldr	r3, [r4, #0]
 80008d8:	2202      	movs	r2, #2
 80008da:	609a      	str	r2, [r3, #8]
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CTC);  
 80008dc:	2210      	movs	r2, #16
 80008de:	609a      	str	r2, [r3, #8]
  __HAL_UNLOCK(hdma2d);
 80008e0:	2000      	movs	r0, #0
  hdma2d->State = HAL_DMA2D_STATE_READY;
 80008e2:	2301      	movs	r3, #1
 80008e4:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  __HAL_UNLOCK(hdma2d);
 80008e8:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
  return HAL_OK;
 80008ec:	bd70      	pop	{r4, r5, r6, pc}
   tickstart = HAL_GetTick();
 80008ee:	f7ff fcd9 	bl	80002a4 <HAL_GetTick>
 80008f2:	4606      	mov	r6, r0
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == RESET)
 80008f4:	6823      	ldr	r3, [r4, #0]
 80008f6:	685a      	ldr	r2, [r3, #4]
 80008f8:	0792      	lsls	r2, r2, #30
 80008fa:	d4e1      	bmi.n	80008c0 <HAL_DMA2D_PollForTransfer+0xe>
      tmp  = __HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CE);
 80008fc:	6859      	ldr	r1, [r3, #4]
      tmp1 = __HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TE);
 80008fe:	685a      	ldr	r2, [r3, #4]
      if((tmp != RESET) || (tmp1 != RESET))
 8000900:	0688      	lsls	r0, r1, #26
      tmp1 = __HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TE);
 8000902:	f002 0201 	and.w	r2, r2, #1
      if((tmp != RESET) || (tmp1 != RESET))
 8000906:	d50a      	bpl.n	800091e <HAL_DMA2D_PollForTransfer+0x6c>
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE);
 8000908:	2220      	movs	r2, #32
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TE);
 800090a:	2001      	movs	r0, #1
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE);
 800090c:	609a      	str	r2, [r3, #8]
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TE);
 800090e:	6098      	str	r0, [r3, #8]
        hdma2d->State= HAL_DMA2D_STATE_ERROR;
 8000910:	2304      	movs	r3, #4
 8000912:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
        __HAL_UNLOCK(hdma2d);
 8000916:	2300      	movs	r3, #0
 8000918:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
        return HAL_ERROR;
 800091c:	bd70      	pop	{r4, r5, r6, pc}
      if((tmp != RESET) || (tmp1 != RESET))
 800091e:	2a00      	cmp	r2, #0
 8000920:	d1f2      	bne.n	8000908 <HAL_DMA2D_PollForTransfer+0x56>
      if(Timeout != HAL_MAX_DELAY)
 8000922:	1c69      	adds	r1, r5, #1
 8000924:	d0e7      	beq.n	80008f6 <HAL_DMA2D_PollForTransfer+0x44>
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8000926:	b955      	cbnz	r5, 800093e <HAL_DMA2D_PollForTransfer+0x8c>
          __HAL_UNLOCK(hdma2d);
 8000928:	2300      	movs	r3, #0
 800092a:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
 800092e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
          hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
 8000930:	2003      	movs	r0, #3
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
 8000932:	f043 0320 	orr.w	r3, r3, #32
 8000936:	63e3      	str	r3, [r4, #60]	; 0x3c
          hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
 8000938:	f884 0039 	strb.w	r0, [r4, #57]	; 0x39
          return HAL_TIMEOUT;
 800093c:	bd70      	pop	{r4, r5, r6, pc}
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 800093e:	f7ff fcb1 	bl	80002a4 <HAL_GetTick>
 8000942:	1b80      	subs	r0, r0, r6
 8000944:	4285      	cmp	r5, r0
 8000946:	d2d5      	bcs.n	80008f4 <HAL_DMA2D_PollForTransfer+0x42>
 8000948:	e7ee      	b.n	8000928 <HAL_DMA2D_PollForTransfer+0x76>
      if((__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CAE) != RESET))
 800094a:	685a      	ldr	r2, [r3, #4]
 800094c:	0710      	lsls	r0, r2, #28
 800094e:	d506      	bpl.n	800095e <HAL_DMA2D_PollForTransfer+0xac>
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE);
 8000950:	2208      	movs	r2, #8
 8000952:	609a      	str	r2, [r3, #8]
        hdma2d->State= HAL_DMA2D_STATE_ERROR;
 8000954:	2304      	movs	r3, #4
 8000956:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
        return HAL_ERROR;      
 800095a:	2001      	movs	r0, #1
 800095c:	bd70      	pop	{r4, r5, r6, pc}
      if(Timeout != HAL_MAX_DELAY)
 800095e:	1c69      	adds	r1, r5, #1
 8000960:	d0b6      	beq.n	80008d0 <HAL_DMA2D_PollForTransfer+0x1e>
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8000962:	2d00      	cmp	r5, #0
 8000964:	d0e3      	beq.n	800092e <HAL_DMA2D_PollForTransfer+0x7c>
 8000966:	f7ff fc9d 	bl	80002a4 <HAL_GetTick>
 800096a:	1b80      	subs	r0, r0, r6
 800096c:	4285      	cmp	r5, r0
 800096e:	d2ae      	bcs.n	80008ce <HAL_DMA2D_PollForTransfer+0x1c>
 8000970:	e7dd      	b.n	800092e <HAL_DMA2D_PollForTransfer+0x7c>
	...

08000974 <HAL_DMA2D_ConfigLayer>:
  __HAL_LOCK(hdma2d);
 8000974:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8000978:	2b01      	cmp	r3, #1
{ 
 800097a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800097c:	f04f 0302 	mov.w	r3, #2
  __HAL_LOCK(hdma2d);
 8000980:	d02d      	beq.n	80009de <HAL_DMA2D_ConfigLayer+0x6a>
 8000982:	2201      	movs	r2, #1
  hdma2d->State = HAL_DMA2D_STATE_BUSY; 
 8000984:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  __HAL_LOCK(hdma2d);
 8000988:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
 800098c:	6803      	ldr	r3, [r0, #0]
 800098e:	4f30      	ldr	r7, [pc, #192]	; (8000a50 <HAL_DMA2D_ConfigLayer+0xdc>)
  if(LayerIdx == 0)
 8000990:	bb39      	cbnz	r1, 80009e2 <HAL_DMA2D_ConfigLayer+0x6e>
    if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
 8000992:	69c6      	ldr	r6, [r0, #28]
    tmp = hdma2d->Instance->BGPFCCR;
 8000994:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000996:	6a41      	ldr	r1, [r0, #36]	; 0x24
    if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
 8000998:	f1a6 0509 	sub.w	r5, r6, #9
 800099c:	2d01      	cmp	r5, #1
    tmp &= (uint32_t)~(DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA); 
 800099e:	ea02 0207 	and.w	r2, r2, r7
 80009a2:	6a07      	ldr	r7, [r0, #32]
      tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | ((pLayerCfg->InputAlpha) & 0xFF000000));
 80009a4:	bf94      	ite	ls
 80009a6:	f001 447f 	andls.w	r4, r1, #4278190080	; 0xff000000
      tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | (pLayerCfg->InputAlpha << 24));
 80009aa:	060c      	lslhi	r4, r1, #24
 80009ac:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
 80009b0:	4334      	orrs	r4, r6
 80009b2:	4322      	orrs	r2, r4
    hdma2d->Instance->BGPFCCR = tmp; 
 80009b4:	625a      	str	r2, [r3, #36]	; 0x24
    tmp = hdma2d->Instance->BGOR;
 80009b6:	699a      	ldr	r2, [r3, #24]
    tmp |= pLayerCfg->InputOffset;
 80009b8:	6984      	ldr	r4, [r0, #24]
    tmp &= (uint32_t)~DMA2D_BGOR_LO; 
 80009ba:	f422 527f 	bic.w	r2, r2, #16320	; 0x3fc0
 80009be:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
    tmp |= pLayerCfg->InputOffset;
 80009c2:	4322      	orrs	r2, r4
    if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
 80009c4:	2d01      	cmp	r5, #1
    hdma2d->Instance->BGOR = tmp;
 80009c6:	619a      	str	r2, [r3, #24]
    if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
 80009c8:	d803      	bhi.n	80009d2 <HAL_DMA2D_ConfigLayer+0x5e>
      tmp |= ((pLayerCfg->InputAlpha) & 0x00FFFFFF);
 80009ca:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 80009ce:	430a      	orrs	r2, r1
      hdma2d->Instance->BGCOLR = tmp;
 80009d0:	629a      	str	r2, [r3, #40]	; 0x28
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 80009d2:	2301      	movs	r3, #1
 80009d4:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  __HAL_UNLOCK(hdma2d);  
 80009d8:	2300      	movs	r3, #0
 80009da:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
  __HAL_LOCK(hdma2d);
 80009de:	4618      	mov	r0, r3
}
 80009e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
 80009e2:	010e      	lsls	r6, r1, #4
 80009e4:	eb00 0e06 	add.w	lr, r0, r6
    tmp = hdma2d->Instance->FGPFCCR;
 80009e8:	69da      	ldr	r2, [r3, #28]
    if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
 80009ea:	f8de c01c 	ldr.w	ip, [lr, #28]
 80009ee:	f1ac 0509 	sub.w	r5, ip, #9
 80009f2:	2d01      	cmp	r5, #1
    tmp &= (uint32_t)~(DMA2D_FGPFCCR_CM | DMA2D_FGPFCCR_AM | DMA2D_FGPFCCR_ALPHA); 
 80009f4:	ea07 0702 	and.w	r7, r7, r2
    if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
 80009f8:	d81e      	bhi.n	8000a38 <HAL_DMA2D_ConfigLayer+0xc4>
      tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | ((pLayerCfg->InputAlpha) & 0xFF000000));
 80009fa:	f8de 4024 	ldr.w	r4, [lr, #36]	; 0x24
 80009fe:	f8de 2020 	ldr.w	r2, [lr, #32]
 8000a02:	f004 447f 	and.w	r4, r4, #4278190080	; 0xff000000
 8000a06:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8000a0a:	ea44 040c 	orr.w	r4, r4, ip
 8000a0e:	4327      	orrs	r7, r4
    hdma2d->Instance->FGPFCCR = tmp; 
 8000a10:	61df      	str	r7, [r3, #28]
    tmp = hdma2d->Instance->FGOR;
 8000a12:	691a      	ldr	r2, [r3, #16]
    tmp |= pLayerCfg->InputOffset;
 8000a14:	4406      	add	r6, r0
    tmp &= (uint32_t)~DMA2D_FGOR_LO; 
 8000a16:	f422 527f 	bic.w	r2, r2, #16320	; 0x3fc0
    tmp |= pLayerCfg->InputOffset;
 8000a1a:	69b4      	ldr	r4, [r6, #24]
    tmp &= (uint32_t)~DMA2D_FGOR_LO; 
 8000a1c:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
    tmp |= pLayerCfg->InputOffset;
 8000a20:	4322      	orrs	r2, r4
    if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
 8000a22:	2d01      	cmp	r5, #1
    hdma2d->Instance->FGOR = tmp;
 8000a24:	611a      	str	r2, [r3, #16]
    if ((pLayerCfg->InputColorMode == CM_A4) || (pLayerCfg->InputColorMode == CM_A8))
 8000a26:	d8d4      	bhi.n	80009d2 <HAL_DMA2D_ConfigLayer+0x5e>
      tmp |= ((pLayerCfg->InputAlpha) & 0x00FFFFFF);
 8000a28:	eb00 1101 	add.w	r1, r0, r1, lsl #4
 8000a2c:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8000a2e:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8000a32:	430a      	orrs	r2, r1
      hdma2d->Instance->FGCOLR = tmp;
 8000a34:	621a      	str	r2, [r3, #32]
 8000a36:	e7cc      	b.n	80009d2 <HAL_DMA2D_ConfigLayer+0x5e>
      tmp |= (pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << 16) | (pLayerCfg->InputAlpha << 24));
 8000a38:	f8de 2024 	ldr.w	r2, [lr, #36]	; 0x24
 8000a3c:	f8de 4020 	ldr.w	r4, [lr, #32]
 8000a40:	0612      	lsls	r2, r2, #24
 8000a42:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
 8000a46:	ea42 020c 	orr.w	r2, r2, ip
 8000a4a:	4317      	orrs	r7, r2
 8000a4c:	e7e0      	b.n	8000a10 <HAL_DMA2D_ConfigLayer+0x9c>
 8000a4e:	bf00      	nop
 8000a50:	00fcfff0 	.word	0x00fcfff0

08000a54 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000a54:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  for(position = 0; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000a58:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __SYSCFG_CLK_ENABLE();
 8000a5a:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 8000c10 <HAL_GPIO_Init+0x1bc>
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GET_GPIO_SOURCE(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000a5e:	4a6a      	ldr	r2, [pc, #424]	; (8000c08 <HAL_GPIO_Init+0x1b4>)
        temp |= ((uint32_t)(GET_GPIO_SOURCE(GPIOx)) << (4 * (position & 0x03)));
 8000a60:	f8df 91b0 	ldr.w	r9, [pc, #432]	; 8000c14 <HAL_GPIO_Init+0x1c0>
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000a64:	9301      	str	r3, [sp, #4]
  for(position = 0; position < GPIO_NUMBER; position++)
 8000a66:	2300      	movs	r3, #0
    ioposition = ((uint32_t)0x01) << position;
 8000a68:	f04f 0e01 	mov.w	lr, #1
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000a6c:	9c01      	ldr	r4, [sp, #4]
    ioposition = ((uint32_t)0x01) << position;
 8000a6e:	fa0e fe03 	lsl.w	lr, lr, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000a72:	ea0e 0604 	and.w	r6, lr, r4
    if(iocurrent == ioposition)
 8000a76:	45b6      	cmp	lr, r6
 8000a78:	f040 80ac 	bne.w	8000bd4 <HAL_GPIO_Init+0x180>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000a7c:	684c      	ldr	r4, [r1, #4]
 8000a7e:	f024 0710 	bic.w	r7, r4, #16
 8000a82:	2f02      	cmp	r7, #2
 8000a84:	d116      	bne.n	8000ab4 <HAL_GPIO_Init+0x60>
        temp = GPIOx->AFR[position >> 3];
 8000a86:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 8000a8a:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000a8e:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3];
 8000a92:	f8da 5020 	ldr.w	r5, [sl, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000a96:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8000a9a:	f04f 0c0f 	mov.w	ip, #15
 8000a9e:	fa0c fc0b 	lsl.w	ip, ip, fp
 8000aa2:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8000aa6:	690d      	ldr	r5, [r1, #16]
 8000aa8:	fa05 f50b 	lsl.w	r5, r5, fp
 8000aac:	ea45 050c 	orr.w	r5, r5, ip
        GPIOx->AFR[position >> 3] = temp;
 8000ab0:	f8ca 5020 	str.w	r5, [sl, #32]
 8000ab4:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000ab8:	2503      	movs	r5, #3
      temp = GPIOx->MODER;
 8000aba:	f8d0 b000 	ldr.w	fp, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000abe:	fa05 f50a 	lsl.w	r5, r5, sl
 8000ac2:	43ed      	mvns	r5, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000ac4:	f004 0c03 	and.w	ip, r4, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000ac8:	ea0b 0b05 	and.w	fp, fp, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000acc:	fa0c fc0a 	lsl.w	ip, ip, sl
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000ad0:	3f01      	subs	r7, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000ad2:	ea4c 0c0b 	orr.w	ip, ip, fp
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000ad6:	2f01      	cmp	r7, #1
      GPIOx->MODER = temp;
 8000ad8:	f8c0 c000 	str.w	ip, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000adc:	d811      	bhi.n	8000b02 <HAL_GPIO_Init+0xae>
        temp = GPIOx->OSPEEDR; 
 8000ade:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8000ae0:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2));
 8000ae4:	68cf      	ldr	r7, [r1, #12]
 8000ae6:	fa07 fc0a 	lsl.w	ip, r7, sl
 8000aea:	ea4c 070b 	orr.w	r7, ip, fp
        GPIOx->OSPEEDR = temp;
 8000aee:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8000af0:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8000af2:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8000af6:	f3c4 1700 	ubfx	r7, r4, #4, #1
 8000afa:	409f      	lsls	r7, r3
 8000afc:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8000b00:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 8000b02:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8000b04:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8000b06:	688f      	ldr	r7, [r1, #8]
 8000b08:	fa07 f70a 	lsl.w	r7, r7, sl
 8000b0c:	433d      	orrs	r5, r7
      GPIOx->PUPDR = temp;
 8000b0e:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000b10:	00e5      	lsls	r5, r4, #3
 8000b12:	d55f      	bpl.n	8000bd4 <HAL_GPIO_Init+0x180>
        __SYSCFG_CLK_ENABLE();
 8000b14:	f8d8 5044 	ldr.w	r5, [r8, #68]	; 0x44
 8000b18:	f023 0703 	bic.w	r7, r3, #3
 8000b1c:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 8000b20:	f445 4580 	orr.w	r5, r5, #16384	; 0x4000
 8000b24:	f507 379c 	add.w	r7, r7, #79872	; 0x13800
 8000b28:	f8c8 5044 	str.w	r5, [r8, #68]	; 0x44
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000b2c:	f003 0e03 	and.w	lr, r3, #3
 8000b30:	f04f 0c0f 	mov.w	ip, #15
        temp = SYSCFG->EXTICR[position >> 2];
 8000b34:	f8d7 a008 	ldr.w	sl, [r7, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000b38:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 8000b3c:	fa0c f50e 	lsl.w	r5, ip, lr
 8000b40:	ea2a 0c05 	bic.w	ip, sl, r5
        temp |= ((uint32_t)(GET_GPIO_SOURCE(GPIOx)) << (4 * (position & 0x03)));
 8000b44:	4d31      	ldr	r5, [pc, #196]	; (8000c0c <HAL_GPIO_Init+0x1b8>)
 8000b46:	42a8      	cmp	r0, r5
 8000b48:	d04b      	beq.n	8000be2 <HAL_GPIO_Init+0x18e>
 8000b4a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000b4e:	42a8      	cmp	r0, r5
 8000b50:	d049      	beq.n	8000be6 <HAL_GPIO_Init+0x192>
 8000b52:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000b56:	42a8      	cmp	r0, r5
 8000b58:	d047      	beq.n	8000bea <HAL_GPIO_Init+0x196>
 8000b5a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000b5e:	42a8      	cmp	r0, r5
 8000b60:	d045      	beq.n	8000bee <HAL_GPIO_Init+0x19a>
 8000b62:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000b66:	42a8      	cmp	r0, r5
 8000b68:	d043      	beq.n	8000bf2 <HAL_GPIO_Init+0x19e>
 8000b6a:	4548      	cmp	r0, r9
 8000b6c:	d043      	beq.n	8000bf6 <HAL_GPIO_Init+0x1a2>
 8000b6e:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8000b72:	42a8      	cmp	r0, r5
 8000b74:	d041      	beq.n	8000bfa <HAL_GPIO_Init+0x1a6>
 8000b76:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000b7a:	42a8      	cmp	r0, r5
 8000b7c:	d03f      	beq.n	8000bfe <HAL_GPIO_Init+0x1aa>
 8000b7e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000b82:	42a8      	cmp	r0, r5
 8000b84:	d03d      	beq.n	8000c02 <HAL_GPIO_Init+0x1ae>
 8000b86:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000b8a:	42a8      	cmp	r0, r5
 8000b8c:	bf14      	ite	ne
 8000b8e:	250a      	movne	r5, #10
 8000b90:	2509      	moveq	r5, #9
 8000b92:	fa05 f50e 	lsl.w	r5, r5, lr
 8000b96:	ea45 050c 	orr.w	r5, r5, ip
        SYSCFG->EXTICR[position >> 2] = temp;
 8000b9a:	60bd      	str	r5, [r7, #8]
        temp = EXTI->IMR;
 8000b9c:	6815      	ldr	r5, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 8000b9e:	43f7      	mvns	r7, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000ba0:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~((uint32_t)iocurrent);
 8000ba4:	bf0c      	ite	eq
 8000ba6:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 8000ba8:	4335      	orrne	r5, r6
        }
        EXTI->IMR = temp;
 8000baa:	6015      	str	r5, [r2, #0]

        temp = EXTI->EMR;
 8000bac:	6855      	ldr	r5, [r2, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000bae:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~((uint32_t)iocurrent);
 8000bb2:	bf0c      	ite	eq
 8000bb4:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 8000bb6:	4335      	orrne	r5, r6
        }
        EXTI->EMR = temp;
 8000bb8:	6055      	str	r5, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8000bba:	6895      	ldr	r5, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000bbc:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~((uint32_t)iocurrent);
 8000bc0:	bf0c      	ite	eq
 8000bc2:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 8000bc4:	4335      	orrne	r5, r6
        }
        EXTI->RTSR = temp;
 8000bc6:	6095      	str	r5, [r2, #8]

        temp = EXTI->FTSR;
 8000bc8:	68d5      	ldr	r5, [r2, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000bca:	02a4      	lsls	r4, r4, #10
        temp &= ~((uint32_t)iocurrent);
 8000bcc:	bf54      	ite	pl
 8000bce:	403d      	andpl	r5, r7
        {
          temp |= iocurrent;
 8000bd0:	4335      	orrmi	r5, r6
        }
        EXTI->FTSR = temp;
 8000bd2:	60d5      	str	r5, [r2, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
 8000bd4:	3301      	adds	r3, #1
 8000bd6:	2b10      	cmp	r3, #16
 8000bd8:	f47f af46 	bne.w	8000a68 <HAL_GPIO_Init+0x14>
      }
    }
  }
}
 8000bdc:	b003      	add	sp, #12
 8000bde:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp |= ((uint32_t)(GET_GPIO_SOURCE(GPIOx)) << (4 * (position & 0x03)));
 8000be2:	2500      	movs	r5, #0
 8000be4:	e7d5      	b.n	8000b92 <HAL_GPIO_Init+0x13e>
 8000be6:	2501      	movs	r5, #1
 8000be8:	e7d3      	b.n	8000b92 <HAL_GPIO_Init+0x13e>
 8000bea:	2502      	movs	r5, #2
 8000bec:	e7d1      	b.n	8000b92 <HAL_GPIO_Init+0x13e>
 8000bee:	2503      	movs	r5, #3
 8000bf0:	e7cf      	b.n	8000b92 <HAL_GPIO_Init+0x13e>
 8000bf2:	2504      	movs	r5, #4
 8000bf4:	e7cd      	b.n	8000b92 <HAL_GPIO_Init+0x13e>
 8000bf6:	2505      	movs	r5, #5
 8000bf8:	e7cb      	b.n	8000b92 <HAL_GPIO_Init+0x13e>
 8000bfa:	2506      	movs	r5, #6
 8000bfc:	e7c9      	b.n	8000b92 <HAL_GPIO_Init+0x13e>
 8000bfe:	2507      	movs	r5, #7
 8000c00:	e7c7      	b.n	8000b92 <HAL_GPIO_Init+0x13e>
 8000c02:	2508      	movs	r5, #8
 8000c04:	e7c5      	b.n	8000b92 <HAL_GPIO_Init+0x13e>
 8000c06:	bf00      	nop
 8000c08:	40013c00 	.word	0x40013c00
 8000c0c:	40020000 	.word	0x40020000
 8000c10:	40023800 	.word	0x40023800
 8000c14:	40021400 	.word	0x40021400

08000c18 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8000c18:	b10a      	cbz	r2, 8000c1e <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRRL = GPIO_Pin;
 8000c1a:	8301      	strh	r1, [r0, #24]
 8000c1c:	4770      	bx	lr
  }
  else
  {
    GPIOx->BSRRH = GPIO_Pin ;
 8000c1e:	8341      	strh	r1, [r0, #26]
 8000c20:	4770      	bx	lr

08000c22 <I2C_WaitOnMasterAddressFlagUntilTimeout>:
  * @param  Flag: specifies the I2C flag to check.
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout)
{
 8000c22:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000c26:	460d      	mov	r5, r1
 8000c28:	4604      	mov	r4, r0
 8000c2a:	4616      	mov	r6, r2
  uint32_t tickstart = 0;

  /* Get tick */
  tickstart = HAL_GetTick();
 8000c2c:	f7ff fb3a 	bl	80002a4 <HAL_GetTick>

  while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 8000c30:	f3c5 4807 	ubfx	r8, r5, #16, #8
  tickstart = HAL_GetTick();
 8000c34:	4607      	mov	r7, r0
 8000c36:	b2ad      	uxth	r5, r5
 8000c38:	6823      	ldr	r3, [r4, #0]
  while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 8000c3a:	f1b8 0f01 	cmp.w	r8, #1
 8000c3e:	bf0c      	ite	eq
 8000c40:	695a      	ldreq	r2, [r3, #20]
 8000c42:	699a      	ldrne	r2, [r3, #24]
 8000c44:	ea35 0202 	bics.w	r2, r5, r2
 8000c48:	bf14      	ite	ne
 8000c4a:	2001      	movne	r0, #1
 8000c4c:	2000      	moveq	r0, #0
 8000c4e:	b908      	cbnz	r0, 8000c54 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x32>
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
}
 8000c50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8000c54:	695a      	ldr	r2, [r3, #20]
 8000c56:	0552      	lsls	r2, r2, #21
 8000c58:	d511      	bpl.n	8000c7e <I2C_WaitOnMasterAddressFlagUntilTimeout+0x5c>
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8000c5a:	681a      	ldr	r2, [r3, #0]
 8000c5c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000c60:	601a      	str	r2, [r3, #0]
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8000c62:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8000c66:	615a      	str	r2, [r3, #20]
      hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8000c68:	2304      	movs	r3, #4
 8000c6a:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
      hi2c->State= HAL_I2C_STATE_READY;
 8000c6e:	2001      	movs	r0, #1
      __HAL_UNLOCK(hi2c);
 8000c70:	2300      	movs	r3, #0
      hi2c->State= HAL_I2C_STATE_READY;
 8000c72:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
      __HAL_UNLOCK(hi2c);
 8000c76:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      return HAL_ERROR;
 8000c7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(Timeout != HAL_MAX_DELAY)
 8000c7e:	1c73      	adds	r3, r6, #1
 8000c80:	d0da      	beq.n	8000c38 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x16>
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8000c82:	b946      	cbnz	r6, 8000c96 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x74>
        hi2c->State= HAL_I2C_STATE_READY;
 8000c84:	2301      	movs	r3, #1
 8000c86:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        __HAL_UNLOCK(hi2c);
 8000c8a:	2300      	movs	r3, #0
 8000c8c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        return HAL_TIMEOUT;
 8000c90:	2003      	movs	r0, #3
 8000c92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8000c96:	f7ff fb05 	bl	80002a4 <HAL_GetTick>
 8000c9a:	1bc0      	subs	r0, r0, r7
 8000c9c:	4286      	cmp	r6, r0
 8000c9e:	d2cb      	bcs.n	8000c38 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x16>
 8000ca0:	e7f0      	b.n	8000c84 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x62>

08000ca2 <I2C_WaitOnFlagUntilTimeout>:
{
 8000ca2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000ca6:	460c      	mov	r4, r1
 8000ca8:	4606      	mov	r6, r0
 8000caa:	4615      	mov	r5, r2
 8000cac:	461f      	mov	r7, r3
  tickstart = HAL_GetTick();
 8000cae:	f7ff faf9 	bl	80002a4 <HAL_GetTick>
 8000cb2:	4680      	mov	r8, r0
 8000cb4:	0c20      	lsrs	r0, r4, #16
 8000cb6:	b2a4      	uxth	r4, r4
  if(Status == RESET)
 8000cb8:	b315      	cbz	r5, 8000d00 <I2C_WaitOnFlagUntilTimeout+0x5e>
    while(__HAL_I2C_GET_FLAG(hi2c, Flag) != RESET)
 8000cba:	b2c5      	uxtb	r5, r0
 8000cbc:	e02c      	b.n	8000d18 <I2C_WaitOnFlagUntilTimeout+0x76>
      if(Timeout != HAL_MAX_DELAY)
 8000cbe:	1c7a      	adds	r2, r7, #1
 8000cc0:	d00f      	beq.n	8000ce2 <I2C_WaitOnFlagUntilTimeout+0x40>
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8000cc2:	b947      	cbnz	r7, 8000cd6 <I2C_WaitOnFlagUntilTimeout+0x34>
          hi2c->State= HAL_I2C_STATE_READY;
 8000cc4:	2301      	movs	r3, #1
 8000cc6:	f886 3035 	strb.w	r3, [r6, #53]	; 0x35
          __HAL_UNLOCK(hi2c);
 8000cca:	2300      	movs	r3, #0
 8000ccc:	f886 3034 	strb.w	r3, [r6, #52]	; 0x34
          return HAL_TIMEOUT;
 8000cd0:	2003      	movs	r0, #3
 8000cd2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8000cd6:	f7ff fae5 	bl	80002a4 <HAL_GetTick>
 8000cda:	eba0 0008 	sub.w	r0, r0, r8
 8000cde:	4287      	cmp	r7, r0
 8000ce0:	d3f0      	bcc.n	8000cc4 <I2C_WaitOnFlagUntilTimeout+0x22>
 8000ce2:	6833      	ldr	r3, [r6, #0]
    while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 8000ce4:	2d01      	cmp	r5, #1
 8000ce6:	bf0c      	ite	eq
 8000ce8:	695b      	ldreq	r3, [r3, #20]
 8000cea:	699b      	ldrne	r3, [r3, #24]
 8000cec:	ea34 0303 	bics.w	r3, r4, r3
 8000cf0:	bf14      	ite	ne
 8000cf2:	2301      	movne	r3, #1
 8000cf4:	2300      	moveq	r3, #0
 8000cf6:	2b00      	cmp	r3, #0
 8000cf8:	d1e1      	bne.n	8000cbe <I2C_WaitOnFlagUntilTimeout+0x1c>
  return HAL_OK;
 8000cfa:	2000      	movs	r0, #0
 8000cfc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 8000d00:	b2c5      	uxtb	r5, r0
 8000d02:	e7ee      	b.n	8000ce2 <I2C_WaitOnFlagUntilTimeout+0x40>
      if(Timeout != HAL_MAX_DELAY)
 8000d04:	1c7b      	adds	r3, r7, #1
 8000d06:	d007      	beq.n	8000d18 <I2C_WaitOnFlagUntilTimeout+0x76>
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8000d08:	2f00      	cmp	r7, #0
 8000d0a:	d0db      	beq.n	8000cc4 <I2C_WaitOnFlagUntilTimeout+0x22>
 8000d0c:	f7ff faca 	bl	80002a4 <HAL_GetTick>
 8000d10:	eba0 0008 	sub.w	r0, r0, r8
 8000d14:	4287      	cmp	r7, r0
 8000d16:	d3d5      	bcc.n	8000cc4 <I2C_WaitOnFlagUntilTimeout+0x22>
 8000d18:	6833      	ldr	r3, [r6, #0]
    while(__HAL_I2C_GET_FLAG(hi2c, Flag) != RESET)
 8000d1a:	2d01      	cmp	r5, #1
 8000d1c:	bf0c      	ite	eq
 8000d1e:	695b      	ldreq	r3, [r3, #20]
 8000d20:	699b      	ldrne	r3, [r3, #24]
 8000d22:	ea34 0303 	bics.w	r3, r4, r3
 8000d26:	bf0c      	ite	eq
 8000d28:	2301      	moveq	r3, #1
 8000d2a:	2300      	movne	r3, #0
 8000d2c:	2b00      	cmp	r3, #0
 8000d2e:	d1e9      	bne.n	8000d04 <I2C_WaitOnFlagUntilTimeout+0x62>
 8000d30:	e7e3      	b.n	8000cfa <I2C_WaitOnFlagUntilTimeout+0x58>
	...

08000d34 <I2C_RequestMemoryWrite>:
{
 8000d34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000d36:	4615      	mov	r5, r2
  hi2c->Instance->CR1 |= I2C_CR1_START;
 8000d38:	6802      	ldr	r2, [r0, #0]
{
 8000d3a:	461f      	mov	r7, r3
  hi2c->Instance->CR1 |= I2C_CR1_START;
 8000d3c:	6813      	ldr	r3, [r2, #0]
 8000d3e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000d42:	6013      	str	r3, [r2, #0]
{
 8000d44:	460e      	mov	r6, r1
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
 8000d46:	9b06      	ldr	r3, [sp, #24]
 8000d48:	2200      	movs	r2, #0
 8000d4a:	f04f 1101 	mov.w	r1, #65537	; 0x10001
{
 8000d4e:	4604      	mov	r4, r0
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
 8000d50:	f7ff ffa7 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 8000d54:	b970      	cbnz	r0, 8000d74 <I2C_RequestMemoryWrite+0x40>
  hi2c->Instance->DR = __HAL_I2C_7BIT_ADD_WRITE(DevAddress);
 8000d56:	6823      	ldr	r3, [r4, #0]
  if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
 8000d58:	9a06      	ldr	r2, [sp, #24]
 8000d5a:	4916      	ldr	r1, [pc, #88]	; (8000db4 <I2C_RequestMemoryWrite+0x80>)
  hi2c->Instance->DR = __HAL_I2C_7BIT_ADD_WRITE(DevAddress);
 8000d5c:	f006 06fe 	and.w	r6, r6, #254	; 0xfe
 8000d60:	611e      	str	r6, [r3, #16]
  if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
 8000d62:	4620      	mov	r0, r4
 8000d64:	f7ff ff5d 	bl	8000c22 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 8000d68:	4602      	mov	r2, r0
 8000d6a:	b128      	cbz	r0, 8000d78 <I2C_RequestMemoryWrite+0x44>
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8000d6c:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
 8000d70:	2b04      	cmp	r3, #4
 8000d72:	d01d      	beq.n	8000db0 <I2C_RequestMemoryWrite+0x7c>
      return HAL_TIMEOUT;
 8000d74:	2003      	movs	r0, #3
 8000d76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8000d78:	6823      	ldr	r3, [r4, #0]
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8000d7a:	4620      	mov	r0, r4
  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8000d7c:	6959      	ldr	r1, [r3, #20]
 8000d7e:	699b      	ldr	r3, [r3, #24]
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8000d80:	490d      	ldr	r1, [pc, #52]	; (8000db8 <I2C_RequestMemoryWrite+0x84>)
 8000d82:	9b06      	ldr	r3, [sp, #24]
 8000d84:	f7ff ff8d 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 8000d88:	2800      	cmp	r0, #0
 8000d8a:	d1f3      	bne.n	8000d74 <I2C_RequestMemoryWrite+0x40>
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8000d8c:	2f01      	cmp	r7, #1
 8000d8e:	6823      	ldr	r3, [r4, #0]
 8000d90:	d102      	bne.n	8000d98 <I2C_RequestMemoryWrite+0x64>
    hi2c->Instance->DR = __HAL_I2C_MEM_ADD_LSB(MemAddress);
 8000d92:	b2ed      	uxtb	r5, r5
 8000d94:	611d      	str	r5, [r3, #16]
 8000d96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hi2c->Instance->DR = __HAL_I2C_MEM_ADD_MSB(MemAddress);
 8000d98:	0a2a      	lsrs	r2, r5, #8
 8000d9a:	611a      	str	r2, [r3, #16]
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8000d9c:	4906      	ldr	r1, [pc, #24]	; (8000db8 <I2C_RequestMemoryWrite+0x84>)
 8000d9e:	9b06      	ldr	r3, [sp, #24]
 8000da0:	4602      	mov	r2, r0
 8000da2:	4620      	mov	r0, r4
 8000da4:	f7ff ff7d 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 8000da8:	2800      	cmp	r0, #0
 8000daa:	d1e3      	bne.n	8000d74 <I2C_RequestMemoryWrite+0x40>
    hi2c->Instance->DR = __HAL_I2C_MEM_ADD_LSB(MemAddress);
 8000dac:	6823      	ldr	r3, [r4, #0]
 8000dae:	e7f0      	b.n	8000d92 <I2C_RequestMemoryWrite+0x5e>
      return HAL_ERROR;
 8000db0:	2001      	movs	r0, #1
}
 8000db2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000db4:	00010002 	.word	0x00010002
 8000db8:	00010080 	.word	0x00010080

08000dbc <I2C_RequestMemoryRead>:
{
 8000dbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000dbe:	461f      	mov	r7, r3
  hi2c->Instance->CR1 |= I2C_CR1_ACK;
 8000dc0:	6803      	ldr	r3, [r0, #0]
{
 8000dc2:	4615      	mov	r5, r2
  hi2c->Instance->CR1 |= I2C_CR1_ACK;
 8000dc4:	681a      	ldr	r2, [r3, #0]
 8000dc6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000dca:	601a      	str	r2, [r3, #0]
  hi2c->Instance->CR1 |= I2C_CR1_START;
 8000dcc:	681a      	ldr	r2, [r3, #0]
 8000dce:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000dd2:	601a      	str	r2, [r3, #0]
{
 8000dd4:	460e      	mov	r6, r1
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
 8000dd6:	9b06      	ldr	r3, [sp, #24]
 8000dd8:	2200      	movs	r2, #0
 8000dda:	f04f 1101 	mov.w	r1, #65537	; 0x10001
{
 8000dde:	4604      	mov	r4, r0
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
 8000de0:	f7ff ff5f 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 8000de4:	b988      	cbnz	r0, 8000e0a <I2C_RequestMemoryRead+0x4e>
  hi2c->Instance->DR = __HAL_I2C_7BIT_ADD_WRITE(DevAddress);
 8000de6:	6823      	ldr	r3, [r4, #0]
  if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
 8000de8:	4927      	ldr	r1, [pc, #156]	; (8000e88 <I2C_RequestMemoryRead+0xcc>)
  hi2c->Instance->DR = __HAL_I2C_7BIT_ADD_WRITE(DevAddress);
 8000dea:	b2f6      	uxtb	r6, r6
 8000dec:	f006 02fe 	and.w	r2, r6, #254	; 0xfe
 8000df0:	611a      	str	r2, [r3, #16]
  if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
 8000df2:	4620      	mov	r0, r4
 8000df4:	9a06      	ldr	r2, [sp, #24]
 8000df6:	f7ff ff14 	bl	8000c22 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 8000dfa:	4602      	mov	r2, r0
 8000dfc:	b138      	cbz	r0, 8000e0e <I2C_RequestMemoryRead+0x52>
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8000dfe:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
 8000e02:	2b04      	cmp	r3, #4
 8000e04:	d101      	bne.n	8000e0a <I2C_RequestMemoryRead+0x4e>
      return HAL_ERROR;
 8000e06:	2001      	movs	r0, #1
 8000e08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      return HAL_TIMEOUT;
 8000e0a:	2003      	movs	r0, #3
 8000e0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8000e0e:	6823      	ldr	r3, [r4, #0]
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8000e10:	4620      	mov	r0, r4
  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8000e12:	6959      	ldr	r1, [r3, #20]
 8000e14:	699b      	ldr	r3, [r3, #24]
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8000e16:	491d      	ldr	r1, [pc, #116]	; (8000e8c <I2C_RequestMemoryRead+0xd0>)
 8000e18:	9b06      	ldr	r3, [sp, #24]
 8000e1a:	f7ff ff42 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 8000e1e:	4602      	mov	r2, r0
 8000e20:	2800      	cmp	r0, #0
 8000e22:	d1f2      	bne.n	8000e0a <I2C_RequestMemoryRead+0x4e>
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8000e24:	2f01      	cmp	r7, #1
 8000e26:	6823      	ldr	r3, [r4, #0]
 8000e28:	d123      	bne.n	8000e72 <I2C_RequestMemoryRead+0xb6>
    hi2c->Instance->DR = __HAL_I2C_MEM_ADD_LSB(MemAddress);
 8000e2a:	b2ed      	uxtb	r5, r5
 8000e2c:	611d      	str	r5, [r3, #16]
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8000e2e:	2200      	movs	r2, #0
 8000e30:	9b06      	ldr	r3, [sp, #24]
 8000e32:	4916      	ldr	r1, [pc, #88]	; (8000e8c <I2C_RequestMemoryRead+0xd0>)
 8000e34:	4620      	mov	r0, r4
 8000e36:	f7ff ff34 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 8000e3a:	4602      	mov	r2, r0
 8000e3c:	2800      	cmp	r0, #0
 8000e3e:	d1e4      	bne.n	8000e0a <I2C_RequestMemoryRead+0x4e>
  hi2c->Instance->CR1 |= I2C_CR1_START;
 8000e40:	6821      	ldr	r1, [r4, #0]
 8000e42:	680b      	ldr	r3, [r1, #0]
 8000e44:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000e48:	600b      	str	r3, [r1, #0]
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
 8000e4a:	4620      	mov	r0, r4
 8000e4c:	9b06      	ldr	r3, [sp, #24]
 8000e4e:	f04f 1101 	mov.w	r1, #65537	; 0x10001
 8000e52:	f7ff ff26 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 8000e56:	2800      	cmp	r0, #0
 8000e58:	d1d7      	bne.n	8000e0a <I2C_RequestMemoryRead+0x4e>
  hi2c->Instance->DR = __HAL_I2C_7BIT_ADD_READ(DevAddress);
 8000e5a:	6823      	ldr	r3, [r4, #0]
  if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
 8000e5c:	9a06      	ldr	r2, [sp, #24]
 8000e5e:	490a      	ldr	r1, [pc, #40]	; (8000e88 <I2C_RequestMemoryRead+0xcc>)
  hi2c->Instance->DR = __HAL_I2C_7BIT_ADD_READ(DevAddress);
 8000e60:	f046 0601 	orr.w	r6, r6, #1
 8000e64:	611e      	str	r6, [r3, #16]
  if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
 8000e66:	4620      	mov	r0, r4
 8000e68:	f7ff fedb 	bl	8000c22 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 8000e6c:	2800      	cmp	r0, #0
 8000e6e:	d1c6      	bne.n	8000dfe <I2C_RequestMemoryRead+0x42>
}
 8000e70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hi2c->Instance->DR = __HAL_I2C_MEM_ADD_MSB(MemAddress);
 8000e72:	0a29      	lsrs	r1, r5, #8
 8000e74:	6119      	str	r1, [r3, #16]
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8000e76:	4620      	mov	r0, r4
 8000e78:	9b06      	ldr	r3, [sp, #24]
 8000e7a:	4904      	ldr	r1, [pc, #16]	; (8000e8c <I2C_RequestMemoryRead+0xd0>)
 8000e7c:	f7ff ff11 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 8000e80:	2800      	cmp	r0, #0
 8000e82:	d1c2      	bne.n	8000e0a <I2C_RequestMemoryRead+0x4e>
    hi2c->Instance->DR = __HAL_I2C_MEM_ADD_LSB(MemAddress);
 8000e84:	6823      	ldr	r3, [r4, #0]
 8000e86:	e7d0      	b.n	8000e2a <I2C_RequestMemoryRead+0x6e>
 8000e88:	00010002 	.word	0x00010002
 8000e8c:	00010080 	.word	0x00010080

08000e90 <HAL_I2C_MspInit>:
 8000e90:	4770      	bx	lr
	...

08000e94 <HAL_I2C_Init>:
{
 8000e94:	b570      	push	{r4, r5, r6, lr}
  if(hi2c == NULL)
 8000e96:	4604      	mov	r4, r0
 8000e98:	2800      	cmp	r0, #0
 8000e9a:	d05c      	beq.n	8000f56 <HAL_I2C_Init+0xc2>
  if(hi2c->State == HAL_I2C_STATE_RESET)
 8000e9c:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8000ea0:	b90b      	cbnz	r3, 8000ea6 <HAL_I2C_Init+0x12>
    HAL_I2C_MspInit(hi2c);
 8000ea2:	f7ff fff5 	bl	8000e90 <HAL_I2C_MspInit>
  __HAL_I2C_DISABLE(hi2c);
 8000ea6:	6822      	ldr	r2, [r4, #0]
  hi2c->Instance->TRISE = __HAL_I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8000ea8:	4e2c      	ldr	r6, [pc, #176]	; (8000f5c <HAL_I2C_Init+0xc8>)
  freqrange = __HAL_I2C_FREQRANGE(pclk1);
 8000eaa:	4d2d      	ldr	r5, [pc, #180]	; (8000f60 <HAL_I2C_Init+0xcc>)
  hi2c->State = HAL_I2C_STATE_BUSY;
 8000eac:	2302      	movs	r3, #2
 8000eae:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_I2C_DISABLE(hi2c);
 8000eb2:	6813      	ldr	r3, [r2, #0]
 8000eb4:	f023 0301 	bic.w	r3, r3, #1
 8000eb8:	6013      	str	r3, [r2, #0]
  pclk1 = HAL_RCC_GetPCLK1Freq();
 8000eba:	f001 f9f9 	bl	80022b0 <HAL_RCC_GetPCLK1Freq>
  hi2c->Instance->TRISE = __HAL_I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8000ebe:	6863      	ldr	r3, [r4, #4]
  hi2c->Instance->CR2 = freqrange;
 8000ec0:	6822      	ldr	r2, [r4, #0]
  freqrange = __HAL_I2C_FREQRANGE(pclk1);
 8000ec2:	fbb0 f5f5 	udiv	r5, r0, r5
  hi2c->Instance->TRISE = __HAL_I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8000ec6:	42b3      	cmp	r3, r6
 8000ec8:	bf84      	itt	hi
 8000eca:	f44f 7196 	movhi.w	r1, #300	; 0x12c
 8000ece:	4369      	mulhi	r1, r5
  hi2c->Instance->CR2 = freqrange;
 8000ed0:	6055      	str	r5, [r2, #4]
  hi2c->Instance->TRISE = __HAL_I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8000ed2:	bf91      	iteee	ls
 8000ed4:	1c69      	addls	r1, r5, #1
 8000ed6:	f44f 757a 	movhi.w	r5, #1000	; 0x3e8
 8000eda:	fbb1 f1f5 	udivhi	r1, r1, r5
 8000ede:	3101      	addhi	r1, #1
  hi2c->Instance->CCR = __HAL_I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 8000ee0:	42b3      	cmp	r3, r6
  hi2c->Instance->TRISE = __HAL_I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8000ee2:	6211      	str	r1, [r2, #32]
  hi2c->Instance->CCR = __HAL_I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 8000ee4:	d81f      	bhi.n	8000f26 <HAL_I2C_Init+0x92>
 8000ee6:	005b      	lsls	r3, r3, #1
 8000ee8:	fbb0 f0f3 	udiv	r0, r0, r3
 8000eec:	f3c0 030b 	ubfx	r3, r0, #0, #12
 8000ef0:	2b03      	cmp	r3, #3
 8000ef2:	bf98      	it	ls
 8000ef4:	2004      	movls	r0, #4
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8000ef6:	6a21      	ldr	r1, [r4, #32]
 8000ef8:	69e3      	ldr	r3, [r4, #28]
  hi2c->Instance->CCR = __HAL_I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 8000efa:	61d0      	str	r0, [r2, #28]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8000efc:	430b      	orrs	r3, r1
 8000efe:	6013      	str	r3, [r2, #0]
  hi2c->Instance->OAR1 = (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1);
 8000f00:	68e1      	ldr	r1, [r4, #12]
 8000f02:	6923      	ldr	r3, [r4, #16]
 8000f04:	430b      	orrs	r3, r1
 8000f06:	6093      	str	r3, [r2, #8]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);
 8000f08:	69a1      	ldr	r1, [r4, #24]
 8000f0a:	6963      	ldr	r3, [r4, #20]
 8000f0c:	430b      	orrs	r3, r1
 8000f0e:	60d3      	str	r3, [r2, #12]
  __HAL_I2C_ENABLE(hi2c);
 8000f10:	6813      	ldr	r3, [r2, #0]
 8000f12:	f043 0301 	orr.w	r3, r3, #1
 8000f16:	6013      	str	r3, [r2, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8000f18:	2000      	movs	r0, #0
  hi2c->State = HAL_I2C_STATE_READY;
 8000f1a:	2301      	movs	r3, #1
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8000f1c:	f884 0036 	strb.w	r0, [r4, #54]	; 0x36
  hi2c->State = HAL_I2C_STATE_READY;
 8000f20:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  return HAL_OK;
 8000f24:	bd70      	pop	{r4, r5, r6, pc}
  hi2c->Instance->CCR = __HAL_I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 8000f26:	68a1      	ldr	r1, [r4, #8]
 8000f28:	b949      	cbnz	r1, 8000f3e <HAL_I2C_Init+0xaa>
 8000f2a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8000f2e:	fbb0 f0f3 	udiv	r0, r0, r3
 8000f32:	f3c0 030b 	ubfx	r3, r0, #0, #12
 8000f36:	b163      	cbz	r3, 8000f52 <HAL_I2C_Init+0xbe>
 8000f38:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
 8000f3c:	e7db      	b.n	8000ef6 <HAL_I2C_Init+0x62>
 8000f3e:	2119      	movs	r1, #25
 8000f40:	434b      	muls	r3, r1
 8000f42:	fbb0 f0f3 	udiv	r0, r0, r3
 8000f46:	f3c0 030b 	ubfx	r3, r0, #0, #12
 8000f4a:	b113      	cbz	r3, 8000f52 <HAL_I2C_Init+0xbe>
 8000f4c:	f440 4040 	orr.w	r0, r0, #49152	; 0xc000
 8000f50:	e7d1      	b.n	8000ef6 <HAL_I2C_Init+0x62>
 8000f52:	2001      	movs	r0, #1
 8000f54:	e7cf      	b.n	8000ef6 <HAL_I2C_Init+0x62>
    return HAL_ERROR;
 8000f56:	2001      	movs	r0, #1
}
 8000f58:	bd70      	pop	{r4, r5, r6, pc}
 8000f5a:	bf00      	nop
 8000f5c:	000186a0 	.word	0x000186a0
 8000f60:	000f4240 	.word	0x000f4240

08000f64 <HAL_I2C_MspDeInit>:
 8000f64:	4770      	bx	lr

08000f66 <HAL_I2C_DeInit>:
{
 8000f66:	b510      	push	{r4, lr}
  if(hi2c == NULL)
 8000f68:	4604      	mov	r4, r0
 8000f6a:	b188      	cbz	r0, 8000f90 <HAL_I2C_DeInit+0x2a>
  __HAL_I2C_DISABLE(hi2c);
 8000f6c:	6802      	ldr	r2, [r0, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 8000f6e:	2302      	movs	r3, #2
 8000f70:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
  __HAL_I2C_DISABLE(hi2c);
 8000f74:	6813      	ldr	r3, [r2, #0]
 8000f76:	f023 0301 	bic.w	r3, r3, #1
 8000f7a:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
 8000f7c:	f7ff fff2 	bl	8000f64 <HAL_I2C_MspDeInit>
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8000f80:	2000      	movs	r0, #0
 8000f82:	f884 0036 	strb.w	r0, [r4, #54]	; 0x36
  __HAL_UNLOCK(hi2c);
 8000f86:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
  hi2c->State = HAL_I2C_STATE_RESET;
 8000f8a:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
  return HAL_OK;
 8000f8e:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8000f90:	2001      	movs	r0, #1
}
 8000f92:	bd10      	pop	{r4, pc}

08000f94 <HAL_I2C_Mem_Write>:
{
 8000f94:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  if(hi2c->State == HAL_I2C_STATE_READY)
 8000f98:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
{
 8000f9c:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
 8000fa0:	f8bd 602c 	ldrh.w	r6, [sp, #44]	; 0x2c
 8000fa4:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
  if(hi2c->State == HAL_I2C_STATE_READY)
 8000fa8:	b2e4      	uxtb	r4, r4
 8000faa:	2c01      	cmp	r4, #1
{
 8000fac:	4605      	mov	r5, r0
  if(hi2c->State == HAL_I2C_STATE_READY)
 8000fae:	d161      	bne.n	8001074 <HAL_I2C_Mem_Write+0xe0>
    if((pData == NULL) || (Size == 0))
 8000fb0:	f1b8 0f00 	cmp.w	r8, #0
 8000fb4:	d01d      	beq.n	8000ff2 <HAL_I2C_Mem_Write+0x5e>
 8000fb6:	b1e6      	cbz	r6, 8000ff2 <HAL_I2C_Mem_Write+0x5e>
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 8000fb8:	6807      	ldr	r7, [r0, #0]
 8000fba:	69bf      	ldr	r7, [r7, #24]
 8000fbc:	f017 0702 	ands.w	r7, r7, #2
 8000fc0:	d158      	bne.n	8001074 <HAL_I2C_Mem_Write+0xe0>
    __HAL_LOCK(hi2c);
 8000fc2:	f890 e034 	ldrb.w	lr, [r0, #52]	; 0x34
 8000fc6:	f1be 0f01 	cmp.w	lr, #1
 8000fca:	d053      	beq.n	8001074 <HAL_I2C_Mem_Write+0xe0>
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
 8000fcc:	f04f 0e32 	mov.w	lr, #50	; 0x32
 8000fd0:	f880 e035 	strb.w	lr, [r0, #53]	; 0x35
    __HAL_LOCK(hi2c);
 8000fd4:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8000fd8:	f880 7036 	strb.w	r7, [r0, #54]	; 0x36
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
 8000fdc:	f8cd 9000 	str.w	r9, [sp]
 8000fe0:	f7ff fea8 	bl	8000d34 <I2C_RequestMemoryWrite>
 8000fe4:	b138      	cbz	r0, 8000ff6 <HAL_I2C_Mem_Write+0x62>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8000fe6:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
        __HAL_UNLOCK(hi2c);
 8000fea:	f885 7034 	strb.w	r7, [r5, #52]	; 0x34
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8000fee:	2b04      	cmp	r3, #4
 8000ff0:	d109      	bne.n	8001006 <HAL_I2C_Mem_Write+0x72>
      return  HAL_ERROR;
 8000ff2:	4620      	mov	r0, r4
 8000ff4:	e008      	b.n	8001008 <HAL_I2C_Mem_Write+0x74>
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8000ff6:	4c20      	ldr	r4, [pc, #128]	; (8001078 <HAL_I2C_Mem_Write+0xe4>)
 8000ff8:	464b      	mov	r3, r9
 8000ffa:	2200      	movs	r2, #0
 8000ffc:	4621      	mov	r1, r4
 8000ffe:	4628      	mov	r0, r5
 8001000:	f7ff fe4f 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 8001004:	b118      	cbz	r0, 800100e <HAL_I2C_Mem_Write+0x7a>
        return HAL_TIMEOUT;
 8001006:	2003      	movs	r0, #3
}
 8001008:	b003      	add	sp, #12
 800100a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      hi2c->Instance->DR = (*pData++);
 800100e:	682a      	ldr	r2, [r5, #0]
 8001010:	f898 3000 	ldrb.w	r3, [r8]
 8001014:	6113      	str	r3, [r2, #16]
      if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
 8001016:	6951      	ldr	r1, [r2, #20]
      Size--;
 8001018:	1e73      	subs	r3, r6, #1
      if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
 800101a:	0749      	lsls	r1, r1, #29
      Size--;
 800101c:	b29b      	uxth	r3, r3
      if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
 800101e:	d405      	bmi.n	800102c <HAL_I2C_Mem_Write+0x98>
      hi2c->Instance->DR = (*pData++);
 8001020:	f108 0801 	add.w	r8, r8, #1
      Size--;
 8001024:	461e      	mov	r6, r3
    while(Size > 0)
 8001026:	2e00      	cmp	r6, #0
 8001028:	d1e6      	bne.n	8000ff8 <HAL_I2C_Mem_Write+0x64>
 800102a:	e000      	b.n	800102e <HAL_I2C_Mem_Write+0x9a>
      if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
 800102c:	b9d3      	cbnz	r3, 8001064 <HAL_I2C_Mem_Write+0xd0>
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TXE, RESET, Timeout) != HAL_OK)
 800102e:	464b      	mov	r3, r9
 8001030:	2200      	movs	r2, #0
 8001032:	4911      	ldr	r1, [pc, #68]	; (8001078 <HAL_I2C_Mem_Write+0xe4>)
 8001034:	4628      	mov	r0, r5
 8001036:	f7ff fe34 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 800103a:	2800      	cmp	r0, #0
 800103c:	d1e3      	bne.n	8001006 <HAL_I2C_Mem_Write+0x72>
    hi2c->Instance->CR1 |= I2C_CR1_STOP;
 800103e:	682a      	ldr	r2, [r5, #0]
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout) != HAL_OK)
 8001040:	490e      	ldr	r1, [pc, #56]	; (800107c <HAL_I2C_Mem_Write+0xe8>)
    hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8001042:	6813      	ldr	r3, [r2, #0]
 8001044:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8001048:	6013      	str	r3, [r2, #0]
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout) != HAL_OK)
 800104a:	4628      	mov	r0, r5
 800104c:	464b      	mov	r3, r9
 800104e:	2201      	movs	r2, #1
 8001050:	f7ff fe27 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 8001054:	2800      	cmp	r0, #0
 8001056:	d1d6      	bne.n	8001006 <HAL_I2C_Mem_Write+0x72>
    hi2c->State = HAL_I2C_STATE_READY;
 8001058:	2301      	movs	r3, #1
 800105a:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
    __HAL_UNLOCK(hi2c);
 800105e:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
    return HAL_OK;
 8001062:	e7d1      	b.n	8001008 <HAL_I2C_Mem_Write+0x74>
        hi2c->Instance->DR = (*pData++);
 8001064:	f898 3001 	ldrb.w	r3, [r8, #1]
 8001068:	6113      	str	r3, [r2, #16]
        Size--;
 800106a:	3e02      	subs	r6, #2
 800106c:	b2b6      	uxth	r6, r6
        hi2c->Instance->DR = (*pData++);
 800106e:	f108 0802 	add.w	r8, r8, #2
 8001072:	e7d8      	b.n	8001026 <HAL_I2C_Mem_Write+0x92>
    return HAL_BUSY;
 8001074:	2002      	movs	r0, #2
 8001076:	e7c7      	b.n	8001008 <HAL_I2C_Mem_Write+0x74>
 8001078:	00010080 	.word	0x00010080
 800107c:	00100002 	.word	0x00100002

08001080 <HAL_I2C_Mem_Read>:
{
 8001080:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  if(hi2c->State == HAL_I2C_STATE_READY)
 8001084:	f890 5035 	ldrb.w	r5, [r0, #53]	; 0x35
{
 8001088:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
 800108c:	f8bd 602c 	ldrh.w	r6, [sp, #44]	; 0x2c
 8001090:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
  if(hi2c->State == HAL_I2C_STATE_READY)
 8001094:	b2ed      	uxtb	r5, r5
 8001096:	2d01      	cmp	r5, #1
{
 8001098:	4604      	mov	r4, r0
  if(hi2c->State == HAL_I2C_STATE_READY)
 800109a:	f040 80c0 	bne.w	800121e <HAL_I2C_Mem_Read+0x19e>
    if((pData == NULL) || (Size == 0))
 800109e:	f1b8 0f00 	cmp.w	r8, #0
 80010a2:	d020      	beq.n	80010e6 <HAL_I2C_Mem_Read+0x66>
 80010a4:	b1fe      	cbz	r6, 80010e6 <HAL_I2C_Mem_Read+0x66>
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 80010a6:	6807      	ldr	r7, [r0, #0]
 80010a8:	69bf      	ldr	r7, [r7, #24]
 80010aa:	f017 0702 	ands.w	r7, r7, #2
 80010ae:	f040 80b6 	bne.w	800121e <HAL_I2C_Mem_Read+0x19e>
    __HAL_LOCK(hi2c);
 80010b2:	f890 e034 	ldrb.w	lr, [r0, #52]	; 0x34
 80010b6:	f1be 0f01 	cmp.w	lr, #1
 80010ba:	f000 80b0 	beq.w	800121e <HAL_I2C_Mem_Read+0x19e>
    hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
 80010be:	f04f 0e42 	mov.w	lr, #66	; 0x42
 80010c2:	f880 e035 	strb.w	lr, [r0, #53]	; 0x35
    __HAL_LOCK(hi2c);
 80010c6:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80010ca:	f880 7036 	strb.w	r7, [r0, #54]	; 0x36
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
 80010ce:	f8cd 9000 	str.w	r9, [sp]
 80010d2:	f7ff fe73 	bl	8000dbc <I2C_RequestMemoryRead>
 80010d6:	4602      	mov	r2, r0
 80010d8:	b138      	cbz	r0, 80010ea <HAL_I2C_Mem_Read+0x6a>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80010da:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
        __HAL_UNLOCK(hi2c);
 80010de:	f884 7034 	strb.w	r7, [r4, #52]	; 0x34
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80010e2:	2b04      	cmp	r3, #4
 80010e4:	d115      	bne.n	8001112 <HAL_I2C_Mem_Read+0x92>
      return  HAL_ERROR;
 80010e6:	4628      	mov	r0, r5
 80010e8:	e014      	b.n	8001114 <HAL_I2C_Mem_Read+0x94>
    if(Size == 1)
 80010ea:	2e01      	cmp	r6, #1
 80010ec:	6823      	ldr	r3, [r4, #0]
 80010ee:	d114      	bne.n	800111a <HAL_I2C_Mem_Read+0x9a>
      hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 80010f0:	6819      	ldr	r1, [r3, #0]
 80010f2:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80010f6:	6019      	str	r1, [r3, #0]
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80010f8:	6959      	ldr	r1, [r3, #20]
 80010fa:	6999      	ldr	r1, [r3, #24]
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 80010fc:	6819      	ldr	r1, [r3, #0]
 80010fe:	f441 7100 	orr.w	r1, r1, #512	; 0x200
 8001102:	6019      	str	r1, [r3, #0]
          if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8001104:	4620      	mov	r0, r4
 8001106:	464b      	mov	r3, r9
 8001108:	4946      	ldr	r1, [pc, #280]	; (8001224 <HAL_I2C_Mem_Read+0x1a4>)
 800110a:	f7ff fdca 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 800110e:	2800      	cmp	r0, #0
 8001110:	d047      	beq.n	80011a2 <HAL_I2C_Mem_Read+0x122>
            return HAL_TIMEOUT;
 8001112:	2003      	movs	r0, #3
}
 8001114:	b003      	add	sp, #12
 8001116:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    else if(Size == 2)
 800111a:	2e02      	cmp	r6, #2
 800111c:	d11e      	bne.n	800115c <HAL_I2C_Mem_Read+0xdc>
      hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 800111e:	681a      	ldr	r2, [r3, #0]
 8001120:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001124:	601a      	str	r2, [r3, #0]
      hi2c->Instance->CR1 |= I2C_CR1_POS;
 8001126:	681a      	ldr	r2, [r3, #0]
 8001128:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800112c:	601a      	str	r2, [r3, #0]
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800112e:	695a      	ldr	r2, [r3, #20]
 8001130:	699b      	ldr	r3, [r3, #24]
          if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
 8001132:	493d      	ldr	r1, [pc, #244]	; (8001228 <HAL_I2C_Mem_Read+0x1a8>)
 8001134:	464b      	mov	r3, r9
 8001136:	2200      	movs	r2, #0
 8001138:	4620      	mov	r0, r4
 800113a:	f7ff fdb2 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 800113e:	2800      	cmp	r0, #0
 8001140:	d1e7      	bne.n	8001112 <HAL_I2C_Mem_Read+0x92>
          hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8001142:	6823      	ldr	r3, [r4, #0]
 8001144:	681a      	ldr	r2, [r3, #0]
 8001146:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800114a:	601a      	str	r2, [r3, #0]
          (*pData++) = hi2c->Instance->DR;
 800114c:	691b      	ldr	r3, [r3, #16]
 800114e:	f888 3000 	strb.w	r3, [r8]
          (*pData++) = hi2c->Instance->DR;
 8001152:	6823      	ldr	r3, [r4, #0]
 8001154:	691b      	ldr	r3, [r3, #16]
 8001156:	f888 3001 	strb.w	r3, [r8, #1]
 800115a:	e026      	b.n	80011aa <HAL_I2C_Mem_Read+0x12a>
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800115c:	695a      	ldr	r2, [r3, #20]
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 800115e:	4d31      	ldr	r5, [pc, #196]	; (8001224 <HAL_I2C_Mem_Read+0x1a4>)
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001160:	699b      	ldr	r3, [r3, #24]
      if(Size <= 3)
 8001162:	2e03      	cmp	r6, #3
 8001164:	d934      	bls.n	80011d0 <HAL_I2C_Mem_Read+0x150>
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8001166:	464b      	mov	r3, r9
 8001168:	2200      	movs	r2, #0
 800116a:	4629      	mov	r1, r5
 800116c:	4620      	mov	r0, r4
 800116e:	f7ff fd98 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 8001172:	2800      	cmp	r0, #0
 8001174:	d1cd      	bne.n	8001112 <HAL_I2C_Mem_Read+0x92>
        (*pData++) = hi2c->Instance->DR;
 8001176:	6823      	ldr	r3, [r4, #0]
 8001178:	691b      	ldr	r3, [r3, #16]
 800117a:	f888 3000 	strb.w	r3, [r8]
        if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 800117e:	6822      	ldr	r2, [r4, #0]
 8001180:	6953      	ldr	r3, [r2, #20]
 8001182:	075b      	lsls	r3, r3, #29
        (*pData++) = hi2c->Instance->DR;
 8001184:	bf59      	ittee	pl
 8001186:	f108 0301 	addpl.w	r3, r8, #1
        Size--;
 800118a:	f106 36ff 	addpl.w	r6, r6, #4294967295	; 0xffffffff
          (*pData++) = hi2c->Instance->DR;
 800118e:	f108 0302 	addmi.w	r3, r8, #2
 8001192:	6912      	ldrmi	r2, [r2, #16]
 8001194:	bf44      	itt	mi
 8001196:	f888 2001 	strbmi.w	r2, [r8, #1]
          Size--;
 800119a:	3e02      	submi	r6, #2
 800119c:	b2b6      	uxth	r6, r6
{
 800119e:	4698      	mov	r8, r3
 80011a0:	e7df      	b.n	8001162 <HAL_I2C_Mem_Read+0xe2>
          (*pData++) = hi2c->Instance->DR;
 80011a2:	6823      	ldr	r3, [r4, #0]
 80011a4:	691b      	ldr	r3, [r3, #16]
 80011a6:	f888 3000 	strb.w	r3, [r8]
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 80011aa:	6822      	ldr	r2, [r4, #0]
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout) != HAL_OK)
 80011ac:	491f      	ldr	r1, [pc, #124]	; (800122c <HAL_I2C_Mem_Read+0x1ac>)
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 80011ae:	6813      	ldr	r3, [r2, #0]
 80011b0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80011b4:	6013      	str	r3, [r2, #0]
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout) != HAL_OK)
 80011b6:	4620      	mov	r0, r4
 80011b8:	464b      	mov	r3, r9
 80011ba:	2201      	movs	r2, #1
 80011bc:	f7ff fd71 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 80011c0:	2800      	cmp	r0, #0
 80011c2:	d1a6      	bne.n	8001112 <HAL_I2C_Mem_Read+0x92>
    hi2c->State = HAL_I2C_STATE_READY;
 80011c4:	2301      	movs	r3, #1
 80011c6:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
    __HAL_UNLOCK(hi2c);
 80011ca:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    return HAL_OK;
 80011ce:	e7a1      	b.n	8001114 <HAL_I2C_Mem_Read+0x94>
        else if(Size == 2)
 80011d0:	2e02      	cmp	r6, #2
 80011d2:	d0ae      	beq.n	8001132 <HAL_I2C_Mem_Read+0xb2>
          if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
 80011d4:	2200      	movs	r2, #0
 80011d6:	464b      	mov	r3, r9
 80011d8:	4913      	ldr	r1, [pc, #76]	; (8001228 <HAL_I2C_Mem_Read+0x1a8>)
 80011da:	4620      	mov	r0, r4
 80011dc:	f7ff fd61 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 80011e0:	4602      	mov	r2, r0
 80011e2:	2800      	cmp	r0, #0
 80011e4:	d195      	bne.n	8001112 <HAL_I2C_Mem_Read+0x92>
          hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 80011e6:	6823      	ldr	r3, [r4, #0]
 80011e8:	6819      	ldr	r1, [r3, #0]
 80011ea:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80011ee:	6019      	str	r1, [r3, #0]
          (*pData++) = hi2c->Instance->DR;
 80011f0:	691b      	ldr	r3, [r3, #16]
 80011f2:	f888 3000 	strb.w	r3, [r8]
          if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
 80011f6:	490c      	ldr	r1, [pc, #48]	; (8001228 <HAL_I2C_Mem_Read+0x1a8>)
 80011f8:	464b      	mov	r3, r9
 80011fa:	4620      	mov	r0, r4
 80011fc:	f7ff fd51 	bl	8000ca2 <I2C_WaitOnFlagUntilTimeout>
 8001200:	2800      	cmp	r0, #0
 8001202:	d186      	bne.n	8001112 <HAL_I2C_Mem_Read+0x92>
          hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8001204:	6823      	ldr	r3, [r4, #0]
 8001206:	681a      	ldr	r2, [r3, #0]
 8001208:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800120c:	601a      	str	r2, [r3, #0]
          (*pData++) = hi2c->Instance->DR;
 800120e:	691b      	ldr	r3, [r3, #16]
 8001210:	f888 3001 	strb.w	r3, [r8, #1]
          (*pData++) = hi2c->Instance->DR;
 8001214:	6823      	ldr	r3, [r4, #0]
 8001216:	691b      	ldr	r3, [r3, #16]
 8001218:	f888 3002 	strb.w	r3, [r8, #2]
 800121c:	e7c5      	b.n	80011aa <HAL_I2C_Mem_Read+0x12a>
    return HAL_BUSY;
 800121e:	2002      	movs	r0, #2
 8001220:	e778      	b.n	8001114 <HAL_I2C_Mem_Read+0x94>
 8001222:	bf00      	nop
 8001224:	00010040 	.word	0x00010040
 8001228:	00010004 	.word	0x00010004
 800122c:	00100002 	.word	0x00100002

08001230 <HAL_I2C_GetState>:
  return hi2c->State;
 8001230:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
}
 8001234:	4770      	bx	lr

08001236 <LTDC_SetConfig>:
  uint32_t tmp = 0;
  uint32_t tmp1 = 0;
  uint32_t tmp2 = 0;

  /* Configures the horizontal start and stop position */
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
 8001236:	6800      	ldr	r0, [r0, #0]
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);

  /* Configures the default color values */
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8);
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16);
  tmp2 = (pLayerCfg->Alpha0 << 24);  
 8001238:	f8d1 c018 	ldr.w	ip, [r1, #24]
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 800123c:	01d2      	lsls	r2, r2, #7
{
 800123e:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8001240:	3284      	adds	r2, #132	; 0x84
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
 8001242:	68c4      	ldr	r4, [r0, #12]
 8001244:	684d      	ldr	r5, [r1, #4]
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16) + 1) | tmp);
 8001246:	680e      	ldr	r6, [r1, #0]
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8001248:	1883      	adds	r3, r0, r2
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
 800124a:	f3c4 440b 	ubfx	r4, r4, #16, #12
 800124e:	4425      	add	r5, r4
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8001250:	685c      	ldr	r4, [r3, #4]
 8001252:	f404 4470 	and.w	r4, r4, #61440	; 0xf000
 8001256:	605c      	str	r4, [r3, #4]
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16) + 1) | tmp);
 8001258:	68c4      	ldr	r4, [r0, #12]
 800125a:	3601      	adds	r6, #1
 800125c:	f3c4 440b 	ubfx	r4, r4, #16, #12
 8001260:	4434      	add	r4, r6
 8001262:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8001266:	605c      	str	r4, [r3, #4]
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16);
 8001268:	68c4      	ldr	r4, [r0, #12]
 800126a:	68cd      	ldr	r5, [r1, #12]
 800126c:	f3c4 040a 	ubfx	r4, r4, #0, #11
 8001270:	4425      	add	r5, r4
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 8001272:	689c      	ldr	r4, [r3, #8]
 8001274:	f404 4470 	and.w	r4, r4, #61440	; 0xf000
 8001278:	609c      	str	r4, [r3, #8]
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1) | tmp);  
 800127a:	68c6      	ldr	r6, [r0, #12]
 800127c:	688c      	ldr	r4, [r1, #8]
 800127e:	f3c6 060a 	ubfx	r6, r6, #0, #11
 8001282:	3401      	adds	r4, #1
 8001284:	4434      	add	r4, r6
 8001286:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 800128a:	609c      	str	r4, [r3, #8]
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
 800128c:	691c      	ldr	r4, [r3, #16]
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 800128e:	690d      	ldr	r5, [r1, #16]
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
 8001290:	f024 0407 	bic.w	r4, r4, #7
 8001294:	611c      	str	r4, [r3, #16]
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 8001296:	2600      	movs	r6, #0
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 8001298:	611d      	str	r5, [r3, #16]
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 800129a:	699c      	ldr	r4, [r3, #24]
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16);
 800129c:	f891 7032 	ldrb.w	r7, [r1, #50]	; 0x32
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8);
 80012a0:	f891 e031 	ldrb.w	lr, [r1, #49]	; 0x31
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 80012a4:	619e      	str	r6, [r3, #24]
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2); 
 80012a6:	f891 4030 	ldrb.w	r4, [r1, #48]	; 0x30
 80012aa:	ea44 640c 	orr.w	r4, r4, ip, lsl #24
 80012ae:	ea44 240e 	orr.w	r4, r4, lr, lsl #8
 80012b2:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
 80012b6:	619c      	str	r4, [r3, #24]

  /* Specifies the constant alpha value */
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
 80012b8:	695c      	ldr	r4, [r3, #20]
 80012ba:	f024 04ff 	bic.w	r4, r4, #255	; 0xff
 80012be:	615c      	str	r4, [r3, #20]
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
 80012c0:	694c      	ldr	r4, [r1, #20]
 80012c2:	615c      	str	r4, [r3, #20]

  /* Specifies the blending factors */
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 80012c4:	69dc      	ldr	r4, [r3, #28]
 80012c6:	f424 64e0 	bic.w	r4, r4, #1792	; 0x700
 80012ca:	f024 0407 	bic.w	r4, r4, #7
 80012ce:	61dc      	str	r4, [r3, #28]
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
 80012d0:	69cc      	ldr	r4, [r1, #28]
 80012d2:	6a0f      	ldr	r7, [r1, #32]
 80012d4:	433c      	orrs	r4, r7
 80012d6:	61dc      	str	r4, [r3, #28]

  /* Configures the color frame buffer start address */
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 80012d8:	6a9c      	ldr	r4, [r3, #40]	; 0x28
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 80012da:	6a4c      	ldr	r4, [r1, #36]	; 0x24
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 80012dc:	629e      	str	r6, [r3, #40]	; 0x28
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 80012de:	629c      	str	r4, [r3, #40]	; 0x28

  if(pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
 80012e0:	b1fd      	cbz	r5, 8001322 <LTDC_SetConfig+0xec>
  {
    tmp = 4;
  }
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
 80012e2:	2d01      	cmp	r5, #1
 80012e4:	d01f      	beq.n	8001326 <LTDC_SetConfig+0xf0>
  {
    tmp = 3;
  }
  else if((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
 80012e6:	1eac      	subs	r4, r5, #2
 80012e8:	2c02      	cmp	r4, #2
 80012ea:	d91e      	bls.n	800132a <LTDC_SetConfig+0xf4>
    (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
      (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
 80012ec:	2d07      	cmp	r5, #7
  {
    tmp = 2;
  }
  else
  {
    tmp = 1;
 80012ee:	bf0c      	ite	eq
 80012f0:	2502      	moveq	r5, #2
 80012f2:	2501      	movne	r5, #1
  }

  /* Configures the color frame buffer pitch in byte */
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 80012f4:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 80012f6:	f004 24e0 	and.w	r4, r4, #3758153728	; 0xe000e000
 80012fa:	62dc      	str	r4, [r3, #44]	; 0x2c
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16) | ((pLayerCfg->ImageWidth * tmp)  + 3));
 80012fc:	6a8c      	ldr	r4, [r1, #40]	; 0x28

  /* Configures the frame buffer line number */
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 80012fe:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16) | ((pLayerCfg->ImageWidth * tmp)  + 3));
 8001300:	436c      	muls	r4, r5
 8001302:	1ce5      	adds	r5, r4, #3
 8001304:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
 8001308:	62dc      	str	r4, [r3, #44]	; 0x2c
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 800130a:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 800130c:	f424 64ff 	bic.w	r4, r4, #2040	; 0x7f8
 8001310:	f024 0407 	bic.w	r4, r4, #7
 8001314:	631c      	str	r4, [r3, #48]	; 0x30
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8001316:	6319      	str	r1, [r3, #48]	; 0x30

  /* Enable LTDC_Layer by setting LEN bit */  
  __HAL_LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
 8001318:	5883      	ldr	r3, [r0, r2]
 800131a:	f043 0301 	orr.w	r3, r3, #1
 800131e:	5083      	str	r3, [r0, r2]
 8001320:	bdf0      	pop	{r4, r5, r6, r7, pc}
    tmp = 4;
 8001322:	2504      	movs	r5, #4
 8001324:	e7e6      	b.n	80012f4 <LTDC_SetConfig+0xbe>
    tmp = 3;
 8001326:	2503      	movs	r5, #3
 8001328:	e7e4      	b.n	80012f4 <LTDC_SetConfig+0xbe>
    tmp = 2;
 800132a:	2502      	movs	r5, #2
 800132c:	e7e2      	b.n	80012f4 <LTDC_SetConfig+0xbe>
	...

08001330 <HAL_LTDC_Init>:
{
 8001330:	b538      	push	{r3, r4, r5, lr}
  if(hltdc == NULL)
 8001332:	4604      	mov	r4, r0
 8001334:	2800      	cmp	r0, #0
 8001336:	d063      	beq.n	8001400 <HAL_LTDC_Init+0xd0>
  if(hltdc->State == HAL_LTDC_STATE_RESET)
 8001338:	f890 30a1 	ldrb.w	r3, [r0, #161]	; 0xa1
 800133c:	b90b      	cbnz	r3, 8001342 <HAL_LTDC_Init+0x12>
    HAL_LTDC_MspInit(hltdc);
 800133e:	f004 f909 	bl	8005554 <HAL_LTDC_MspInit>
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8001342:	2302      	movs	r3, #2
 8001344:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 8001348:	6823      	ldr	r3, [r4, #0]
  hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 800134a:	68a0      	ldr	r0, [r4, #8]
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 800134c:	699a      	ldr	r2, [r3, #24]
 800134e:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8001352:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8001354:	6862      	ldr	r2, [r4, #4]
 8001356:	6999      	ldr	r1, [r3, #24]
 8001358:	4302      	orrs	r2, r0
 800135a:	68e0      	ldr	r0, [r4, #12]
 800135c:	4302      	orrs	r2, r0
  hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
 800135e:	6920      	ldr	r0, [r4, #16]
 8001360:	4302      	orrs	r2, r0
  hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8001362:	430a      	orrs	r2, r1
 8001364:	619a      	str	r2, [r3, #24]
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 8001366:	689a      	ldr	r2, [r3, #8]
 8001368:	4926      	ldr	r1, [pc, #152]	; (8001404 <HAL_LTDC_Init+0xd4>)
  tmp = (hltdc->Init.HorizontalSync << 16);
 800136a:	6960      	ldr	r0, [r4, #20]
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 800136c:	400a      	ands	r2, r1
 800136e:	609a      	str	r2, [r3, #8]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
 8001370:	689a      	ldr	r2, [r3, #8]
 8001372:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8001376:	69a0      	ldr	r0, [r4, #24]
 8001378:	4302      	orrs	r2, r0
 800137a:	609a      	str	r2, [r3, #8]
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
 800137c:	68da      	ldr	r2, [r3, #12]
  tmp = (hltdc->Init.AccumulatedHBP << 16);
 800137e:	69e0      	ldr	r0, [r4, #28]
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
 8001380:	400a      	ands	r2, r1
 8001382:	60da      	str	r2, [r3, #12]
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
 8001384:	68da      	ldr	r2, [r3, #12]
 8001386:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 800138a:	6a20      	ldr	r0, [r4, #32]
 800138c:	4302      	orrs	r2, r0
 800138e:	60da      	str	r2, [r3, #12]
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
 8001390:	691a      	ldr	r2, [r3, #16]
  tmp = (hltdc->Init.AccumulatedActiveW << 16);
 8001392:	6a60      	ldr	r0, [r4, #36]	; 0x24
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
 8001394:	400a      	ands	r2, r1
 8001396:	611a      	str	r2, [r3, #16]
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
 8001398:	691a      	ldr	r2, [r3, #16]
 800139a:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 800139e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80013a0:	4302      	orrs	r2, r0
 80013a2:	611a      	str	r2, [r3, #16]
  hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
 80013a4:	695a      	ldr	r2, [r3, #20]
 80013a6:	4011      	ands	r1, r2
 80013a8:	6159      	str	r1, [r3, #20]
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
 80013aa:	695a      	ldr	r2, [r3, #20]
  tmp = (hltdc->Init.TotalWidth << 16);
 80013ac:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
 80013ae:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 80013b2:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80013b4:	430a      	orrs	r2, r1
 80013b6:	615a      	str	r2, [r3, #20]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 80013b8:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16);
 80013ba:	f894 0036 	ldrb.w	r0, [r4, #54]	; 0x36
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8);
 80013be:	f894 5035 	ldrb.w	r5, [r4, #53]	; 0x35
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 80013c2:	f001 417f 	and.w	r1, r1, #4278190080	; 0xff000000
 80013c6:	62d9      	str	r1, [r3, #44]	; 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
 80013c8:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80013ca:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
 80013ce:	430a      	orrs	r2, r1
 80013d0:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
 80013d4:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 80013d8:	62da      	str	r2, [r3, #44]	; 0x2c
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE);
 80013da:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80013dc:	f042 0204 	orr.w	r2, r2, #4
 80013e0:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_FU);
 80013e2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80013e4:	f042 0202 	orr.w	r2, r2, #2
 80013e8:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_LTDC_ENABLE(hltdc);
 80013ea:	699a      	ldr	r2, [r3, #24]
 80013ec:	f042 0201 	orr.w	r2, r2, #1
 80013f0:	619a      	str	r2, [r3, #24]
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;  
 80013f2:	2000      	movs	r0, #0
  hltdc->State = HAL_LTDC_STATE_READY;
 80013f4:	2301      	movs	r3, #1
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;  
 80013f6:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
  hltdc->State = HAL_LTDC_STATE_READY;
 80013fa:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1
  return HAL_OK;
 80013fe:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8001400:	2001      	movs	r0, #1
}
 8001402:	bd38      	pop	{r3, r4, r5, pc}
 8001404:	f000f800 	.word	0xf000f800

08001408 <HAL_LTDC_ConfigLayer>:
{   
 8001408:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hltdc);
 800140a:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
 800140e:	2b01      	cmp	r3, #1
{   
 8001410:	4606      	mov	r6, r0
 8001412:	468e      	mov	lr, r1
 8001414:	4694      	mov	ip, r2
 8001416:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hltdc);
 800141a:	d01d      	beq.n	8001458 <HAL_LTDC_ConfigLayer+0x50>
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
 800141c:	2434      	movs	r4, #52	; 0x34
 800141e:	460d      	mov	r5, r1
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8001420:	f886 00a1 	strb.w	r0, [r6, #161]	; 0xa1
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
 8001424:	fb04 6402 	mla	r4, r4, r2, r6
 8001428:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  __HAL_LOCK(hltdc);
 800142a:	2701      	movs	r7, #1
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
 800142c:	3438      	adds	r4, #56	; 0x38
  __HAL_LOCK(hltdc);
 800142e:	f886 70a0 	strb.w	r7, [r6, #160]	; 0xa0
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
 8001432:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8001434:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8001436:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8001438:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800143a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800143c:	682b      	ldr	r3, [r5, #0]
 800143e:	6023      	str	r3, [r4, #0]
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 8001440:	4630      	mov	r0, r6
 8001442:	4662      	mov	r2, ip
 8001444:	4671      	mov	r1, lr
 8001446:	f7ff fef6 	bl	8001236 <LTDC_SetConfig>
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 800144a:	6833      	ldr	r3, [r6, #0]
  __HAL_UNLOCK(hltdc);
 800144c:	2000      	movs	r0, #0
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 800144e:	625f      	str	r7, [r3, #36]	; 0x24
  hltdc->State  = HAL_LTDC_STATE_READY;
 8001450:	f886 70a1 	strb.w	r7, [r6, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
 8001454:	f886 00a0 	strb.w	r0, [r6, #160]	; 0xa0
}
 8001458:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0800145c <HAL_LTDC_EnableDither>:
  __HAL_LOCK(hltdc);
 800145c:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
 8001460:	2b01      	cmp	r3, #1
 8001462:	f04f 0302 	mov.w	r3, #2
 8001466:	d00c      	beq.n	8001482 <HAL_LTDC_EnableDither+0x26>
  LTDC->GCR |= (uint32_t)LTDC_GCR_DTEN;
 8001468:	4a07      	ldr	r2, [pc, #28]	; (8001488 <HAL_LTDC_EnableDither+0x2c>)
  hltdc->State = HAL_LTDC_STATE_BUSY;
 800146a:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1
  LTDC->GCR |= (uint32_t)LTDC_GCR_DTEN;
 800146e:	6993      	ldr	r3, [r2, #24]
 8001470:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001474:	6193      	str	r3, [r2, #24]
  hltdc->State = HAL_LTDC_STATE_READY; 
 8001476:	2301      	movs	r3, #1
 8001478:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
 800147c:	2300      	movs	r3, #0
 800147e:	f880 30a0 	strb.w	r3, [r0, #160]	; 0xa0
  __HAL_LOCK(hltdc);
 8001482:	4618      	mov	r0, r3
}
 8001484:	4770      	bx	lr
 8001486:	bf00      	nop
 8001488:	40016800 	.word	0x40016800

0800148c <HAL_LTDC_SetAlpha>:
  __HAL_LOCK(hltdc);
 800148c:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
 8001490:	2b01      	cmp	r3, #1
{
 8001492:	b570      	push	{r4, r5, r6, lr}
 8001494:	f04f 0302 	mov.w	r3, #2
 8001498:	4604      	mov	r4, r0
  __HAL_LOCK(hltdc);
 800149a:	d015      	beq.n	80014c8 <HAL_LTDC_SetAlpha+0x3c>
  hltdc->State = HAL_LTDC_STATE_BUSY;
 800149c:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1
  pLayerCfg->Alpha = Alpha;
 80014a0:	2334      	movs	r3, #52	; 0x34
 80014a2:	4353      	muls	r3, r2
 80014a4:	18c6      	adds	r6, r0, r3
  __HAL_LOCK(hltdc);
 80014a6:	2501      	movs	r5, #1
 80014a8:	f880 50a0 	strb.w	r5, [r0, #160]	; 0xa0
  pLayerCfg->Alpha = Alpha;
 80014ac:	64f1      	str	r1, [r6, #76]	; 0x4c
  pLayerCfg = &hltdc->LayerCfg[LayerIdx];
 80014ae:	f103 0138 	add.w	r1, r3, #56	; 0x38
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 80014b2:	4401      	add	r1, r0
 80014b4:	f7ff febf 	bl	8001236 <LTDC_SetConfig>
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 80014b8:	6823      	ldr	r3, [r4, #0]
  __HAL_UNLOCK(hltdc);
 80014ba:	2000      	movs	r0, #0
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 80014bc:	625d      	str	r5, [r3, #36]	; 0x24
  hltdc->State = HAL_LTDC_STATE_READY;
 80014be:	f884 50a1 	strb.w	r5, [r4, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
 80014c2:	f884 00a0 	strb.w	r0, [r4, #160]	; 0xa0
  return HAL_OK;
 80014c6:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hltdc);
 80014c8:	4618      	mov	r0, r3
}
 80014ca:	bd70      	pop	{r4, r5, r6, pc}

080014cc <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and create the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 80014cc:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t i = 0;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 80014ce:	4605      	mov	r5, r0
{ 
 80014d0:	b089      	sub	sp, #36	; 0x24
  if(hpcd == NULL)
 80014d2:	2800      	cmp	r0, #0
 80014d4:	d060      	beq.n	8001598 <HAL_PCD_Init+0xcc>
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = HAL_PCD_STATE_BUSY;
 80014d6:	2303      	movs	r3, #3
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);

  /* Disable the Interrupts */
 __HAL_PCD_DISABLE(hpcd);
 80014d8:	462c      	mov	r4, r5
  hpcd->State = HAL_PCD_STATE_BUSY;
 80014da:	f880 3379 	strb.w	r3, [r0, #889]	; 0x379
  HAL_PCD_MspInit(hpcd);
 80014de:	f004 fcf5 	bl	8005ecc <HAL_PCD_MspInit>
 __HAL_PCD_DISABLE(hpcd);
 80014e2:	f854 0b10 	ldr.w	r0, [r4], #16
 80014e6:	f001 fcc5 	bl	8002e74 <USB_DisableGlobalInt>
 
 /*Init the Core (common init.) */
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 80014ea:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80014ec:	466e      	mov	r6, sp
 80014ee:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80014f0:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 80014f4:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
 80014f8:	1d2f      	adds	r7, r5, #4
 80014fa:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 80014fe:	6828      	ldr	r0, [r5, #0]
 8001500:	f001 fc78 	bl	8002df4 <USB_CoreInit>
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 8001504:	2100      	movs	r1, #0
 8001506:	6828      	ldr	r0, [r5, #0]
 8001508:	f001 fcba 	bl	8002e80 <USB_SetCurrentMode>
 
 /* Init endpoints structures */
 for (i = 0; i < 15 ; i++)
 800150c:	2100      	movs	r1, #0
 800150e:	462b      	mov	r3, r5
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 8001510:	462a      	mov	r2, r5
 8001512:	f105 0410 	add.w	r4, r5, #16
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1;
 8001516:	2601      	movs	r6, #1
   hpcd->IN_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is actvated */
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8001518:	4608      	mov	r0, r1
   hpcd->IN_ep[i].num = i;
 800151a:	f882 1030 	strb.w	r1, [r2, #48]	; 0x30
   hpcd->IN_ep[i].tx_fifo_num = i;
 800151e:	86d1      	strh	r1, [r2, #54]	; 0x36
 for (i = 0; i < 15 ; i++)
 8001520:	3101      	adds	r1, #1
 8001522:	290f      	cmp	r1, #15
   hpcd->IN_ep[i].is_in = 1;
 8001524:	f882 6031 	strb.w	r6, [r2, #49]	; 0x31
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8001528:	f882 0033 	strb.w	r0, [r2, #51]	; 0x33
   hpcd->IN_ep[i].maxpacket =  0;
 800152c:	6390      	str	r0, [r2, #56]	; 0x38
   hpcd->IN_ep[i].xfer_buff = 0;
 800152e:	63d0      	str	r0, [r2, #60]	; 0x3c
   hpcd->IN_ep[i].xfer_len = 0;
 8001530:	6450      	str	r0, [r2, #68]	; 0x44
 8001532:	f102 021c 	add.w	r2, r2, #28
 for (i = 0; i < 15 ; i++)
 8001536:	d1f0      	bne.n	800151a <HAL_PCD_Init+0x4e>
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   hpcd->OUT_ep[i].maxpacket = 0;
   hpcd->OUT_ep[i].xfer_buff = 0;
   hpcd->OUT_ep[i].xfer_len = 0;
   
   hpcd->Instance->DIEPTXF[i] = 0;
 8001538:	2200      	movs	r2, #0
 800153a:	f8d5 e000 	ldr.w	lr, [r5]
   hpcd->OUT_ep[i].is_in = 0;
 800153e:	4611      	mov	r1, r2
   hpcd->Instance->DIEPTXF[i] = 0;
 8001540:	f102 0040 	add.w	r0, r2, #64	; 0x40
   hpcd->OUT_ep[i].num = i;
 8001544:	f883 21d4 	strb.w	r2, [r3, #468]	; 0x1d4
   hpcd->IN_ep[i].tx_fifo_num = i;
 8001548:	86da      	strh	r2, [r3, #54]	; 0x36
   hpcd->Instance->DIEPTXF[i] = 0;
 800154a:	eb0e 0080 	add.w	r0, lr, r0, lsl #2
 for (i = 0; i < 15 ; i++)
 800154e:	3201      	adds	r2, #1
 8001550:	2a0f      	cmp	r2, #15
   hpcd->OUT_ep[i].is_in = 0;
 8001552:	f883 11d5 	strb.w	r1, [r3, #469]	; 0x1d5
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8001556:	f883 11d7 	strb.w	r1, [r3, #471]	; 0x1d7
   hpcd->OUT_ep[i].maxpacket = 0;
 800155a:	f8c3 11dc 	str.w	r1, [r3, #476]	; 0x1dc
   hpcd->OUT_ep[i].xfer_buff = 0;
 800155e:	f8c3 11e0 	str.w	r1, [r3, #480]	; 0x1e0
   hpcd->OUT_ep[i].xfer_len = 0;
 8001562:	f8c3 11e8 	str.w	r1, [r3, #488]	; 0x1e8
   hpcd->Instance->DIEPTXF[i] = 0;
 8001566:	6041      	str	r1, [r0, #4]
 8001568:	f103 031c 	add.w	r3, r3, #28
 for (i = 0; i < 15 ; i++)
 800156c:	d1e8      	bne.n	8001540 <HAL_PCD_Init+0x74>
 }
 
 /* Init Device */
 USB_DevInit(hpcd->Instance, hpcd->Init);
 800156e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8001570:	466e      	mov	r6, sp
 8001572:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8001574:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8001578:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
 800157c:	4670      	mov	r0, lr
 800157e:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8001582:	f001 fc95 	bl	8002eb0 <USB_DevInit>
 
 hpcd->State= HAL_PCD_STATE_READY;
 8001586:	2301      	movs	r3, #1
 8001588:	f885 3379 	strb.w	r3, [r5, #889]	; 0x379
 
 USB_DevDisconnect (hpcd->Instance);  
 800158c:	6828      	ldr	r0, [r5, #0]
 800158e:	f001 ff8f 	bl	80034b0 <USB_DevDisconnect>
 return HAL_OK;
 8001592:	2000      	movs	r0, #0
}
 8001594:	b009      	add	sp, #36	; 0x24
 8001596:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_ERROR;
 8001598:	2001      	movs	r0, #1
 800159a:	e7fb      	b.n	8001594 <HAL_PCD_Init+0xc8>

0800159c <HAL_PCD_Start>:
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 800159c:	f890 3378 	ldrb.w	r3, [r0, #888]	; 0x378
 80015a0:	2b01      	cmp	r3, #1
{ 
 80015a2:	b510      	push	{r4, lr}
 80015a4:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 80015a6:	d00c      	beq.n	80015c2 <HAL_PCD_Start+0x26>
 80015a8:	2301      	movs	r3, #1
 80015aa:	f880 3378 	strb.w	r3, [r0, #888]	; 0x378
  USB_DevConnect (hpcd->Instance);  
 80015ae:	6800      	ldr	r0, [r0, #0]
 80015b0:	f001 ff72 	bl	8003498 <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 80015b4:	6820      	ldr	r0, [r4, #0]
 80015b6:	f001 fc57 	bl	8002e68 <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd); 
 80015ba:	2000      	movs	r0, #0
 80015bc:	f884 0378 	strb.w	r0, [r4, #888]	; 0x378
  return HAL_OK;
 80015c0:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd); 
 80015c2:	2002      	movs	r0, #2
}
 80015c4:	bd10      	pop	{r4, pc}

080015c6 <HAL_PCD_IRQHandler>:
  * @brief  This function handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 80015c6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80015ca:	f8d0 9000 	ldr.w	r9, [r0]
{
 80015ce:	b087      	sub	sp, #28
 80015d0:	4604      	mov	r4, r0
  uint32_t i = 0, ep_intr = 0, epint = 0, epnum = 0;
  uint32_t fifoemptymsk = 0, temp = 0;
  USB_OTG_EPTypeDef *ep;
    
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 80015d2:	4648      	mov	r0, r9
 80015d4:	f001 ffa6 	bl	8003524 <USB_GetMode>
 80015d8:	9002      	str	r0, [sp, #8]
 80015da:	2800      	cmp	r0, #0
 80015dc:	f040 8123 	bne.w	8001826 <HAL_PCD_IRQHandler+0x260>
  {
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
 80015e0:	6820      	ldr	r0, [r4, #0]
 80015e2:	f001 ff71 	bl	80034c8 <USB_ReadInterrupts>
 80015e6:	2800      	cmp	r0, #0
 80015e8:	f000 811d 	beq.w	8001826 <HAL_PCD_IRQHandler+0x260>
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 80015ec:	6820      	ldr	r0, [r4, #0]
 80015ee:	f001 ff6b 	bl	80034c8 <USB_ReadInterrupts>
 80015f2:	0785      	lsls	r5, r0, #30
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 80015f4:	bf48      	it	mi
 80015f6:	6823      	ldrmi	r3, [r4, #0]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 80015f8:	6820      	ldr	r0, [r4, #0]
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 80015fa:	bf44      	itt	mi
 80015fc:	2202      	movmi	r2, #2
 80015fe:	615a      	strmi	r2, [r3, #20]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8001600:	f001 ff62 	bl	80034c8 <USB_ReadInterrupts>
 8001604:	f410 2500 	ands.w	r5, r0, #524288	; 0x80000
 8001608:	d00a      	beq.n	8001620 <HAL_PCD_IRQHandler+0x5a>
    {
      epnum = 0;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 800160a:	6820      	ldr	r0, [r4, #0]
 800160c:	f001 ff60 	bl	80034d0 <USB_ReadDevAllOutEpInterrupt>
 8001610:	f509 6630 	add.w	r6, r9, #2816	; 0xb00
 8001614:	4607      	mov	r7, r0
 8001616:	46a2      	mov	sl, r4
      epnum = 0;
 8001618:	2500      	movs	r5, #0
      
      while ( ep_intr )
 800161a:	2f00      	cmp	r7, #0
 800161c:	f040 8106 	bne.w	800182c <HAL_PCD_IRQHandler+0x266>
        epnum++;
        ep_intr >>= 1;
      }
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8001620:	6820      	ldr	r0, [r4, #0]
 8001622:	f001 ff51 	bl	80034c8 <USB_ReadInterrupts>
 8001626:	0341      	lsls	r1, r0, #13
 8001628:	d50b      	bpl.n	8001642 <HAL_PCD_IRQHandler+0x7c>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 800162a:	6820      	ldr	r0, [r4, #0]
 800162c:	f001 ff58 	bl	80034e0 <USB_ReadDevAllInEpInterrupt>
 8001630:	4626      	mov	r6, r4
 8001632:	9003      	str	r0, [sp, #12]
 8001634:	f509 6810 	add.w	r8, r9, #2304	; 0x900
      
      epnum = 0;
 8001638:	2500      	movs	r5, #0
      
      while ( ep_intr )
 800163a:	9b03      	ldr	r3, [sp, #12]
 800163c:	2b00      	cmp	r3, #0
 800163e:	f040 8136 	bne.w	80018ae <HAL_PCD_IRQHandler+0x2e8>
        ep_intr >>= 1;
      }
    }
    
    /* Handle Resume Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8001642:	6820      	ldr	r0, [r4, #0]
 8001644:	f001 ff40 	bl	80034c8 <USB_ReadInterrupts>
 8001648:	2800      	cmp	r0, #0
 800164a:	da0c      	bge.n	8001666 <HAL_PCD_IRQHandler+0xa0>
    {    
     /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 800164c:	f8d9 3804 	ldr.w	r3, [r9, #2052]	; 0x804
 8001650:	f023 0301 	bic.w	r3, r3, #1
 8001654:	f8c9 3804 	str.w	r3, [r9, #2052]	; 0x804
     
     HAL_PCD_ResumeCallback(hpcd);
 8001658:	4620      	mov	r0, r4
 800165a:	f004 fcad 	bl	8005fb8 <HAL_PCD_ResumeCallback>

     __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 800165e:	6823      	ldr	r3, [r4, #0]
 8001660:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8001664:	615a      	str	r2, [r3, #20]
    }
    
    /* Handle Suspend Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 8001666:	6820      	ldr	r0, [r4, #0]
 8001668:	f001 ff2e 	bl	80034c8 <USB_ReadInterrupts>
 800166c:	0506      	lsls	r6, r0, #20
 800166e:	d50a      	bpl.n	8001686 <HAL_PCD_IRQHandler+0xc0>
    {

      if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 8001670:	f8d9 3808 	ldr.w	r3, [r9, #2056]	; 0x808
 8001674:	07d8      	lsls	r0, r3, #31
 8001676:	d502      	bpl.n	800167e <HAL_PCD_IRQHandler+0xb8>
      {
        
        HAL_PCD_SuspendCallback(hpcd);
 8001678:	4620      	mov	r0, r4
 800167a:	f004 fc85 	bl	8005f88 <HAL_PCD_SuspendCallback>
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 800167e:	6823      	ldr	r3, [r4, #0]
 8001680:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8001684:	615a      	str	r2, [r3, #20]
    }
    


    /* Handle Reset Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8001686:	6820      	ldr	r0, [r4, #0]
 8001688:	f001 ff1e 	bl	80034c8 <USB_ReadInterrupts>
 800168c:	04c1      	lsls	r1, r0, #19
 800168e:	d536      	bpl.n	80016fe <HAL_PCD_IRQHandler+0x138>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 8001690:	f509 6600 	add.w	r6, r9, #2048	; 0x800
 8001694:	6873      	ldr	r3, [r6, #4]
      USB_FlushTxFifo(hpcd->Instance ,  0 );
 8001696:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 8001698:	f023 0301 	bic.w	r3, r3, #1
 800169c:	6073      	str	r3, [r6, #4]
      USB_FlushTxFifo(hpcd->Instance ,  0 );
 800169e:	2100      	movs	r1, #0
 80016a0:	f001 fca2 	bl	8002fe8 <USB_FlushTxFifo>
      
      for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 80016a4:	6861      	ldr	r1, [r4, #4]
 80016a6:	f509 6310 	add.w	r3, r9, #2304	; 0x900
      {
        USBx_INEP(i)->DIEPINT = 0xFF;
 80016aa:	22ff      	movs	r2, #255	; 0xff
      for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 80016ac:	9802      	ldr	r0, [sp, #8]
 80016ae:	4288      	cmp	r0, r1
 80016b0:	f040 818d 	bne.w	80019ce <HAL_PCD_IRQHandler+0x408>
        USBx_OUTEP(i)->DOEPINT = 0xFF;
      }
      USBx_DEVICE->DAINT = 0xFFFFFFFF;
 80016b4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80016b8:	61b3      	str	r3, [r6, #24]
      USBx_DEVICE->DAINTMSK |= 0x10001;
 80016ba:	69f3      	ldr	r3, [r6, #28]
 80016bc:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 80016c0:	61f3      	str	r3, [r6, #28]
      
      if(hpcd->Init.use_dedicated_ep1)
 80016c2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80016c4:	2b00      	cmp	r3, #0
 80016c6:	f000 818a 	beq.w	80019de <HAL_PCD_IRQHandler+0x418>
      {
        USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
 80016ca:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
 80016ce:	f043 030b 	orr.w	r3, r3, #11
 80016d2:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
 80016d6:	6c73      	ldr	r3, [r6, #68]	; 0x44
 80016d8:	f043 030b 	orr.w	r3, r3, #11
 80016dc:	6473      	str	r3, [r6, #68]	; 0x44
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
      }
      
      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 80016de:	f8d9 3800 	ldr.w	r3, [r9, #2048]	; 0x800
      
      /* setup EP0 to receive SETUP packets */
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 80016e2:	7c21      	ldrb	r1, [r4, #16]
 80016e4:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 80016e6:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80016ea:	f8c9 3800 	str.w	r3, [r9, #2048]	; 0x800
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 80016ee:	f504 725f 	add.w	r2, r4, #892	; 0x37c
 80016f2:	f001 ff36 	bl	8003562 <USB_EP0_OutStart>
        
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 80016f6:	6823      	ldr	r3, [r4, #0]
 80016f8:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80016fc:	615a      	str	r2, [r3, #20]
    }
    
    /* Handle Enumeration done Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 80016fe:	6820      	ldr	r0, [r4, #0]
 8001700:	f001 fee2 	bl	80034c8 <USB_ReadInterrupts>
 8001704:	0482      	lsls	r2, r0, #18
 8001706:	d51c      	bpl.n	8001742 <HAL_PCD_IRQHandler+0x17c>
    {
      USB_ActivateSetup(hpcd->Instance);
 8001708:	6820      	ldr	r0, [r4, #0]
 800170a:	f001 ff0f 	bl	800352c <USB_ActivateSetup>
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 800170e:	6820      	ldr	r0, [r4, #0]
 8001710:	68c3      	ldr	r3, [r0, #12]
 8001712:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8001716:	60c3      	str	r3, [r0, #12]
      
      if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
 8001718:	f001 fc8f 	bl	800303a <USB_GetDevSpeed>
 800171c:	6823      	ldr	r3, [r4, #0]
 800171e:	2800      	cmp	r0, #0
 8001720:	f040 8166 	bne.w	80019f0 <HAL_PCD_IRQHandler+0x42a>
      {
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
        hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
 8001724:	f44f 7200 	mov.w	r2, #512	; 0x200
 8001728:	6162      	str	r2, [r4, #20]
        hpcd->Instance->GUSBCFG |= (USB_OTG_GUSBCFG_TRDT_0 | USB_OTG_GUSBCFG_TRDT_3);
 800172a:	68da      	ldr	r2, [r3, #12]
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
 800172c:	60e0      	str	r0, [r4, #12]
        hpcd->Instance->GUSBCFG |= (USB_OTG_GUSBCFG_TRDT_0 | USB_OTG_GUSBCFG_TRDT_3);
 800172e:	f442 5210 	orr.w	r2, r2, #9216	; 0x2400
      }
      else
      {
        hpcd->Init.speed            = USB_OTG_SPEED_FULL;
        hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
        hpcd->Instance->GUSBCFG |= (USB_OTG_GUSBCFG_TRDT_0 | USB_OTG_GUSBCFG_TRDT_2);
 8001732:	60da      	str	r2, [r3, #12]
      }
      
      HAL_PCD_ResetCallback(hpcd);
 8001734:	4620      	mov	r0, r4
 8001736:	f004 fc16 	bl	8005f66 <HAL_PCD_ResetCallback>
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 800173a:	6823      	ldr	r3, [r4, #0]
 800173c:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001740:	615a      	str	r2, [r3, #20]
    }
    
     
    /* Handle RxQLevel Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8001742:	6820      	ldr	r0, [r4, #0]
 8001744:	f001 fec0 	bl	80034c8 <USB_ReadInterrupts>
 8001748:	06c3      	lsls	r3, r0, #27
 800174a:	d52b      	bpl.n	80017a4 <HAL_PCD_IRQHandler+0x1de>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800174c:	6822      	ldr	r2, [r4, #0]
 800174e:	6993      	ldr	r3, [r2, #24]
 8001750:	f023 0310 	bic.w	r3, r3, #16
 8001754:	6193      	str	r3, [r2, #24]
      temp = USBx->GRXSTSP;
 8001756:	f8d9 6020 	ldr.w	r6, [r9, #32]
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
      
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 800175a:	f3c6 4343 	ubfx	r3, r6, #17, #4
 800175e:	2b02      	cmp	r3, #2
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 8001760:	f006 080f 	and.w	r8, r6, #15
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 8001764:	f040 814c 	bne.w	8001a00 <HAL_PCD_IRQHandler+0x43a>
      {
        if((temp & USB_OTG_GRXSTSP_BCNT) != 0)
 8001768:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 800176c:	421e      	tst	r6, r3
 800176e:	d014      	beq.n	800179a <HAL_PCD_IRQHandler+0x1d4>
        {
          USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4);
 8001770:	271c      	movs	r7, #28
 8001772:	fb07 4708 	mla	r7, r7, r8, r4
 8001776:	f3c6 160a 	ubfx	r6, r6, #4, #11
 800177a:	4632      	mov	r2, r6
 800177c:	f8d7 11e0 	ldr.w	r1, [r7, #480]	; 0x1e0
 8001780:	4648      	mov	r0, r9
 8001782:	f001 fe31 	bl	80033e8 <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8001786:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 800178a:	4433      	add	r3, r6
 800178c:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0
        }
      }
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
      {
        USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8);
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8001790:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8001794:	441e      	add	r6, r3
 8001796:	f8c7 61ec 	str.w	r6, [r7, #492]	; 0x1ec
      }
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800179a:	6822      	ldr	r2, [r4, #0]
 800179c:	6993      	ldr	r3, [r2, #24]
 800179e:	f043 0310 	orr.w	r3, r3, #16
 80017a2:	6193      	str	r3, [r2, #24]
    }
    
    /* Handle SOF Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 80017a4:	6820      	ldr	r0, [r4, #0]
 80017a6:	f001 fe8f 	bl	80034c8 <USB_ReadInterrupts>
 80017aa:	0707      	lsls	r7, r0, #28
 80017ac:	d505      	bpl.n	80017ba <HAL_PCD_IRQHandler+0x1f4>
    {
      HAL_PCD_SOFCallback(hpcd);
 80017ae:	4620      	mov	r0, r4
 80017b0:	f004 fbd5 	bl	8005f5e <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 80017b4:	6823      	ldr	r3, [r4, #0]
 80017b6:	2208      	movs	r2, #8
 80017b8:	615a      	str	r2, [r3, #20]
    }
    
    /* Handle Incomplete ISO IN Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 80017ba:	6820      	ldr	r0, [r4, #0]
 80017bc:	f001 fe84 	bl	80034c8 <USB_ReadInterrupts>
 80017c0:	02c6      	lsls	r6, r0, #11
 80017c2:	d507      	bpl.n	80017d4 <HAL_PCD_IRQHandler+0x20e>
    {
      HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
 80017c4:	b2e9      	uxtb	r1, r5
 80017c6:	4620      	mov	r0, r4
 80017c8:	f004 fc1a 	bl	8006000 <HAL_PCD_ISOINIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 80017cc:	6823      	ldr	r3, [r4, #0]
 80017ce:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 80017d2:	615a      	str	r2, [r3, #20]
    } 
    
    /* Handle Incomplete ISO OUT Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 80017d4:	6820      	ldr	r0, [r4, #0]
 80017d6:	f001 fe77 	bl	80034c8 <USB_ReadInterrupts>
 80017da:	0280      	lsls	r0, r0, #10
 80017dc:	d507      	bpl.n	80017ee <HAL_PCD_IRQHandler+0x228>
    {
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
 80017de:	b2e9      	uxtb	r1, r5
 80017e0:	4620      	mov	r0, r4
 80017e2:	f004 fc09 	bl	8005ff8 <HAL_PCD_ISOOUTIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 80017e6:	6823      	ldr	r3, [r4, #0]
 80017e8:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 80017ec:	615a      	str	r2, [r3, #20]
    } 
    
    /* Handle Connection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 80017ee:	6820      	ldr	r0, [r4, #0]
 80017f0:	f001 fe6a 	bl	80034c8 <USB_ReadInterrupts>
 80017f4:	0041      	lsls	r1, r0, #1
 80017f6:	d506      	bpl.n	8001806 <HAL_PCD_IRQHandler+0x240>
    {
      HAL_PCD_ConnectCallback(hpcd);
 80017f8:	4620      	mov	r0, r4
 80017fa:	f004 fc05 	bl	8006008 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 80017fe:	6823      	ldr	r3, [r4, #0]
 8001800:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001804:	615a      	str	r2, [r3, #20]
    } 
    
    /* Handle Disconnection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8001806:	6820      	ldr	r0, [r4, #0]
 8001808:	f001 fe5e 	bl	80034c8 <USB_ReadInterrupts>
 800180c:	0742      	lsls	r2, r0, #29
 800180e:	d50a      	bpl.n	8001826 <HAL_PCD_IRQHandler+0x260>
    {
      temp = hpcd->Instance->GOTGINT;
 8001810:	6823      	ldr	r3, [r4, #0]
 8001812:	685d      	ldr	r5, [r3, #4]
      
      if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8001814:	076b      	lsls	r3, r5, #29
 8001816:	d502      	bpl.n	800181e <HAL_PCD_IRQHandler+0x258>
      {
        HAL_PCD_DisconnectCallback(hpcd);
 8001818:	4620      	mov	r0, r4
 800181a:	f004 fbf9 	bl	8006010 <HAL_PCD_DisconnectCallback>
      }
      hpcd->Instance->GOTGINT |= temp;
 800181e:	6823      	ldr	r3, [r4, #0]
 8001820:	685a      	ldr	r2, [r3, #4]
 8001822:	4315      	orrs	r5, r2
 8001824:	605d      	str	r5, [r3, #4]
    }
  }
}
 8001826:	b007      	add	sp, #28
 8001828:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (ep_intr & 0x1)
 800182c:	07f8      	lsls	r0, r7, #31
 800182e:	d538      	bpl.n	80018a2 <HAL_PCD_IRQHandler+0x2dc>
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 8001830:	fa5f fb85 	uxtb.w	fp, r5
 8001834:	4659      	mov	r1, fp
 8001836:	6820      	ldr	r0, [r4, #0]
 8001838:	f001 fe5a 	bl	80034f0 <USB_ReadDevOutEPInterrupt>
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 800183c:	f010 0f01 	tst.w	r0, #1
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 8001840:	4680      	mov	r8, r0
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8001842:	d021      	beq.n	8001888 <HAL_PCD_IRQHandler+0x2c2>
            if(hpcd->Init.dma_enable == 1)
 8001844:	6921      	ldr	r1, [r4, #16]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8001846:	2301      	movs	r3, #1
            if(hpcd->Init.dma_enable == 1)
 8001848:	4299      	cmp	r1, r3
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 800184a:	60b3      	str	r3, [r6, #8]
            if(hpcd->Init.dma_enable == 1)
 800184c:	d10c      	bne.n	8001868 <HAL_PCD_IRQHandler+0x2a2>
              hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
 800184e:	6931      	ldr	r1, [r6, #16]
 8001850:	f8da 01dc 	ldr.w	r0, [sl, #476]	; 0x1dc
 8001854:	f3c1 0112 	ubfx	r1, r1, #0, #19
 8001858:	1a41      	subs	r1, r0, r1
 800185a:	f8ca 11ec 	str.w	r1, [sl, #492]	; 0x1ec
              hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
 800185e:	f8da 11e0 	ldr.w	r1, [sl, #480]	; 0x1e0
 8001862:	4408      	add	r0, r1
 8001864:	f8ca 01e0 	str.w	r0, [sl, #480]	; 0x1e0
            HAL_PCD_DataOutStageCallback(hpcd, epnum);
 8001868:	4659      	mov	r1, fp
 800186a:	4620      	mov	r0, r4
 800186c:	f004 fb66 	bl	8005f3c <HAL_PCD_DataOutStageCallback>
            if(hpcd->Init.dma_enable == 1)
 8001870:	6921      	ldr	r1, [r4, #16]
 8001872:	2901      	cmp	r1, #1
 8001874:	d108      	bne.n	8001888 <HAL_PCD_IRQHandler+0x2c2>
              if((epnum == 0) && (hpcd->OUT_ep[epnum].xfer_len == 0))
 8001876:	b93d      	cbnz	r5, 8001888 <HAL_PCD_IRQHandler+0x2c2>
 8001878:	f8d4 21e8 	ldr.w	r2, [r4, #488]	; 0x1e8
 800187c:	b922      	cbnz	r2, 8001888 <HAL_PCD_IRQHandler+0x2c2>
                USB_EP0_OutStart(hpcd->Instance, 1, (uint8_t *)hpcd->Setup);
 800187e:	f504 725f 	add.w	r2, r4, #892	; 0x37c
 8001882:	6820      	ldr	r0, [r4, #0]
 8001884:	f001 fe6d 	bl	8003562 <USB_EP0_OutStart>
          if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8001888:	f018 0f08 	tst.w	r8, #8
 800188c:	d004      	beq.n	8001898 <HAL_PCD_IRQHandler+0x2d2>
            HAL_PCD_SetupStageCallback(hpcd);
 800188e:	4620      	mov	r0, r4
 8001890:	f004 fb4e 	bl	8005f30 <HAL_PCD_SetupStageCallback>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8001894:	2308      	movs	r3, #8
 8001896:	60b3      	str	r3, [r6, #8]
          if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8001898:	f018 0f10 	tst.w	r8, #16
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 800189c:	bf1c      	itt	ne
 800189e:	2310      	movne	r3, #16
 80018a0:	60b3      	strne	r3, [r6, #8]
        epnum++;
 80018a2:	3501      	adds	r5, #1
        ep_intr >>= 1;
 80018a4:	087f      	lsrs	r7, r7, #1
 80018a6:	3620      	adds	r6, #32
 80018a8:	f10a 0a1c 	add.w	sl, sl, #28
 80018ac:	e6b5      	b.n	800161a <HAL_PCD_IRQHandler+0x54>
        if (ep_intr & 0x1) /* In ITR */
 80018ae:	9b03      	ldr	r3, [sp, #12]
 80018b0:	07da      	lsls	r2, r3, #31
 80018b2:	d565      	bpl.n	8001980 <HAL_PCD_IRQHandler+0x3ba>
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 80018b4:	fa5f fa85 	uxtb.w	sl, r5
 80018b8:	4651      	mov	r1, sl
 80018ba:	6820      	ldr	r0, [r4, #0]
 80018bc:	f001 fe22 	bl	8003504 <USB_ReadDevInEPInterrupt>
           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 80018c0:	07c3      	lsls	r3, r0, #31
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 80018c2:	4607      	mov	r7, r0
           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 80018c4:	d520      	bpl.n	8001908 <HAL_PCD_IRQHandler+0x342>
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80018c6:	f8d9 3834 	ldr.w	r3, [r9, #2100]	; 0x834
            fifoemptymsk = 0x1 << epnum;
 80018ca:	2101      	movs	r1, #1
 80018cc:	40a9      	lsls	r1, r5
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80018ce:	ea23 0301 	bic.w	r3, r3, r1
 80018d2:	f8c9 3834 	str.w	r3, [r9, #2100]	; 0x834
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 80018d6:	2301      	movs	r3, #1
 80018d8:	f8c8 3008 	str.w	r3, [r8, #8]
            if (hpcd->Init.dma_enable == 1)
 80018dc:	6923      	ldr	r3, [r4, #16]
 80018de:	2b01      	cmp	r3, #1
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket; 
 80018e0:	bf01      	itttt	eq
 80018e2:	6bf3      	ldreq	r3, [r6, #60]	; 0x3c
 80018e4:	6bb2      	ldreq	r2, [r6, #56]	; 0x38
 80018e6:	189b      	addeq	r3, r3, r2
 80018e8:	63f3      	streq	r3, [r6, #60]	; 0x3c
            HAL_PCD_DataInStageCallback(hpcd, epnum);
 80018ea:	4651      	mov	r1, sl
 80018ec:	4620      	mov	r0, r4
 80018ee:	f004 fb2e 	bl	8005f4e <HAL_PCD_DataInStageCallback>
            if (hpcd->Init.dma_enable == 1)
 80018f2:	6921      	ldr	r1, [r4, #16]
 80018f4:	2901      	cmp	r1, #1
 80018f6:	d107      	bne.n	8001908 <HAL_PCD_IRQHandler+0x342>
              if((epnum == 0) && (hpcd->IN_ep[epnum].xfer_len == 0))
 80018f8:	b935      	cbnz	r5, 8001908 <HAL_PCD_IRQHandler+0x342>
 80018fa:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80018fc:	b923      	cbnz	r3, 8001908 <HAL_PCD_IRQHandler+0x342>
                USB_EP0_OutStart(hpcd->Instance, 1, (uint8_t *)hpcd->Setup);
 80018fe:	f504 725f 	add.w	r2, r4, #892	; 0x37c
 8001902:	6820      	ldr	r0, [r4, #0]
 8001904:	f001 fe2d 	bl	8003562 <USB_EP0_OutStart>
           if(( epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8001908:	0738      	lsls	r0, r7, #28
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 800190a:	bf44      	itt	mi
 800190c:	2308      	movmi	r3, #8
 800190e:	f8c8 3008 	strmi.w	r3, [r8, #8]
          if(( epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8001912:	06f9      	lsls	r1, r7, #27
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8001914:	bf44      	itt	mi
 8001916:	2310      	movmi	r3, #16
 8001918:	f8c8 3008 	strmi.w	r3, [r8, #8]
          if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 800191c:	067a      	lsls	r2, r7, #25
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 800191e:	bf44      	itt	mi
 8001920:	2340      	movmi	r3, #64	; 0x40
 8001922:	f8c8 3008 	strmi.w	r3, [r8, #8]
          if(( epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8001926:	07bb      	lsls	r3, r7, #30
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8001928:	bf44      	itt	mi
 800192a:	2302      	movmi	r3, #2
 800192c:	f8c8 3008 	strmi.w	r3, [r8, #8]
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8001930:	063f      	lsls	r7, r7, #24
 8001932:	d525      	bpl.n	8001980 <HAL_PCD_IRQHandler+0x3ba>
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 8001934:	6823      	ldr	r3, [r4, #0]
 8001936:	9304      	str	r3, [sp, #16]
  int32_t len = 0;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 8001938:	6c77      	ldr	r7, [r6, #68]	; 0x44
 800193a:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 800193c:	1aff      	subs	r7, r7, r3
 800193e:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8001940:	429f      	cmp	r7, r3
 8001942:	bf28      	it	cs
 8001944:	461f      	movcs	r7, r3
  {
    len = ep->maxpacket;
  }
  
  
  len32b = (len + 3) / 4;
 8001946:	f107 0b03 	add.w	fp, r7, #3
 800194a:	2304      	movs	r3, #4
 800194c:	fb9b fbf3 	sdiv	fp, fp, r3
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8001950:	9b04      	ldr	r3, [sp, #16]
 8001952:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8001956:	eb03 1345 	add.w	r3, r3, r5, lsl #5
 800195a:	9305      	str	r3, [sp, #20]
 800195c:	9b05      	ldr	r3, [sp, #20]
 800195e:	699b      	ldr	r3, [r3, #24]
 8001960:	b29b      	uxth	r3, r3
 8001962:	455b      	cmp	r3, fp
 8001964:	d814      	bhi.n	8001990 <HAL_PCD_IRQHandler+0x3ca>
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
  }
  
  if(len <= 0)
 8001966:	2f00      	cmp	r7, #0
 8001968:	dc0a      	bgt.n	8001980 <HAL_PCD_IRQHandler+0x3ba>
  {
    fifoemptymsk = 0x1 << epnum;
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800196a:	9b04      	ldr	r3, [sp, #16]
    fifoemptymsk = 0x1 << epnum;
 800196c:	2201      	movs	r2, #1
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800196e:	f503 6a00 	add.w	sl, r3, #2048	; 0x800
 8001972:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
    fifoemptymsk = 0x1 << epnum;
 8001976:	40aa      	lsls	r2, r5
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8001978:	ea23 0302 	bic.w	r3, r3, r2
 800197c:	f8ca 3034 	str.w	r3, [sl, #52]	; 0x34
        ep_intr >>= 1;
 8001980:	9b03      	ldr	r3, [sp, #12]
 8001982:	085b      	lsrs	r3, r3, #1
        epnum++;
 8001984:	3501      	adds	r5, #1
        ep_intr >>= 1;
 8001986:	9303      	str	r3, [sp, #12]
 8001988:	361c      	adds	r6, #28
 800198a:	f108 0820 	add.w	r8, r8, #32
 800198e:	e654      	b.n	800163a <HAL_PCD_IRQHandler+0x74>
          ep->xfer_count < ep->xfer_len &&
 8001990:	6cb2      	ldr	r2, [r6, #72]	; 0x48
 8001992:	6c73      	ldr	r3, [r6, #68]	; 0x44
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8001994:	4293      	cmp	r3, r2
 8001996:	d9e6      	bls.n	8001966 <HAL_PCD_IRQHandler+0x3a0>
          ep->xfer_count < ep->xfer_len &&
 8001998:	2b00      	cmp	r3, #0
 800199a:	d0e4      	beq.n	8001966 <HAL_PCD_IRQHandler+0x3a0>
 800199c:	6bb7      	ldr	r7, [r6, #56]	; 0x38
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 800199e:	9804      	ldr	r0, [sp, #16]
    len = ep->xfer_len - ep->xfer_count;
 80019a0:	1a9b      	subs	r3, r3, r2
 80019a2:	429f      	cmp	r7, r3
 80019a4:	bf28      	it	cs
 80019a6:	461f      	movcs	r7, r3
    len32b = (len + 3) / 4;
 80019a8:	f107 0b03 	add.w	fp, r7, #3
 80019ac:	2304      	movs	r3, #4
 80019ae:	fb9b fbf3 	sdiv	fp, fp, r3
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 80019b2:	7c23      	ldrb	r3, [r4, #16]
 80019b4:	9300      	str	r3, [sp, #0]
 80019b6:	4652      	mov	r2, sl
 80019b8:	b2bb      	uxth	r3, r7
 80019ba:	6bf1      	ldr	r1, [r6, #60]	; 0x3c
 80019bc:	f001 fd01 	bl	80033c2 <USB_WritePacket>
    ep->xfer_buff  += len;
 80019c0:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 80019c2:	443b      	add	r3, r7
 80019c4:	63f3      	str	r3, [r6, #60]	; 0x3c
    ep->xfer_count += len;
 80019c6:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 80019c8:	443b      	add	r3, r7
 80019ca:	64b3      	str	r3, [r6, #72]	; 0x48
 80019cc:	e7c6      	b.n	800195c <HAL_PCD_IRQHandler+0x396>
      for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 80019ce:	9802      	ldr	r0, [sp, #8]
        USBx_INEP(i)->DIEPINT = 0xFF;
 80019d0:	609a      	str	r2, [r3, #8]
      for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 80019d2:	3001      	adds	r0, #1
        USBx_OUTEP(i)->DOEPINT = 0xFF;
 80019d4:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
      for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 80019d8:	9002      	str	r0, [sp, #8]
 80019da:	3320      	adds	r3, #32
 80019dc:	e666      	b.n	80016ac <HAL_PCD_IRQHandler+0xe6>
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
 80019de:	6973      	ldr	r3, [r6, #20]
 80019e0:	f043 030b 	orr.w	r3, r3, #11
 80019e4:	6173      	str	r3, [r6, #20]
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
 80019e6:	6933      	ldr	r3, [r6, #16]
 80019e8:	f043 030b 	orr.w	r3, r3, #11
 80019ec:	6133      	str	r3, [r6, #16]
 80019ee:	e676      	b.n	80016de <HAL_PCD_IRQHandler+0x118>
        hpcd->Init.speed            = USB_OTG_SPEED_FULL;
 80019f0:	2203      	movs	r2, #3
 80019f2:	60e2      	str	r2, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
 80019f4:	2240      	movs	r2, #64	; 0x40
 80019f6:	6162      	str	r2, [r4, #20]
        hpcd->Instance->GUSBCFG |= (USB_OTG_GUSBCFG_TRDT_0 | USB_OTG_GUSBCFG_TRDT_2);
 80019f8:	68da      	ldr	r2, [r3, #12]
 80019fa:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 80019fe:	e698      	b.n	8001732 <HAL_PCD_IRQHandler+0x16c>
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
 8001a00:	2b06      	cmp	r3, #6
 8001a02:	f47f aeca 	bne.w	800179a <HAL_PCD_IRQHandler+0x1d4>
        USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8);
 8001a06:	2208      	movs	r2, #8
 8001a08:	f504 715f 	add.w	r1, r4, #892	; 0x37c
 8001a0c:	4648      	mov	r0, r9
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8001a0e:	271c      	movs	r7, #28
        USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8);
 8001a10:	f001 fcea 	bl	80033e8 <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8001a14:	fb07 4708 	mla	r7, r7, r8, r4
 8001a18:	f3c6 160a 	ubfx	r6, r6, #4, #11
 8001a1c:	e6b8      	b.n	8001790 <HAL_PCD_IRQHandler+0x1ca>

08001a1e <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd); 
 8001a1e:	f890 3378 	ldrb.w	r3, [r0, #888]	; 0x378
 8001a22:	2b01      	cmp	r3, #1
{
 8001a24:	b510      	push	{r4, lr}
 8001a26:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 8001a28:	d009      	beq.n	8001a3e <HAL_PCD_SetAddress+0x20>
 8001a2a:	2301      	movs	r3, #1
 8001a2c:	f880 3378 	strb.w	r3, [r0, #888]	; 0x378
  USB_SetDevAddress(hpcd->Instance, address);
 8001a30:	6800      	ldr	r0, [r0, #0]
 8001a32:	f001 fd21 	bl	8003478 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);   
 8001a36:	2000      	movs	r0, #0
 8001a38:	f884 0378 	strb.w	r0, [r4, #888]	; 0x378
  return HAL_OK;
 8001a3c:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd); 
 8001a3e:	2002      	movs	r0, #2
}
 8001a40:	bd10      	pop	{r4, pc}

08001a42 <HAL_PCD_EP_Open>:
{
 8001a42:	b570      	push	{r4, r5, r6, lr}
  if ((ep_addr & 0x80) == 0x80)
 8001a44:	b24e      	sxtb	r6, r1
 8001a46:	2e00      	cmp	r6, #0
{
 8001a48:	4604      	mov	r4, r0
 8001a4a:	f04f 051c 	mov.w	r5, #28
 8001a4e:	f001 007f 	and.w	r0, r1, #127	; 0x7f
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001a52:	bfb5      	itete	lt
 8001a54:	fb05 4100 	mlalt	r1, r5, r0, r4
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8001a58:	fb05 4101 	mlage	r1, r5, r1, r4
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001a5c:	3130      	addlt	r1, #48	; 0x30
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8001a5e:	f501 71ea 	addge.w	r1, r1, #468	; 0x1d4
  ep->num   = ep_addr & 0x7F;
 8001a62:	b2c0      	uxtb	r0, r0
  if (ep->is_in)
 8001a64:	2e00      	cmp	r6, #0
    ep->tx_fifo_num = ep->num;
 8001a66:	bfb8      	it	lt
 8001a68:	80c8      	strhlt	r0, [r1, #6]
  if (ep_type == EP_TYPE_BULK )
 8001a6a:	2b02      	cmp	r3, #2
  ep->type = ep_type;
 8001a6c:	70cb      	strb	r3, [r1, #3]
  ep->is_in = (0x80 & ep_addr) != 0;
 8001a6e:	ea4f 75d6 	mov.w	r5, r6, lsr #31
    ep->data_pid_start = 0;
 8001a72:	bf04      	itt	eq
 8001a74:	2300      	moveq	r3, #0
 8001a76:	710b      	strbeq	r3, [r1, #4]
  ep->num   = ep_addr & 0x7F;
 8001a78:	7008      	strb	r0, [r1, #0]
  ep->is_in = (0x80 & ep_addr) != 0;
 8001a7a:	704d      	strb	r5, [r1, #1]
  __HAL_LOCK(hpcd); 
 8001a7c:	f894 3378 	ldrb.w	r3, [r4, #888]	; 0x378
  ep->maxpacket = ep_mps;
 8001a80:	608a      	str	r2, [r1, #8]
  __HAL_LOCK(hpcd); 
 8001a82:	2b01      	cmp	r3, #1
 8001a84:	d009      	beq.n	8001a9a <HAL_PCD_EP_Open+0x58>
 8001a86:	2301      	movs	r3, #1
 8001a88:	f884 3378 	strb.w	r3, [r4, #888]	; 0x378
  USB_ActivateEndpoint(hpcd->Instance , ep);
 8001a8c:	6820      	ldr	r0, [r4, #0]
 8001a8e:	f001 faef 	bl	8003070 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 8001a92:	2000      	movs	r0, #0
 8001a94:	f884 0378 	strb.w	r0, [r4, #888]	; 0x378
  return ret;
 8001a98:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hpcd); 
 8001a9a:	2002      	movs	r0, #2
}
 8001a9c:	bd70      	pop	{r4, r5, r6, pc}

08001a9e <HAL_PCD_EP_Close>:
  if ((ep_addr & 0x80) == 0x80)
 8001a9e:	b24b      	sxtb	r3, r1
 8001aa0:	2b00      	cmp	r3, #0
{  
 8001aa2:	b510      	push	{r4, lr}
 8001aa4:	f04f 021c 	mov.w	r2, #28
 8001aa8:	4604      	mov	r4, r0
 8001aaa:	f001 007f 	and.w	r0, r1, #127	; 0x7f
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001aae:	bfb5      	itete	lt
 8001ab0:	fb02 4100 	mlalt	r1, r2, r0, r4
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8001ab4:	fb02 4101 	mlage	r1, r2, r1, r4
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001ab8:	3130      	addlt	r1, #48	; 0x30
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8001aba:	f501 71ea 	addge.w	r1, r1, #468	; 0x1d4
  ep->is_in = (0x80 & ep_addr) != 0;
 8001abe:	0fdb      	lsrs	r3, r3, #31
  ep->num   = ep_addr & 0x7F;
 8001ac0:	7008      	strb	r0, [r1, #0]
  ep->is_in = (0x80 & ep_addr) != 0;
 8001ac2:	704b      	strb	r3, [r1, #1]
  __HAL_LOCK(hpcd); 
 8001ac4:	f894 3378 	ldrb.w	r3, [r4, #888]	; 0x378
 8001ac8:	2b01      	cmp	r3, #1
 8001aca:	d009      	beq.n	8001ae0 <HAL_PCD_EP_Close+0x42>
 8001acc:	2301      	movs	r3, #1
 8001ace:	f884 3378 	strb.w	r3, [r4, #888]	; 0x378
  USB_DeactivateEndpoint(hpcd->Instance , ep);
 8001ad2:	6820      	ldr	r0, [r4, #0]
 8001ad4:	f001 fb0b 	bl	80030ee <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 8001ad8:	2000      	movs	r0, #0
 8001ada:	f884 0378 	strb.w	r0, [r4, #888]	; 0x378
  return HAL_OK;
 8001ade:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd); 
 8001ae0:	2002      	movs	r0, #2
}
 8001ae2:	bd10      	pop	{r4, pc}

08001ae4 <HAL_PCD_EP_Receive>:
{
 8001ae4:	b538      	push	{r3, r4, r5, lr}
 8001ae6:	4604      	mov	r4, r0
 8001ae8:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  ep->xfer_buff = pBuf;  
 8001aec:	201c      	movs	r0, #28
 8001aee:	fb00 4005 	mla	r0, r0, r5, r4
  ep->xfer_len = len;
 8001af2:	f8c0 31e8 	str.w	r3, [r0, #488]	; 0x1e8
  ep->xfer_count = 0;
 8001af6:	2300      	movs	r3, #0
  ep->xfer_buff = pBuf;  
 8001af8:	f8c0 21e0 	str.w	r2, [r0, #480]	; 0x1e0
  ep->xfer_count = 0;
 8001afc:	f8c0 31ec 	str.w	r3, [r0, #492]	; 0x1ec
  ep->is_in = 0;
 8001b00:	f880 31d5 	strb.w	r3, [r0, #469]	; 0x1d5
  ep->num = ep_addr & 0x7F;
 8001b04:	f880 51d4 	strb.w	r5, [r0, #468]	; 0x1d4
  if (hpcd->Init.dma_enable == 1)
 8001b08:	6923      	ldr	r3, [r4, #16]
 8001b0a:	2b01      	cmp	r3, #1
    ep->dma_addr = (uint32_t)pBuf;  
 8001b0c:	bf08      	it	eq
 8001b0e:	f8c0 21e4 	streq.w	r2, [r0, #484]	; 0x1e4
  __HAL_LOCK(hpcd); 
 8001b12:	f894 2378 	ldrb.w	r2, [r4, #888]	; 0x378
 8001b16:	2a01      	cmp	r2, #1
 8001b18:	d013      	beq.n	8001b42 <HAL_PCD_EP_Receive+0x5e>
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8001b1a:	211c      	movs	r1, #28
  __HAL_LOCK(hpcd); 
 8001b1c:	2201      	movs	r2, #1
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8001b1e:	fb01 4105 	mla	r1, r1, r5, r4
  __HAL_LOCK(hpcd); 
 8001b22:	f884 2378 	strb.w	r2, [r4, #888]	; 0x378
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8001b26:	f501 71ea 	add.w	r1, r1, #468	; 0x1d4
 8001b2a:	b2da      	uxtb	r2, r3
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8001b2c:	6820      	ldr	r0, [r4, #0]
  if ((ep_addr & 0x7F) == 0 )
 8001b2e:	b92d      	cbnz	r5, 8001b3c <HAL_PCD_EP_Receive+0x58>
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8001b30:	f001 fbd0 	bl	80032d4 <USB_EP0StartXfer>
  __HAL_UNLOCK(hpcd); 
 8001b34:	2000      	movs	r0, #0
 8001b36:	f884 0378 	strb.w	r0, [r4, #888]	; 0x378
  return HAL_OK;
 8001b3a:	bd38      	pop	{r3, r4, r5, pc}
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8001b3c:	f001 fb04 	bl	8003148 <USB_EPStartXfer>
 8001b40:	e7f8      	b.n	8001b34 <HAL_PCD_EP_Receive+0x50>
  __HAL_LOCK(hpcd); 
 8001b42:	2002      	movs	r0, #2
}
 8001b44:	bd38      	pop	{r3, r4, r5, pc}

08001b46 <HAL_PCD_EP_Transmit>:
{
 8001b46:	b538      	push	{r3, r4, r5, lr}
 8001b48:	4604      	mov	r4, r0
 8001b4a:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  ep->xfer_buff = pBuf;  
 8001b4e:	201c      	movs	r0, #28
 8001b50:	fb00 4005 	mla	r0, r0, r5, r4
  ep->xfer_len = len;
 8001b54:	6443      	str	r3, [r0, #68]	; 0x44
  ep->xfer_count = 0;
 8001b56:	2300      	movs	r3, #0
 8001b58:	6483      	str	r3, [r0, #72]	; 0x48
  ep->is_in = 1;
 8001b5a:	2301      	movs	r3, #1
  ep->xfer_buff = pBuf;  
 8001b5c:	63c2      	str	r2, [r0, #60]	; 0x3c
  ep->is_in = 1;
 8001b5e:	f880 3031 	strb.w	r3, [r0, #49]	; 0x31
  ep->num = ep_addr & 0x7F;
 8001b62:	f880 5030 	strb.w	r5, [r0, #48]	; 0x30
  if (hpcd->Init.dma_enable == 1)
 8001b66:	6923      	ldr	r3, [r4, #16]
 8001b68:	2b01      	cmp	r3, #1
    ep->dma_addr = (uint32_t)pBuf;  
 8001b6a:	bf08      	it	eq
 8001b6c:	6402      	streq	r2, [r0, #64]	; 0x40
  __HAL_LOCK(hpcd); 
 8001b6e:	f894 2378 	ldrb.w	r2, [r4, #888]	; 0x378
 8001b72:	2a01      	cmp	r2, #1
 8001b74:	d012      	beq.n	8001b9c <HAL_PCD_EP_Transmit+0x56>
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001b76:	211c      	movs	r1, #28
  __HAL_LOCK(hpcd); 
 8001b78:	2201      	movs	r2, #1
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001b7a:	fb01 4105 	mla	r1, r1, r5, r4
  __HAL_LOCK(hpcd); 
 8001b7e:	f884 2378 	strb.w	r2, [r4, #888]	; 0x378
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001b82:	3130      	adds	r1, #48	; 0x30
 8001b84:	b2da      	uxtb	r2, r3
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8001b86:	6820      	ldr	r0, [r4, #0]
  if ((ep_addr & 0x7F) == 0 )
 8001b88:	b92d      	cbnz	r5, 8001b96 <HAL_PCD_EP_Transmit+0x50>
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8001b8a:	f001 fba3 	bl	80032d4 <USB_EP0StartXfer>
  __HAL_UNLOCK(hpcd);
 8001b8e:	2000      	movs	r0, #0
 8001b90:	f884 0378 	strb.w	r0, [r4, #888]	; 0x378
  return HAL_OK;
 8001b94:	bd38      	pop	{r3, r4, r5, pc}
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8001b96:	f001 fad7 	bl	8003148 <USB_EPStartXfer>
 8001b9a:	e7f8      	b.n	8001b8e <HAL_PCD_EP_Transmit+0x48>
  __HAL_LOCK(hpcd); 
 8001b9c:	2002      	movs	r0, #2
}
 8001b9e:	bd38      	pop	{r3, r4, r5, pc}

08001ba0 <HAL_PCD_EP_SetStall>:
{
 8001ba0:	b538      	push	{r3, r4, r5, lr}
  if ((0x80 & ep_addr) == 0x80)
 8001ba2:	b24b      	sxtb	r3, r1
 8001ba4:	2b00      	cmp	r3, #0
 8001ba6:	f001 057f 	and.w	r5, r1, #127	; 0x7f
 8001baa:	f04f 021c 	mov.w	r2, #28
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001bae:	bfb5      	itete	lt
 8001bb0:	fb02 0105 	mlalt	r1, r2, r5, r0
    ep = &hpcd->OUT_ep[ep_addr];
 8001bb4:	fb02 0101 	mlage	r1, r2, r1, r0
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001bb8:	3130      	addlt	r1, #48	; 0x30
    ep = &hpcd->OUT_ep[ep_addr];
 8001bba:	f501 71ea 	addge.w	r1, r1, #468	; 0x1d4
  ep->is_stall = 1;
 8001bbe:	2201      	movs	r2, #1
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8001bc0:	0fdb      	lsrs	r3, r3, #31
  ep->num   = ep_addr & 0x7F;
 8001bc2:	b2ed      	uxtb	r5, r5
  ep->is_stall = 1;
 8001bc4:	708a      	strb	r2, [r1, #2]
  ep->num   = ep_addr & 0x7F;
 8001bc6:	700d      	strb	r5, [r1, #0]
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8001bc8:	704b      	strb	r3, [r1, #1]
  __HAL_LOCK(hpcd); 
 8001bca:	f890 3378 	ldrb.w	r3, [r0, #888]	; 0x378
 8001bce:	4293      	cmp	r3, r2
{
 8001bd0:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 8001bd2:	d00f      	beq.n	8001bf4 <HAL_PCD_EP_SetStall+0x54>
 8001bd4:	f880 2378 	strb.w	r2, [r0, #888]	; 0x378
  USB_EPSetStall(hpcd->Instance , ep);
 8001bd8:	6800      	ldr	r0, [r0, #0]
 8001bda:	f001 fc15 	bl	8003408 <USB_EPSetStall>
  if((ep_addr & 0x7F) == 0)
 8001bde:	b92d      	cbnz	r5, 8001bec <HAL_PCD_EP_SetStall+0x4c>
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8001be0:	f504 725f 	add.w	r2, r4, #892	; 0x37c
 8001be4:	7c21      	ldrb	r1, [r4, #16]
 8001be6:	6820      	ldr	r0, [r4, #0]
 8001be8:	f001 fcbb 	bl	8003562 <USB_EP0_OutStart>
  __HAL_UNLOCK(hpcd); 
 8001bec:	2000      	movs	r0, #0
 8001bee:	f884 0378 	strb.w	r0, [r4, #888]	; 0x378
  return HAL_OK;
 8001bf2:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(hpcd); 
 8001bf4:	2002      	movs	r0, #2
}
 8001bf6:	bd38      	pop	{r3, r4, r5, pc}

08001bf8 <HAL_PCD_EP_ClrStall>:
{
 8001bf8:	b538      	push	{r3, r4, r5, lr}
  if ((0x80 & ep_addr) == 0x80)
 8001bfa:	b24b      	sxtb	r3, r1
 8001bfc:	2b00      	cmp	r3, #0
{
 8001bfe:	4605      	mov	r5, r0
 8001c00:	f04f 021c 	mov.w	r2, #28
 8001c04:	f001 007f 	and.w	r0, r1, #127	; 0x7f
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001c08:	bfb5      	itete	lt
 8001c0a:	fb02 5100 	mlalt	r1, r2, r0, r5
    ep = &hpcd->OUT_ep[ep_addr];
 8001c0e:	fb02 5101 	mlage	r1, r2, r1, r5
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001c12:	3130      	addlt	r1, #48	; 0x30
    ep = &hpcd->OUT_ep[ep_addr];
 8001c14:	f501 71ea 	addge.w	r1, r1, #468	; 0x1d4
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8001c18:	0fdb      	lsrs	r3, r3, #31
  ep->is_stall = 0;
 8001c1a:	2400      	movs	r4, #0
 8001c1c:	708c      	strb	r4, [r1, #2]
  ep->num   = ep_addr & 0x7F;
 8001c1e:	7008      	strb	r0, [r1, #0]
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8001c20:	704b      	strb	r3, [r1, #1]
  __HAL_LOCK(hpcd); 
 8001c22:	f895 3378 	ldrb.w	r3, [r5, #888]	; 0x378
 8001c26:	2b01      	cmp	r3, #1
 8001c28:	d009      	beq.n	8001c3e <HAL_PCD_EP_ClrStall+0x46>
 8001c2a:	2301      	movs	r3, #1
 8001c2c:	f885 3378 	strb.w	r3, [r5, #888]	; 0x378
  USB_EPClearStall(hpcd->Instance , ep);
 8001c30:	6828      	ldr	r0, [r5, #0]
 8001c32:	f001 fc08 	bl	8003446 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd); 
 8001c36:	f885 4378 	strb.w	r4, [r5, #888]	; 0x378
  return HAL_OK;
 8001c3a:	4620      	mov	r0, r4
 8001c3c:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(hpcd); 
 8001c3e:	2002      	movs	r0, #2
}
 8001c40:	bd38      	pop	{r3, r4, r5, pc}

08001c42 <HAL_PCDEx_SetTxFiFo>:
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top 
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */
  
  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8001c42:	6800      	ldr	r0, [r0, #0]
{
 8001c44:	b570      	push	{r4, r5, r6, lr}
  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8001c46:	6a43      	ldr	r3, [r0, #36]	; 0x24
  
  if(fifo == 0)
 8001c48:	b921      	cbnz	r1, 8001c54 <HAL_PCDEx_SetTxFiFo+0x12>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (size << 16) | Tx_Offset;
 8001c4a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001c4e:	6283      	str	r3, [r0, #40]	; 0x28
    hpcd->Instance->DIEPTXF[fifo - 1] = (size << 16) | Tx_Offset;
    
  }
  
  return HAL_OK;
}
 8001c50:	2000      	movs	r0, #0
 8001c52:	bd70      	pop	{r4, r5, r6, pc}
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 8001c54:	6a84      	ldr	r4, [r0, #40]	; 0x28
    for (i = 0; i < (fifo - 1); i++)
 8001c56:	2500      	movs	r5, #0
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 8001c58:	eb03 4314 	add.w	r3, r3, r4, lsr #16
    for (i = 0; i < (fifo - 1); i++)
 8001c5c:	1e4e      	subs	r6, r1, #1
 8001c5e:	b2ec      	uxtb	r4, r5
 8001c60:	42b4      	cmp	r4, r6
 8001c62:	f105 0501 	add.w	r5, r5, #1
 8001c66:	db06      	blt.n	8001c76 <HAL_PCDEx_SetTxFiFo+0x34>
    hpcd->Instance->DIEPTXF[fifo - 1] = (size << 16) | Tx_Offset;
 8001c68:	313f      	adds	r1, #63	; 0x3f
 8001c6a:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 8001c6e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001c72:	6043      	str	r3, [r0, #4]
 8001c74:	e7ec      	b.n	8001c50 <HAL_PCDEx_SetTxFiFo+0xe>
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8001c76:	3440      	adds	r4, #64	; 0x40
 8001c78:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8001c7c:	6864      	ldr	r4, [r4, #4]
 8001c7e:	eb03 4314 	add.w	r3, r3, r4, lsr #16
 8001c82:	e7ec      	b.n	8001c5e <HAL_PCDEx_SetTxFiFo+0x1c>

08001c84 <HAL_PCDEx_SetRxFiFo>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  
  hpcd->Instance->GRXFSIZ = size;
 8001c84:	6803      	ldr	r3, [r0, #0]
  
  return HAL_OK;
}
 8001c86:	2000      	movs	r0, #0
  hpcd->Instance->GRXFSIZ = size;
 8001c88:	6259      	str	r1, [r3, #36]	; 0x24
}
 8001c8a:	4770      	bx	lr

08001c8c <HAL_PWREx_ActivateOverDrive>:
  */
HAL_StatusTypeDef HAL_PWREx_ActivateOverDrive(void)
{
  uint32_t tickstart = 0;

  __PWR_CLK_ENABLE();
 8001c8c:	4a15      	ldr	r2, [pc, #84]	; (8001ce4 <HAL_PWREx_ActivateOverDrive+0x58>)
{
 8001c8e:	b538      	push	{r3, r4, r5, lr}
  __PWR_CLK_ENABLE();
 8001c90:	6c13      	ldr	r3, [r2, #64]	; 0x40
  __HAL_PWR_OVERDRIVE_ENABLE();

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8001c92:	4c15      	ldr	r4, [pc, #84]	; (8001ce8 <HAL_PWREx_ActivateOverDrive+0x5c>)
  __PWR_CLK_ENABLE();
 8001c94:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001c98:	6413      	str	r3, [r2, #64]	; 0x40
  __HAL_PWR_OVERDRIVE_ENABLE();
 8001c9a:	4b14      	ldr	r3, [pc, #80]	; (8001cec <HAL_PWREx_ActivateOverDrive+0x60>)
 8001c9c:	2201      	movs	r2, #1
 8001c9e:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8001ca0:	f7fe fb00 	bl	80002a4 <HAL_GetTick>
 8001ca4:	4605      	mov	r5, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8001ca6:	6863      	ldr	r3, [r4, #4]
 8001ca8:	03da      	lsls	r2, r3, #15
 8001caa:	d50b      	bpl.n	8001cc4 <HAL_PWREx_ActivateOverDrive+0x38>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8001cac:	4b10      	ldr	r3, [pc, #64]	; (8001cf0 <HAL_PWREx_ActivateOverDrive+0x64>)

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8001cae:	4c0e      	ldr	r4, [pc, #56]	; (8001ce8 <HAL_PWREx_ActivateOverDrive+0x5c>)
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8001cb0:	2201      	movs	r2, #1
 8001cb2:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8001cb4:	f7fe faf6 	bl	80002a4 <HAL_GetTick>
 8001cb8:	4605      	mov	r5, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8001cba:	6863      	ldr	r3, [r4, #4]
 8001cbc:	039b      	lsls	r3, r3, #14
 8001cbe:	d509      	bpl.n	8001cd4 <HAL_PWREx_ActivateOverDrive+0x48>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 8001cc0:	2000      	movs	r0, #0
}
 8001cc2:	bd38      	pop	{r3, r4, r5, pc}
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8001cc4:	f7fe faee 	bl	80002a4 <HAL_GetTick>
 8001cc8:	1b40      	subs	r0, r0, r5
 8001cca:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8001cce:	d9ea      	bls.n	8001ca6 <HAL_PWREx_ActivateOverDrive+0x1a>
      return HAL_TIMEOUT;
 8001cd0:	2003      	movs	r0, #3
 8001cd2:	bd38      	pop	{r3, r4, r5, pc}
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8001cd4:	f7fe fae6 	bl	80002a4 <HAL_GetTick>
 8001cd8:	1b40      	subs	r0, r0, r5
 8001cda:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8001cde:	d9ec      	bls.n	8001cba <HAL_PWREx_ActivateOverDrive+0x2e>
 8001ce0:	e7f6      	b.n	8001cd0 <HAL_PWREx_ActivateOverDrive+0x44>
 8001ce2:	bf00      	nop
 8001ce4:	40023800 	.word	0x40023800
 8001ce8:	40007000 	.word	0x40007000
 8001cec:	420e0040 	.word	0x420e0040
 8001cf0:	420e0044 	.word	0x420e0044

08001cf4 <HAL_RCC_OscConfig>:
  uint32_t tickstart = 0;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001cf4:	6803      	ldr	r3, [r0, #0]
{
 8001cf6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001cfa:	07df      	lsls	r7, r3, #31
{
 8001cfc:	4604      	mov	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001cfe:	d43f      	bmi.n	8001d80 <HAL_RCC_OscConfig+0x8c>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001d00:	6823      	ldr	r3, [r4, #0]
 8001d02:	079e      	lsls	r6, r3, #30
 8001d04:	f100 808c 	bmi.w	8001e20 <HAL_RCC_OscConfig+0x12c>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001d08:	6823      	ldr	r3, [r4, #0]
 8001d0a:	071a      	lsls	r2, r3, #28
 8001d0c:	f100 80db 	bmi.w	8001ec6 <HAL_RCC_OscConfig+0x1d2>
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001d10:	6823      	ldr	r3, [r4, #0]
 8001d12:	075b      	lsls	r3, r3, #29
 8001d14:	d52d      	bpl.n	8001d72 <HAL_RCC_OscConfig+0x7e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __PWR_CLK_ENABLE();
 8001d16:	4ab4      	ldr	r2, [pc, #720]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8001d18:	4db4      	ldr	r5, [pc, #720]	; (8001fec <HAL_RCC_OscConfig+0x2f8>)
    __PWR_CLK_ENABLE();
 8001d1a:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8001d1c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001d20:	6413      	str	r3, [r2, #64]	; 0x40
    PWR->CR |= PWR_CR_DBP;
 8001d22:	682b      	ldr	r3, [r5, #0]
 8001d24:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001d28:	602b      	str	r3, [r5, #0]
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8001d2a:	f7fe fabb 	bl	80002a4 <HAL_GetTick>
 8001d2e:	4606      	mov	r6, r0
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8001d30:	682b      	ldr	r3, [r5, #0]
 8001d32:	05d9      	lsls	r1, r3, #23
 8001d34:	f140 80e9 	bpl.w	8001f0a <HAL_RCC_OscConfig+0x216>
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 8001d38:	4dad      	ldr	r5, [pc, #692]	; (8001ff0 <HAL_RCC_OscConfig+0x2fc>)
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001d3a:	4eab      	ldr	r6, [pc, #684]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 8001d3c:	2300      	movs	r3, #0
 8001d3e:	702b      	strb	r3, [r5, #0]
    tickstart = HAL_GetTick();
 8001d40:	f7fe fab0 	bl	80002a4 <HAL_GetTick>
    {
      if((HAL_GetTick() - tickstart ) > LSE_TIMEOUT_VALUE)
 8001d44:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8001d48:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001d4a:	6f33      	ldr	r3, [r6, #112]	; 0x70
 8001d4c:	079a      	lsls	r2, r3, #30
 8001d4e:	f100 80e3 	bmi.w	8001f18 <HAL_RCC_OscConfig+0x224>
        return HAL_TIMEOUT;
      }    
    } 
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001d52:	7a23      	ldrb	r3, [r4, #8]
 8001d54:	702b      	strb	r3, [r5, #0]
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) == RCC_LSE_ON)
 8001d56:	68a3      	ldr	r3, [r4, #8]
 8001d58:	2b01      	cmp	r3, #1
 8001d5a:	f040 80eb 	bne.w	8001f34 <HAL_RCC_OscConfig+0x240>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001d5e:	f7fe faa1 	bl	80002a4 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001d62:	4da1      	ldr	r5, [pc, #644]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
      tickstart = HAL_GetTick();
 8001d64:	4606      	mov	r6, r0
      {
        if((HAL_GetTick() - tickstart ) > LSE_TIMEOUT_VALUE)
 8001d66:	f241 3788 	movw	r7, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001d6a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001d6c:	079b      	lsls	r3, r3, #30
 8001d6e:	f140 80da 	bpl.w	8001f26 <HAL_RCC_OscConfig+0x232>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8001d72:	69a2      	ldr	r2, [r4, #24]
 8001d74:	2a00      	cmp	r2, #0
 8001d76:	f040 80ed 	bne.w	8001f54 <HAL_RCC_OscConfig+0x260>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8001d7a:	2000      	movs	r0, #0
 8001d7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001d80:	4b99      	ldr	r3, [pc, #612]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
 8001d82:	689a      	ldr	r2, [r3, #8]
 8001d84:	f002 020c 	and.w	r2, r2, #12
 8001d88:	2a04      	cmp	r2, #4
 8001d8a:	d007      	beq.n	8001d9c <HAL_RCC_OscConfig+0xa8>
 8001d8c:	689a      	ldr	r2, [r3, #8]
 8001d8e:	f002 020c 	and.w	r2, r2, #12
 8001d92:	2a08      	cmp	r2, #8
 8001d94:	d10c      	bne.n	8001db0 <HAL_RCC_OscConfig+0xbc>
 8001d96:	685b      	ldr	r3, [r3, #4]
 8001d98:	025d      	lsls	r5, r3, #9
 8001d9a:	d509      	bpl.n	8001db0 <HAL_RCC_OscConfig+0xbc>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState != RCC_HSE_ON))
 8001d9c:	4b92      	ldr	r3, [pc, #584]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
 8001d9e:	681b      	ldr	r3, [r3, #0]
 8001da0:	0398      	lsls	r0, r3, #14
 8001da2:	d5ad      	bpl.n	8001d00 <HAL_RCC_OscConfig+0xc>
 8001da4:	6863      	ldr	r3, [r4, #4]
 8001da6:	2b01      	cmp	r3, #1
 8001da8:	d0aa      	beq.n	8001d00 <HAL_RCC_OscConfig+0xc>
        return HAL_ERROR;
 8001daa:	2001      	movs	r0, #1
 8001dac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 8001db0:	4d90      	ldr	r5, [pc, #576]	; (8001ff4 <HAL_RCC_OscConfig+0x300>)
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001db2:	4e8d      	ldr	r6, [pc, #564]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 8001db4:	2300      	movs	r3, #0
 8001db6:	702b      	strb	r3, [r5, #0]
      tickstart = HAL_GetTick();
 8001db8:	f7fe fa74 	bl	80002a4 <HAL_GetTick>
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001dbc:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8001dc0:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001dc2:	6833      	ldr	r3, [r6, #0]
 8001dc4:	0399      	lsls	r1, r3, #14
 8001dc6:	d413      	bmi.n	8001df0 <HAL_RCC_OscConfig+0xfc>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001dc8:	7923      	ldrb	r3, [r4, #4]
 8001dca:	702b      	strb	r3, [r5, #0]
      if((RCC_OscInitStruct->HSEState) == RCC_HSE_ON)
 8001dcc:	6863      	ldr	r3, [r4, #4]
 8001dce:	2b01      	cmp	r3, #1
 8001dd0:	d116      	bne.n	8001e00 <HAL_RCC_OscConfig+0x10c>
        tickstart = HAL_GetTick();
 8001dd2:	f7fe fa67 	bl	80002a4 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001dd6:	4d84      	ldr	r5, [pc, #528]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
        tickstart = HAL_GetTick();
 8001dd8:	4606      	mov	r6, r0
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001dda:	f241 3788 	movw	r7, #5000	; 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001dde:	682b      	ldr	r3, [r5, #0]
 8001de0:	039a      	lsls	r2, r3, #14
 8001de2:	d48d      	bmi.n	8001d00 <HAL_RCC_OscConfig+0xc>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001de4:	f7fe fa5e 	bl	80002a4 <HAL_GetTick>
 8001de8:	1b80      	subs	r0, r0, r6
 8001dea:	42b8      	cmp	r0, r7
 8001dec:	d9f7      	bls.n	8001dde <HAL_RCC_OscConfig+0xea>
 8001dee:	e004      	b.n	8001dfa <HAL_RCC_OscConfig+0x106>
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001df0:	f7fe fa58 	bl	80002a4 <HAL_GetTick>
 8001df4:	1bc0      	subs	r0, r0, r7
 8001df6:	4540      	cmp	r0, r8
 8001df8:	d9e3      	bls.n	8001dc2 <HAL_RCC_OscConfig+0xce>
          return HAL_TIMEOUT;
 8001dfa:	2003      	movs	r0, #3
 8001dfc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        tickstart = HAL_GetTick();
 8001e00:	f7fe fa50 	bl	80002a4 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001e04:	4d78      	ldr	r5, [pc, #480]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
        tickstart = HAL_GetTick();
 8001e06:	4606      	mov	r6, r0
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001e08:	f241 3788 	movw	r7, #5000	; 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001e0c:	682b      	ldr	r3, [r5, #0]
 8001e0e:	039b      	lsls	r3, r3, #14
 8001e10:	f57f af76 	bpl.w	8001d00 <HAL_RCC_OscConfig+0xc>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001e14:	f7fe fa46 	bl	80002a4 <HAL_GetTick>
 8001e18:	1b80      	subs	r0, r0, r6
 8001e1a:	42b8      	cmp	r0, r7
 8001e1c:	d9f6      	bls.n	8001e0c <HAL_RCC_OscConfig+0x118>
 8001e1e:	e7ec      	b.n	8001dfa <HAL_RCC_OscConfig+0x106>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001e20:	4b71      	ldr	r3, [pc, #452]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
 8001e22:	689a      	ldr	r2, [r3, #8]
 8001e24:	f012 0f0c 	tst.w	r2, #12
 8001e28:	d007      	beq.n	8001e3a <HAL_RCC_OscConfig+0x146>
 8001e2a:	689a      	ldr	r2, [r3, #8]
 8001e2c:	f002 020c 	and.w	r2, r2, #12
 8001e30:	2a08      	cmp	r2, #8
 8001e32:	d118      	bne.n	8001e66 <HAL_RCC_OscConfig+0x172>
 8001e34:	685b      	ldr	r3, [r3, #4]
 8001e36:	025e      	lsls	r6, r3, #9
 8001e38:	d415      	bmi.n	8001e66 <HAL_RCC_OscConfig+0x172>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001e3a:	4a6b      	ldr	r2, [pc, #428]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
 8001e3c:	6813      	ldr	r3, [r2, #0]
 8001e3e:	079d      	lsls	r5, r3, #30
 8001e40:	d502      	bpl.n	8001e48 <HAL_RCC_OscConfig+0x154>
 8001e42:	68e3      	ldr	r3, [r4, #12]
 8001e44:	2b01      	cmp	r3, #1
 8001e46:	d1b0      	bne.n	8001daa <HAL_RCC_OscConfig+0xb6>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001e48:	6811      	ldr	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001e4a:	23f8      	movs	r3, #248	; 0xf8
 8001e4c:	fa93 f3a3 	rbit	r3, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8001e50:	fab3 f383 	clz	r3, r3
 8001e54:	6920      	ldr	r0, [r4, #16]
 8001e56:	b2db      	uxtb	r3, r3
 8001e58:	fa00 f303 	lsl.w	r3, r0, r3
 8001e5c:	f021 01f8 	bic.w	r1, r1, #248	; 0xf8
 8001e60:	430b      	orrs	r3, r1
 8001e62:	6013      	str	r3, [r2, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001e64:	e750      	b.n	8001d08 <HAL_RCC_OscConfig+0x14>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8001e66:	68e2      	ldr	r2, [r4, #12]
 8001e68:	4b63      	ldr	r3, [pc, #396]	; (8001ff8 <HAL_RCC_OscConfig+0x304>)
 8001e6a:	b1ea      	cbz	r2, 8001ea8 <HAL_RCC_OscConfig+0x1b4>
        __HAL_RCC_HSI_ENABLE();
 8001e6c:	2201      	movs	r2, #1
 8001e6e:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001e70:	f7fe fa18 	bl	80002a4 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001e74:	4d5c      	ldr	r5, [pc, #368]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
        tickstart = HAL_GetTick();
 8001e76:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001e78:	682b      	ldr	r3, [r5, #0]
 8001e7a:	0798      	lsls	r0, r3, #30
 8001e7c:	d50e      	bpl.n	8001e9c <HAL_RCC_OscConfig+0x1a8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001e7e:	682a      	ldr	r2, [r5, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001e80:	23f8      	movs	r3, #248	; 0xf8
 8001e82:	fa93 f3a3 	rbit	r3, r3
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8001e86:	fab3 f383 	clz	r3, r3
 8001e8a:	6921      	ldr	r1, [r4, #16]
 8001e8c:	b2db      	uxtb	r3, r3
 8001e8e:	fa01 f303 	lsl.w	r3, r1, r3
 8001e92:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8001e96:	4313      	orrs	r3, r2
 8001e98:	602b      	str	r3, [r5, #0]
 8001e9a:	e735      	b.n	8001d08 <HAL_RCC_OscConfig+0x14>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001e9c:	f7fe fa02 	bl	80002a4 <HAL_GetTick>
 8001ea0:	1b80      	subs	r0, r0, r6
 8001ea2:	2864      	cmp	r0, #100	; 0x64
 8001ea4:	d9e8      	bls.n	8001e78 <HAL_RCC_OscConfig+0x184>
 8001ea6:	e7a8      	b.n	8001dfa <HAL_RCC_OscConfig+0x106>
        __HAL_RCC_HSI_DISABLE();
 8001ea8:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001eaa:	f7fe f9fb 	bl	80002a4 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001eae:	4d4e      	ldr	r5, [pc, #312]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
        tickstart = HAL_GetTick();
 8001eb0:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001eb2:	682b      	ldr	r3, [r5, #0]
 8001eb4:	0799      	lsls	r1, r3, #30
 8001eb6:	f57f af27 	bpl.w	8001d08 <HAL_RCC_OscConfig+0x14>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001eba:	f7fe f9f3 	bl	80002a4 <HAL_GetTick>
 8001ebe:	1b80      	subs	r0, r0, r6
 8001ec0:	2864      	cmp	r0, #100	; 0x64
 8001ec2:	d9f6      	bls.n	8001eb2 <HAL_RCC_OscConfig+0x1be>
 8001ec4:	e799      	b.n	8001dfa <HAL_RCC_OscConfig+0x106>
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8001ec6:	6962      	ldr	r2, [r4, #20]
 8001ec8:	4b4c      	ldr	r3, [pc, #304]	; (8001ffc <HAL_RCC_OscConfig+0x308>)
 8001eca:	b17a      	cbz	r2, 8001eec <HAL_RCC_OscConfig+0x1f8>
      __HAL_RCC_LSI_ENABLE();
 8001ecc:	2201      	movs	r2, #1
 8001ece:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8001ed0:	f7fe f9e8 	bl	80002a4 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001ed4:	4d44      	ldr	r5, [pc, #272]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
      tickstart = HAL_GetTick();
 8001ed6:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001ed8:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8001eda:	079f      	lsls	r7, r3, #30
 8001edc:	f53f af18 	bmi.w	8001d10 <HAL_RCC_OscConfig+0x1c>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001ee0:	f7fe f9e0 	bl	80002a4 <HAL_GetTick>
 8001ee4:	1b80      	subs	r0, r0, r6
 8001ee6:	2864      	cmp	r0, #100	; 0x64
 8001ee8:	d9f6      	bls.n	8001ed8 <HAL_RCC_OscConfig+0x1e4>
 8001eea:	e786      	b.n	8001dfa <HAL_RCC_OscConfig+0x106>
      __HAL_RCC_LSI_DISABLE();
 8001eec:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8001eee:	f7fe f9d9 	bl	80002a4 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001ef2:	4d3d      	ldr	r5, [pc, #244]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
      tickstart = HAL_GetTick();
 8001ef4:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001ef6:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8001ef8:	0798      	lsls	r0, r3, #30
 8001efa:	f57f af09 	bpl.w	8001d10 <HAL_RCC_OscConfig+0x1c>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001efe:	f7fe f9d1 	bl	80002a4 <HAL_GetTick>
 8001f02:	1b80      	subs	r0, r0, r6
 8001f04:	2864      	cmp	r0, #100	; 0x64
 8001f06:	d9f6      	bls.n	8001ef6 <HAL_RCC_OscConfig+0x202>
 8001f08:	e777      	b.n	8001dfa <HAL_RCC_OscConfig+0x106>
      if((HAL_GetTick() - tickstart ) > DBP_TIMEOUT_VALUE)
 8001f0a:	f7fe f9cb 	bl	80002a4 <HAL_GetTick>
 8001f0e:	1b80      	subs	r0, r0, r6
 8001f10:	2864      	cmp	r0, #100	; 0x64
 8001f12:	f67f af0d 	bls.w	8001d30 <HAL_RCC_OscConfig+0x3c>
 8001f16:	e770      	b.n	8001dfa <HAL_RCC_OscConfig+0x106>
      if((HAL_GetTick() - tickstart ) > LSE_TIMEOUT_VALUE)
 8001f18:	f7fe f9c4 	bl	80002a4 <HAL_GetTick>
 8001f1c:	1bc0      	subs	r0, r0, r7
 8001f1e:	4540      	cmp	r0, r8
 8001f20:	f67f af13 	bls.w	8001d4a <HAL_RCC_OscConfig+0x56>
 8001f24:	e769      	b.n	8001dfa <HAL_RCC_OscConfig+0x106>
        if((HAL_GetTick() - tickstart ) > LSE_TIMEOUT_VALUE)
 8001f26:	f7fe f9bd 	bl	80002a4 <HAL_GetTick>
 8001f2a:	1b80      	subs	r0, r0, r6
 8001f2c:	42b8      	cmp	r0, r7
 8001f2e:	f67f af1c 	bls.w	8001d6a <HAL_RCC_OscConfig+0x76>
 8001f32:	e762      	b.n	8001dfa <HAL_RCC_OscConfig+0x106>
      tickstart = HAL_GetTick();
 8001f34:	f7fe f9b6 	bl	80002a4 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001f38:	4d2b      	ldr	r5, [pc, #172]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
      tickstart = HAL_GetTick();
 8001f3a:	4606      	mov	r6, r0
        if((HAL_GetTick() - tickstart ) > LSE_TIMEOUT_VALUE)
 8001f3c:	f241 3788 	movw	r7, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001f40:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001f42:	0798      	lsls	r0, r3, #30
 8001f44:	f57f af15 	bpl.w	8001d72 <HAL_RCC_OscConfig+0x7e>
        if((HAL_GetTick() - tickstart ) > LSE_TIMEOUT_VALUE)
 8001f48:	f7fe f9ac 	bl	80002a4 <HAL_GetTick>
 8001f4c:	1b80      	subs	r0, r0, r6
 8001f4e:	42b8      	cmp	r0, r7
 8001f50:	d9f6      	bls.n	8001f40 <HAL_RCC_OscConfig+0x24c>
 8001f52:	e752      	b.n	8001dfa <HAL_RCC_OscConfig+0x106>
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8001f54:	4d24      	ldr	r5, [pc, #144]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
 8001f56:	68ab      	ldr	r3, [r5, #8]
 8001f58:	f003 030c 	and.w	r3, r3, #12
 8001f5c:	2b08      	cmp	r3, #8
 8001f5e:	f43f af24 	beq.w	8001daa <HAL_RCC_OscConfig+0xb6>
 8001f62:	4e27      	ldr	r6, [pc, #156]	; (8002000 <HAL_RCC_OscConfig+0x30c>)
 8001f64:	2300      	movs	r3, #0
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001f66:	2a02      	cmp	r2, #2
        __HAL_RCC_PLL_DISABLE();
 8001f68:	6033      	str	r3, [r6, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001f6a:	d151      	bne.n	8002010 <HAL_RCC_OscConfig+0x31c>
        tickstart = HAL_GetTick();
 8001f6c:	f7fe f99a 	bl	80002a4 <HAL_GetTick>
 8001f70:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001f72:	682b      	ldr	r3, [r5, #0]
 8001f74:	0199      	lsls	r1, r3, #6
 8001f76:	d445      	bmi.n	8002004 <HAL_RCC_OscConfig+0x310>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001f78:	f647 70c0 	movw	r0, #32704	; 0x7fc0
 8001f7c:	fa90 f0a0 	rbit	r0, r0
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8001f80:	fab0 f080 	clz	r0, r0
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001f84:	f44f 3740 	mov.w	r7, #196608	; 0x30000
 8001f88:	fa97 f7a7 	rbit	r7, r7
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8001f8c:	fab7 f787 	clz	r7, r7
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001f90:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
 8001f94:	fa92 f2a2 	rbit	r2, r2
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8001f98:	fab2 f282 	clz	r2, r2
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001f9c:	69e1      	ldr	r1, [r4, #28]
 8001f9e:	6a23      	ldr	r3, [r4, #32]
 8001fa0:	430b      	orrs	r3, r1
 8001fa2:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8001fa4:	b2c0      	uxtb	r0, r0
 8001fa6:	fa01 f000 	lsl.w	r0, r1, r0
 8001faa:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8001fac:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8001fb0:	0849      	lsrs	r1, r1, #1
 8001fb2:	4303      	orrs	r3, r0
 8001fb4:	3901      	subs	r1, #1
 8001fb6:	b2f8      	uxtb	r0, r7
 8001fb8:	4081      	lsls	r1, r0
 8001fba:	430b      	orrs	r3, r1
 8001fbc:	b2d1      	uxtb	r1, r2
 8001fbe:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001fc0:	4c09      	ldr	r4, [pc, #36]	; (8001fe8 <HAL_RCC_OscConfig+0x2f4>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001fc2:	408a      	lsls	r2, r1
 8001fc4:	4313      	orrs	r3, r2
 8001fc6:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8001fc8:	2301      	movs	r3, #1
 8001fca:	6033      	str	r3, [r6, #0]
        tickstart = HAL_GetTick();
 8001fcc:	f7fe f96a 	bl	80002a4 <HAL_GetTick>
 8001fd0:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001fd2:	6823      	ldr	r3, [r4, #0]
 8001fd4:	019a      	lsls	r2, r3, #6
 8001fd6:	f53f aed0 	bmi.w	8001d7a <HAL_RCC_OscConfig+0x86>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001fda:	f7fe f963 	bl	80002a4 <HAL_GetTick>
 8001fde:	1b40      	subs	r0, r0, r5
 8001fe0:	2864      	cmp	r0, #100	; 0x64
 8001fe2:	d9f6      	bls.n	8001fd2 <HAL_RCC_OscConfig+0x2de>
 8001fe4:	e709      	b.n	8001dfa <HAL_RCC_OscConfig+0x106>
 8001fe6:	bf00      	nop
 8001fe8:	40023800 	.word	0x40023800
 8001fec:	40007000 	.word	0x40007000
 8001ff0:	40023870 	.word	0x40023870
 8001ff4:	40023802 	.word	0x40023802
 8001ff8:	42470000 	.word	0x42470000
 8001ffc:	42470e80 	.word	0x42470e80
 8002000:	42470060 	.word	0x42470060
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002004:	f7fe f94e 	bl	80002a4 <HAL_GetTick>
 8002008:	1bc0      	subs	r0, r0, r7
 800200a:	2864      	cmp	r0, #100	; 0x64
 800200c:	d9b1      	bls.n	8001f72 <HAL_RCC_OscConfig+0x27e>
 800200e:	e6f4      	b.n	8001dfa <HAL_RCC_OscConfig+0x106>
        tickstart = HAL_GetTick();
 8002010:	f7fe f948 	bl	80002a4 <HAL_GetTick>
 8002014:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8002016:	682b      	ldr	r3, [r5, #0]
 8002018:	019b      	lsls	r3, r3, #6
 800201a:	f57f aeae 	bpl.w	8001d7a <HAL_RCC_OscConfig+0x86>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800201e:	f7fe f941 	bl	80002a4 <HAL_GetTick>
 8002022:	1b00      	subs	r0, r0, r4
 8002024:	2864      	cmp	r0, #100	; 0x64
 8002026:	d9f6      	bls.n	8002016 <HAL_RCC_OscConfig+0x322>
 8002028:	e6e7      	b.n	8001dfa <HAL_RCC_OscConfig+0x106>
 800202a:	bf00      	nop

0800202c <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 800202c:	4b69      	ldr	r3, [pc, #420]	; (80021d4 <HAL_RCC_ClockConfig+0x1a8>)
 800202e:	681a      	ldr	r2, [r3, #0]
 8002030:	f002 020f 	and.w	r2, r2, #15
 8002034:	428a      	cmp	r2, r1
{
 8002036:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800203a:	4604      	mov	r4, r0
 800203c:	460d      	mov	r5, r1
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 800203e:	d26b      	bcs.n	8002118 <HAL_RCC_ClockConfig+0xec>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002040:	b2ca      	uxtb	r2, r1
 8002042:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8002044:	681b      	ldr	r3, [r3, #0]
 8002046:	f003 030f 	and.w	r3, r3, #15
 800204a:	4299      	cmp	r1, r3
 800204c:	d002      	beq.n	8002054 <HAL_RCC_ClockConfig+0x28>
    {
      return HAL_ERROR;
 800204e:	2001      	movs	r0, #1
 8002050:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8002054:	6802      	ldr	r2, [r0, #0]
 8002056:	0796      	lsls	r6, r2, #30
 8002058:	d506      	bpl.n	8002068 <HAL_RCC_ClockConfig+0x3c>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800205a:	495f      	ldr	r1, [pc, #380]	; (80021d8 <HAL_RCC_ClockConfig+0x1ac>)
 800205c:	6880      	ldr	r0, [r0, #8]
 800205e:	688b      	ldr	r3, [r1, #8]
 8002060:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002064:	4303      	orrs	r3, r0
 8002066:	608b      	str	r3, [r1, #8]
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/ 
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8002068:	07d5      	lsls	r5, r2, #31
 800206a:	d413      	bmi.n	8002094 <HAL_RCC_ClockConfig+0x68>
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800206c:	6822      	ldr	r2, [r4, #0]
 800206e:	0750      	lsls	r0, r2, #29
 8002070:	f100 80a8 	bmi.w	80021c4 <HAL_RCC_ClockConfig+0x198>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002074:	0713      	lsls	r3, r2, #28
 8002076:	d507      	bpl.n	8002088 <HAL_RCC_ClockConfig+0x5c>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8002078:	4a57      	ldr	r2, [pc, #348]	; (80021d8 <HAL_RCC_ClockConfig+0x1ac>)
 800207a:	6921      	ldr	r1, [r4, #16]
 800207c:	6893      	ldr	r3, [r2, #8]
 800207e:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8002082:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8002086:	6093      	str	r3, [r2, #8]
  }

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8002088:	200f      	movs	r0, #15
 800208a:	f7fe f8d6 	bl	800023a <HAL_InitTick>
  
  return HAL_OK;
 800208e:	2000      	movs	r0, #0
}
 8002090:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002094:	6861      	ldr	r1, [r4, #4]
 8002096:	4b50      	ldr	r3, [pc, #320]	; (80021d8 <HAL_RCC_ClockConfig+0x1ac>)
 8002098:	2901      	cmp	r1, #1
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800209a:	681a      	ldr	r2, [r3, #0]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800209c:	d11d      	bne.n	80020da <HAL_RCC_ClockConfig+0xae>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800209e:	f412 3f00 	tst.w	r2, #131072	; 0x20000
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80020a2:	d0d4      	beq.n	800204e <HAL_RCC_ClockConfig+0x22>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 80020a4:	689a      	ldr	r2, [r3, #8]
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 80020a6:	4e4c      	ldr	r6, [pc, #304]	; (80021d8 <HAL_RCC_ClockConfig+0x1ac>)
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 80020a8:	f022 0203 	bic.w	r2, r2, #3
 80020ac:	430a      	orrs	r2, r1
 80020ae:	609a      	str	r2, [r3, #8]
      tickstart = HAL_GetTick();
 80020b0:	f7fe f8f8 	bl	80002a4 <HAL_GetTick>
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80020b4:	6863      	ldr	r3, [r4, #4]
 80020b6:	2b01      	cmp	r3, #1
      tickstart = HAL_GetTick();
 80020b8:	4605      	mov	r5, r0
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80020ba:	f241 3788 	movw	r7, #5000	; 0x1388
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80020be:	d114      	bne.n	80020ea <HAL_RCC_ClockConfig+0xbe>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 80020c0:	68b3      	ldr	r3, [r6, #8]
 80020c2:	f003 030c 	and.w	r3, r3, #12
 80020c6:	2b04      	cmp	r3, #4
 80020c8:	d0d0      	beq.n	800206c <HAL_RCC_ClockConfig+0x40>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80020ca:	f7fe f8eb 	bl	80002a4 <HAL_GetTick>
 80020ce:	1b40      	subs	r0, r0, r5
 80020d0:	42b8      	cmp	r0, r7
 80020d2:	d9f5      	bls.n	80020c0 <HAL_RCC_ClockConfig+0x94>
            return HAL_TIMEOUT;
 80020d4:	2003      	movs	r0, #3
 80020d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80020da:	2902      	cmp	r1, #2
 80020dc:	d102      	bne.n	80020e4 <HAL_RCC_ClockConfig+0xb8>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80020de:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 80020e2:	e7de      	b.n	80020a2 <HAL_RCC_ClockConfig+0x76>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80020e4:	f012 0f02 	tst.w	r2, #2
 80020e8:	e7db      	b.n	80020a2 <HAL_RCC_ClockConfig+0x76>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80020ea:	2b02      	cmp	r3, #2
 80020ec:	d10f      	bne.n	800210e <HAL_RCC_ClockConfig+0xe2>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80020ee:	68b3      	ldr	r3, [r6, #8]
 80020f0:	f003 030c 	and.w	r3, r3, #12
 80020f4:	2b08      	cmp	r3, #8
 80020f6:	d0b9      	beq.n	800206c <HAL_RCC_ClockConfig+0x40>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80020f8:	f7fe f8d4 	bl	80002a4 <HAL_GetTick>
 80020fc:	1b40      	subs	r0, r0, r5
 80020fe:	42b8      	cmp	r0, r7
 8002100:	d9f5      	bls.n	80020ee <HAL_RCC_ClockConfig+0xc2>
 8002102:	e7e7      	b.n	80020d4 <HAL_RCC_ClockConfig+0xa8>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002104:	f7fe f8ce 	bl	80002a4 <HAL_GetTick>
 8002108:	1b40      	subs	r0, r0, r5
 800210a:	42b8      	cmp	r0, r7
 800210c:	d8e2      	bhi.n	80020d4 <HAL_RCC_ClockConfig+0xa8>
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 800210e:	68b3      	ldr	r3, [r6, #8]
 8002110:	f013 0f0c 	tst.w	r3, #12
 8002114:	d1f6      	bne.n	8002104 <HAL_RCC_ClockConfig+0xd8>
 8002116:	e7a9      	b.n	800206c <HAL_RCC_ClockConfig+0x40>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8002118:	6802      	ldr	r2, [r0, #0]
 800211a:	0791      	lsls	r1, r2, #30
 800211c:	d506      	bpl.n	800212c <HAL_RCC_ClockConfig+0x100>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800211e:	492e      	ldr	r1, [pc, #184]	; (80021d8 <HAL_RCC_ClockConfig+0x1ac>)
 8002120:	6880      	ldr	r0, [r0, #8]
 8002122:	688b      	ldr	r3, [r1, #8]
 8002124:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002128:	4303      	orrs	r3, r0
 800212a:	608b      	str	r3, [r1, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800212c:	07d2      	lsls	r2, r2, #31
 800212e:	d408      	bmi.n	8002142 <HAL_RCC_ClockConfig+0x116>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002130:	4b28      	ldr	r3, [pc, #160]	; (80021d4 <HAL_RCC_ClockConfig+0x1a8>)
 8002132:	b2ea      	uxtb	r2, r5
 8002134:	701a      	strb	r2, [r3, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8002136:	681b      	ldr	r3, [r3, #0]
 8002138:	f003 030f 	and.w	r3, r3, #15
 800213c:	429d      	cmp	r5, r3
 800213e:	d186      	bne.n	800204e <HAL_RCC_ClockConfig+0x22>
 8002140:	e794      	b.n	800206c <HAL_RCC_ClockConfig+0x40>
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002142:	6861      	ldr	r1, [r4, #4]
 8002144:	4b24      	ldr	r3, [pc, #144]	; (80021d8 <HAL_RCC_ClockConfig+0x1ac>)
 8002146:	2901      	cmp	r1, #1
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002148:	681a      	ldr	r2, [r3, #0]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800214a:	d11c      	bne.n	8002186 <HAL_RCC_ClockConfig+0x15a>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800214c:	f412 3f00 	tst.w	r2, #131072	; 0x20000
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002150:	f43f af7d 	beq.w	800204e <HAL_RCC_ClockConfig+0x22>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8002154:	689a      	ldr	r2, [r3, #8]
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 8002156:	4f20      	ldr	r7, [pc, #128]	; (80021d8 <HAL_RCC_ClockConfig+0x1ac>)
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8002158:	f022 0203 	bic.w	r2, r2, #3
 800215c:	430a      	orrs	r2, r1
 800215e:	609a      	str	r2, [r3, #8]
      tickstart = HAL_GetTick();
 8002160:	f7fe f8a0 	bl	80002a4 <HAL_GetTick>
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002164:	6863      	ldr	r3, [r4, #4]
 8002166:	2b01      	cmp	r3, #1
      tickstart = HAL_GetTick();
 8002168:	4606      	mov	r6, r0
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800216a:	f241 3888 	movw	r8, #5000	; 0x1388
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800216e:	d112      	bne.n	8002196 <HAL_RCC_ClockConfig+0x16a>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 8002170:	68bb      	ldr	r3, [r7, #8]
 8002172:	f003 030c 	and.w	r3, r3, #12
 8002176:	2b04      	cmp	r3, #4
 8002178:	d0da      	beq.n	8002130 <HAL_RCC_ClockConfig+0x104>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800217a:	f7fe f893 	bl	80002a4 <HAL_GetTick>
 800217e:	1b80      	subs	r0, r0, r6
 8002180:	4540      	cmp	r0, r8
 8002182:	d9f5      	bls.n	8002170 <HAL_RCC_ClockConfig+0x144>
 8002184:	e7a6      	b.n	80020d4 <HAL_RCC_ClockConfig+0xa8>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8002186:	2902      	cmp	r1, #2
 8002188:	d102      	bne.n	8002190 <HAL_RCC_ClockConfig+0x164>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800218a:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 800218e:	e7df      	b.n	8002150 <HAL_RCC_ClockConfig+0x124>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002190:	f012 0f02 	tst.w	r2, #2
 8002194:	e7dc      	b.n	8002150 <HAL_RCC_ClockConfig+0x124>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8002196:	2b02      	cmp	r3, #2
 8002198:	d10f      	bne.n	80021ba <HAL_RCC_ClockConfig+0x18e>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800219a:	68bb      	ldr	r3, [r7, #8]
 800219c:	f003 030c 	and.w	r3, r3, #12
 80021a0:	2b08      	cmp	r3, #8
 80021a2:	d0c5      	beq.n	8002130 <HAL_RCC_ClockConfig+0x104>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80021a4:	f7fe f87e 	bl	80002a4 <HAL_GetTick>
 80021a8:	1b80      	subs	r0, r0, r6
 80021aa:	4540      	cmp	r0, r8
 80021ac:	d9f5      	bls.n	800219a <HAL_RCC_ClockConfig+0x16e>
 80021ae:	e791      	b.n	80020d4 <HAL_RCC_ClockConfig+0xa8>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80021b0:	f7fe f878 	bl	80002a4 <HAL_GetTick>
 80021b4:	1b80      	subs	r0, r0, r6
 80021b6:	4540      	cmp	r0, r8
 80021b8:	d88c      	bhi.n	80020d4 <HAL_RCC_ClockConfig+0xa8>
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 80021ba:	68bb      	ldr	r3, [r7, #8]
 80021bc:	f013 0f0c 	tst.w	r3, #12
 80021c0:	d1f6      	bne.n	80021b0 <HAL_RCC_ClockConfig+0x184>
 80021c2:	e7b5      	b.n	8002130 <HAL_RCC_ClockConfig+0x104>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80021c4:	4904      	ldr	r1, [pc, #16]	; (80021d8 <HAL_RCC_ClockConfig+0x1ac>)
 80021c6:	68e0      	ldr	r0, [r4, #12]
 80021c8:	688b      	ldr	r3, [r1, #8]
 80021ca:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 80021ce:	4303      	orrs	r3, r0
 80021d0:	608b      	str	r3, [r1, #8]
 80021d2:	e74f      	b.n	8002074 <HAL_RCC_ClockConfig+0x48>
 80021d4:	40023c00 	.word	0x40023c00
 80021d8:	40023800 	.word	0x40023800

080021dc <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80021dc:	4a23      	ldr	r2, [pc, #140]	; (800226c <HAL_RCC_GetSysClockFreq+0x90>)
 80021de:	6893      	ldr	r3, [r2, #8]
 80021e0:	f003 030c 	and.w	r3, r3, #12
 80021e4:	2b04      	cmp	r3, #4
{
 80021e6:	b510      	push	{r4, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80021e8:	d003      	beq.n	80021f2 <HAL_RCC_GetSysClockFreq+0x16>
 80021ea:	2b08      	cmp	r3, #8
 80021ec:	d003      	beq.n	80021f6 <HAL_RCC_GetSysClockFreq+0x1a>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 80021ee:	4820      	ldr	r0, [pc, #128]	; (8002270 <HAL_RCC_GetSysClockFreq+0x94>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 80021f0:	bd10      	pop	{r4, pc}
      sysclockfreq = HSE_VALUE;
 80021f2:	4820      	ldr	r0, [pc, #128]	; (8002274 <HAL_RCC_GetSysClockFreq+0x98>)
 80021f4:	bd10      	pop	{r4, pc}
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80021f6:	6851      	ldr	r1, [r2, #4]
      if (__RCC_PLLSRC() != 0)
 80021f8:	6850      	ldr	r0, [r2, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80021fa:	f001 013f 	and.w	r1, r1, #63	; 0x3f
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80021fe:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8002202:	fa93 f3a3 	rbit	r3, r3
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002206:	fab3 f383 	clz	r3, r3
      if (__RCC_PLLSRC() != 0)
 800220a:	f400 0080 	and.w	r0, r0, #4194304	; 0x400000
 800220e:	b2db      	uxtb	r3, r3
 8002210:	fa30 f303 	lsrs.w	r3, r0, r3
 8002214:	f647 74c0 	movw	r4, #32704	; 0x7fc0
 8002218:	d01d      	beq.n	8002256 <HAL_RCC_GetSysClockFreq+0x7a>
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 800221a:	6850      	ldr	r0, [r2, #4]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800221c:	fa94 f3a4 	rbit	r3, r4
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002220:	fab3 f383 	clz	r3, r3
 8002224:	4020      	ands	r0, r4
 8002226:	b2db      	uxtb	r3, r3
 8002228:	fa20 f303 	lsr.w	r3, r0, r3
 800222c:	4811      	ldr	r0, [pc, #68]	; (8002274 <HAL_RCC_GetSysClockFreq+0x98>)
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 800222e:	fbb0 f0f1 	udiv	r0, r0, r1
 8002232:	4358      	muls	r0, r3
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 8002234:	4b0d      	ldr	r3, [pc, #52]	; (800226c <HAL_RCC_GetSysClockFreq+0x90>)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002236:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 800223a:	685b      	ldr	r3, [r3, #4]
 800223c:	fa92 f2a2 	rbit	r2, r2
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002240:	fab2 f282 	clz	r2, r2
 8002244:	b2d2      	uxtb	r2, r2
 8002246:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800224a:	40d3      	lsrs	r3, r2
 800224c:	3301      	adds	r3, #1
 800224e:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco/pllp;
 8002250:	fbb0 f0f3 	udiv	r0, r0, r3
 8002254:	bd10      	pop	{r4, pc}
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8002256:	6853      	ldr	r3, [r2, #4]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002258:	fa94 f0a4 	rbit	r0, r4
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800225c:	fab0 f080 	clz	r0, r0
 8002260:	b2c0      	uxtb	r0, r0
 8002262:	4023      	ands	r3, r4
 8002264:	40c3      	lsrs	r3, r0
 8002266:	4802      	ldr	r0, [pc, #8]	; (8002270 <HAL_RCC_GetSysClockFreq+0x94>)
 8002268:	e7e1      	b.n	800222e <HAL_RCC_GetSysClockFreq+0x52>
 800226a:	bf00      	nop
 800226c:	40023800 	.word	0x40023800
 8002270:	00f42400 	.word	0x00f42400
 8002274:	007a1200 	.word	0x007a1200

08002278 <HAL_RCC_GetHCLKFreq>:
  *         and updated within this function
  * @param  None
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8002278:	b508      	push	{r3, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 800227a:	f7ff ffaf 	bl	80021dc <HAL_RCC_GetSysClockFreq>
 800227e:	4b09      	ldr	r3, [pc, #36]	; (80022a4 <HAL_RCC_GetHCLKFreq+0x2c>)
 8002280:	689a      	ldr	r2, [r3, #8]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002282:	23f0      	movs	r3, #240	; 0xf0
 8002284:	fa93 f3a3 	rbit	r3, r3
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002288:	fab3 f383 	clz	r3, r3
 800228c:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8002290:	b2db      	uxtb	r3, r3
 8002292:	fa22 f303 	lsr.w	r3, r2, r3
 8002296:	4a04      	ldr	r2, [pc, #16]	; (80022a8 <HAL_RCC_GetHCLKFreq+0x30>)
 8002298:	5cd3      	ldrb	r3, [r2, r3]
 800229a:	40d8      	lsrs	r0, r3
 800229c:	4b03      	ldr	r3, [pc, #12]	; (80022ac <HAL_RCC_GetHCLKFreq+0x34>)
 800229e:	6018      	str	r0, [r3, #0]
  return SystemCoreClock;
}
 80022a0:	bd08      	pop	{r3, pc}
 80022a2:	bf00      	nop
 80022a4:	40023800 	.word	0x40023800
 80022a8:	08006478 	.word	0x08006478
 80022ac:	20000000 	.word	0x20000000

080022b0 <HAL_RCC_GetPCLK1Freq>:
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @param  None
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
 80022b0:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 80022b2:	f7ff ffe1 	bl	8002278 <HAL_RCC_GetHCLKFreq>
 80022b6:	4b08      	ldr	r3, [pc, #32]	; (80022d8 <HAL_RCC_GetPCLK1Freq+0x28>)
 80022b8:	689a      	ldr	r2, [r3, #8]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80022ba:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 80022be:	fa93 f3a3 	rbit	r3, r3
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80022c2:	fab3 f383 	clz	r3, r3
 80022c6:	f402 52e0 	and.w	r2, r2, #7168	; 0x1c00
 80022ca:	b2db      	uxtb	r3, r3
 80022cc:	fa22 f303 	lsr.w	r3, r2, r3
 80022d0:	4a02      	ldr	r2, [pc, #8]	; (80022dc <HAL_RCC_GetPCLK1Freq+0x2c>)
 80022d2:	5cd3      	ldrb	r3, [r2, r3]
}
 80022d4:	40d8      	lsrs	r0, r3
 80022d6:	bd08      	pop	{r3, pc}
 80022d8:	40023800 	.word	0x40023800
 80022dc:	08006478 	.word	0x08006478

080022e0 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) and RCC_BDCR register are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80022e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /*----------------------- SAI/I2S Configuration (PLLI2S) -------------------------*/
  
  /*----------------------- Common configuration SAI/I2S ---------------------------*/
  /* In Case of SAI or I2S Clock Configuration through PLLI2S, PLLI2SN division   
     factor is common parameters for both peripherals */ 
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) || 
 80022e2:	6803      	ldr	r3, [r0, #0]
 80022e4:	079a      	lsls	r2, r3, #30
{
 80022e6:	4604      	mov	r4, r0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) || 
 80022e8:	f040 80a6 	bne.w	8002438 <HAL_RCCEx_PeriphCLKConfig+0x158>
  /*----------------------- SAI/LTDC Configuration (PLLSAI) ------------------*/
  
  /*----------------------- Common configuration SAI/LTDC --------------------*/
  /* In Case of SAI or LTDC Clock Configuration through PLLSAI, PLLSAIN division
     factor is common parameters for both peripherals */ 
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == RCC_PERIPHCLK_SAI_PLLSAI) || 
 80022ec:	6823      	ldr	r3, [r4, #0]
 80022ee:	f013 0f0c 	tst.w	r3, #12
 80022f2:	d058      	beq.n	80023a6 <HAL_RCCEx_PeriphCLKConfig+0xc6>
  {
    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));
 
    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE(); 
 80022f4:	4d93      	ldr	r5, [pc, #588]	; (8002544 <HAL_RCCEx_PeriphCLKConfig+0x264>)
    /* Get tick */
    tickstart = HAL_GetTick();
    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 80022f6:	4e94      	ldr	r6, [pc, #592]	; (8002548 <HAL_RCCEx_PeriphCLKConfig+0x268>)
    __HAL_RCC_PLLSAI_DISABLE(); 
 80022f8:	2300      	movs	r3, #0
 80022fa:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 80022fc:	f7fd ffd2 	bl	80002a4 <HAL_GetTick>
 8002300:	4607      	mov	r7, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8002302:	6833      	ldr	r3, [r6, #0]
 8002304:	009b      	lsls	r3, r3, #2
 8002306:	f100 80f4 	bmi.w	80024f2 <HAL_RCCEx_PeriphCLKConfig+0x212>
    }
    
    /*---------------------------- SAI configuration -------------------------*/
    /* In Case of SAI Clock Configuration through PLLSAI, PLLSAIQ and PLLSAI_DIVQ must  
       be added only for SAI configuration */     
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == (RCC_PERIPHCLK_SAI_PLLSAI))
 800230a:	6821      	ldr	r1, [r4, #0]
 800230c:	074f      	lsls	r7, r1, #29
 800230e:	d51f      	bpl.n	8002350 <HAL_RCCEx_PeriphCLKConfig+0x70>
    {
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));
      
      /* Read PLLSAIR value from PLLSAICFGR register (this value is not need for SAI configuration) */
      tmpreg = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR));
 8002310:	f8d6 0088 	ldr.w	r0, [r6, #136]	; 0x88
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002314:	f04f 42e0 	mov.w	r2, #1879048192	; 0x70000000
 8002318:	fa92 f2a2 	rbit	r2, r2
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800231c:	fab2 f282 	clz	r2, r2
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg);
 8002320:	6963      	ldr	r3, [r4, #20]
 8002322:	6927      	ldr	r7, [r4, #16]
 8002324:	061b      	lsls	r3, r3, #24
      tmpreg = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR));
 8002326:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
 800232a:	b2d2      	uxtb	r2, r2
 800232c:	fa20 f202 	lsr.w	r2, r0, r2
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg);
 8002330:	ea43 1387 	orr.w	r3, r3, r7, lsl #6
 8002334:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 8002338:	f8c6 3088 	str.w	r3, [r6, #136]	; 0x88
      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */ 
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 800233c:	f8d6 308c 	ldr.w	r3, [r6, #140]	; 0x8c
 8002340:	6a22      	ldr	r2, [r4, #32]
 8002342:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 8002346:	3a01      	subs	r2, #1
 8002348:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800234c:	f8c6 308c 	str.w	r3, [r6, #140]	; 0x8c
    }
    
    /*---------------------------- LTDC configuration ------------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 8002350:	0708      	lsls	r0, r1, #28
 8002352:	d51e      	bpl.n	8002392 <HAL_RCCEx_PeriphCLKConfig+0xb2>
    {
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));
      
      /* Read PLLSAIR value from PLLSAICFGR register (this value is not need for SAI configuration) */
      tmpreg = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ));
 8002354:	497c      	ldr	r1, [pc, #496]	; (8002548 <HAL_RCCEx_PeriphCLKConfig+0x268>)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002356:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
 800235a:	f8d1 0088 	ldr.w	r0, [r1, #136]	; 0x88
 800235e:	fa92 f2a2 	rbit	r2, r2
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002362:	fab2 f282 	clz	r2, r2
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg, PeriphClkInit->PLLSAI.PLLSAIR);
 8002366:	69a3      	ldr	r3, [r4, #24]
 8002368:	6926      	ldr	r6, [r4, #16]
 800236a:	071b      	lsls	r3, r3, #28
      tmpreg = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ));
 800236c:	f000 6070 	and.w	r0, r0, #251658240	; 0xf000000
 8002370:	b2d2      	uxtb	r2, r2
 8002372:	fa20 f202 	lsr.w	r2, r0, r2
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg, PeriphClkInit->PLLSAI.PLLSAIR);
 8002376:	ea43 1386 	orr.w	r3, r3, r6, lsl #6
 800237a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800237e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */ 
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 8002382:	f8d1 308c 	ldr.w	r3, [r1, #140]	; 0x8c
 8002386:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8002388:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 800238c:	4313      	orrs	r3, r2
 800238e:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }    
    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
 8002392:	2301      	movs	r3, #1
 8002394:	602b      	str	r3, [r5, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8002396:	f7fd ff85 	bl	80002a4 <HAL_GetTick>
    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 800239a:	4d6b      	ldr	r5, [pc, #428]	; (8002548 <HAL_RCCEx_PeriphCLKConfig+0x268>)
    tickstart = HAL_GetTick();
 800239c:	4606      	mov	r6, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 800239e:	682b      	ldr	r3, [r5, #0]
 80023a0:	0099      	lsls	r1, r3, #2
 80023a2:	f140 80ad 	bpl.w	8002500 <HAL_RCCEx_PeriphCLKConfig+0x220>
    }  
  }

   
  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 80023a6:	6823      	ldr	r3, [r4, #0]
 80023a8:	069a      	lsls	r2, r3, #26
 80023aa:	d53b      	bpl.n	8002424 <HAL_RCCEx_PeriphCLKConfig+0x144>
  {
    /* Enable Power Clock*/
    __PWR_CLK_ENABLE();
 80023ac:	4a66      	ldr	r2, [pc, #408]	; (8002548 <HAL_RCCEx_PeriphCLKConfig+0x268>)
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 80023ae:	4d67      	ldr	r5, [pc, #412]	; (800254c <HAL_RCCEx_PeriphCLKConfig+0x26c>)
    __PWR_CLK_ENABLE();
 80023b0:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80023b2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80023b6:	6413      	str	r3, [r2, #64]	; 0x40
    PWR->CR |= PWR_CR_DBP;
 80023b8:	682b      	ldr	r3, [r5, #0]
 80023ba:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80023be:	602b      	str	r3, [r5, #0]
    
    /* Get tick */
    tickstart = HAL_GetTick();
 80023c0:	f7fd ff70 	bl	80002a4 <HAL_GetTick>
 80023c4:	4606      	mov	r6, r0
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 80023c6:	682b      	ldr	r3, [r5, #0]
 80023c8:	05da      	lsls	r2, r3, #23
 80023ca:	f140 80a0 	bpl.w	800250e <HAL_RCCEx_PeriphCLKConfig+0x22e>
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset the Backup domain only if the RTC Clock source selction is modified */ 
    if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 80023ce:	4b5e      	ldr	r3, [pc, #376]	; (8002548 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 80023d0:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80023d2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80023d4:	404a      	eors	r2, r1
 80023d6:	f412 7f40 	tst.w	r2, #768	; 0x300
 80023da:	d008      	beq.n	80023ee <HAL_RCCEx_PeriphCLKConfig+0x10e>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 80023dc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 80023de:	495c      	ldr	r1, [pc, #368]	; (8002550 <HAL_RCCEx_PeriphCLKConfig+0x270>)
 80023e0:	2001      	movs	r0, #1
 80023e2:	6008      	str	r0, [r1, #0]
      tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 80023e4:	f422 7240 	bic.w	r2, r2, #768	; 0x300
      __HAL_RCC_BACKUPRESET_RELEASE();
 80023e8:	2000      	movs	r0, #0
 80023ea:	6008      	str	r0, [r1, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg;
 80023ec:	671a      	str	r2, [r3, #112]	; 0x70
    }
    
    /* If LSE is selected as RTC clock source, wait for LSE reactivation */
    if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
 80023ee:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80023f0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80023f4:	f000 8092 	beq.w	800251c <HAL_RCCEx_PeriphCLKConfig+0x23c>
        {
          return HAL_TIMEOUT;
        }      
      }  
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
 80023f8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80023fa:	f403 7240 	and.w	r2, r3, #768	; 0x300
 80023fe:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 8002402:	4a51      	ldr	r2, [pc, #324]	; (8002548 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 8002404:	f040 809a 	bne.w	800253c <HAL_RCCEx_PeriphCLKConfig+0x25c>
 8002408:	6891      	ldr	r1, [r2, #8]
 800240a:	f023 4070 	bic.w	r0, r3, #4026531840	; 0xf0000000
 800240e:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
 8002412:	f420 7040 	bic.w	r0, r0, #768	; 0x300
 8002416:	4301      	orrs	r1, r0
 8002418:	6091      	str	r1, [r2, #8]
 800241a:	6f11      	ldr	r1, [r2, #112]	; 0x70
 800241c:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8002420:	430b      	orrs	r3, r1
 8002422:	6713      	str	r3, [r2, #112]	; 0x70
  }
  
  /*---------------------------- TIM configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 8002424:	6820      	ldr	r0, [r4, #0]
 8002426:	f010 0010 	ands.w	r0, r0, #16
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 800242a:	bf1f      	itttt	ne
 800242c:	4b49      	ldrne	r3, [pc, #292]	; (8002554 <HAL_RCCEx_PeriphCLKConfig+0x274>)
 800242e:	f894 202c 	ldrbne.w	r2, [r4, #44]	; 0x2c
 8002432:	601a      	strne	r2, [r3, #0]
  }
  return HAL_OK;
 8002434:	2000      	movne	r0, #0
}
 8002436:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_RCC_PLLI2S_DISABLE();    
 8002438:	4d47      	ldr	r5, [pc, #284]	; (8002558 <HAL_RCCEx_PeriphCLKConfig+0x278>)
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 800243a:	4e43      	ldr	r6, [pc, #268]	; (8002548 <HAL_RCCEx_PeriphCLKConfig+0x268>)
    __HAL_RCC_PLLI2S_DISABLE();    
 800243c:	2300      	movs	r3, #0
 800243e:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 8002440:	f7fd ff30 	bl	80002a4 <HAL_GetTick>
 8002444:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8002446:	6833      	ldr	r3, [r6, #0]
 8002448:	011b      	lsls	r3, r3, #4
 800244a:	d44b      	bmi.n	80024e4 <HAL_RCCEx_PeriphCLKConfig+0x204>
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 800244c:	6820      	ldr	r0, [r4, #0]
 800244e:	07c7      	lsls	r7, r0, #31
 8002450:	d516      	bpl.n	8002480 <HAL_RCCEx_PeriphCLKConfig+0x1a0>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002452:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8002456:	fa92 f2a2 	rbit	r2, r2
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800245a:	fab2 f282 	clz	r2, r2
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800245e:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
 8002462:	fa93 f3a3 	rbit	r3, r3
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002466:	fab3 f383 	clz	r3, r3
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 800246a:	6861      	ldr	r1, [r4, #4]
 800246c:	b2d2      	uxtb	r2, r2
 800246e:	fa01 f202 	lsl.w	r2, r1, r2
 8002472:	68a1      	ldr	r1, [r4, #8]
 8002474:	b2db      	uxtb	r3, r3
 8002476:	fa01 f303 	lsl.w	r3, r1, r3
 800247a:	431a      	orrs	r2, r3
 800247c:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLI2S) == (RCC_PERIPHCLK_SAI_PLLI2S))
 8002480:	0780      	lsls	r0, r0, #30
 8002482:	d51f      	bpl.n	80024c4 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
      tmpreg = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR));
 8002484:	4930      	ldr	r1, [pc, #192]	; (8002548 <HAL_RCCEx_PeriphCLKConfig+0x268>)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002486:	f04f 42e0 	mov.w	r2, #1879048192	; 0x70000000
 800248a:	f8d1 0084 	ldr.w	r0, [r1, #132]	; 0x84
 800248e:	fa92 f2a2 	rbit	r2, r2
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002492:	fab2 f282 	clz	r2, r2
      __HAL_RCC_PLLI2S_SAICLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SQ , tmpreg);
 8002496:	68e3      	ldr	r3, [r4, #12]
 8002498:	6866      	ldr	r6, [r4, #4]
 800249a:	061b      	lsls	r3, r3, #24
      tmpreg = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR));
 800249c:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
 80024a0:	b2d2      	uxtb	r2, r2
 80024a2:	fa20 f202 	lsr.w	r2, r0, r2
      __HAL_RCC_PLLI2S_SAICLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SQ , tmpreg);
 80024a6:	ea43 1386 	orr.w	r3, r3, r6, lsl #6
 80024aa:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 80024ae:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 80024b2:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
 80024b6:	69e3      	ldr	r3, [r4, #28]
 80024b8:	f022 021f 	bic.w	r2, r2, #31
 80024bc:	3b01      	subs	r3, #1
 80024be:	4313      	orrs	r3, r2
 80024c0:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    __HAL_RCC_PLLI2S_ENABLE();
 80024c4:	2301      	movs	r3, #1
 80024c6:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 80024c8:	f7fd feec 	bl	80002a4 <HAL_GetTick>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80024cc:	4d1e      	ldr	r5, [pc, #120]	; (8002548 <HAL_RCCEx_PeriphCLKConfig+0x268>)
    tickstart = HAL_GetTick();
 80024ce:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80024d0:	682b      	ldr	r3, [r5, #0]
 80024d2:	0119      	lsls	r1, r3, #4
 80024d4:	f53f af0a 	bmi.w	80022ec <HAL_RCCEx_PeriphCLKConfig+0xc>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 80024d8:	f7fd fee4 	bl	80002a4 <HAL_GetTick>
 80024dc:	1b80      	subs	r0, r0, r6
 80024de:	2864      	cmp	r0, #100	; 0x64
 80024e0:	d9f6      	bls.n	80024d0 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
 80024e2:	e004      	b.n	80024ee <HAL_RCCEx_PeriphCLKConfig+0x20e>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 80024e4:	f7fd fede 	bl	80002a4 <HAL_GetTick>
 80024e8:	1bc0      	subs	r0, r0, r7
 80024ea:	2864      	cmp	r0, #100	; 0x64
 80024ec:	d9ab      	bls.n	8002446 <HAL_RCCEx_PeriphCLKConfig+0x166>
        return HAL_TIMEOUT;
 80024ee:	2003      	movs	r0, #3
 80024f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
 80024f2:	f7fd fed7 	bl	80002a4 <HAL_GetTick>
 80024f6:	1bc0      	subs	r0, r0, r7
 80024f8:	2864      	cmp	r0, #100	; 0x64
 80024fa:	f67f af02 	bls.w	8002302 <HAL_RCCEx_PeriphCLKConfig+0x22>
 80024fe:	e7f6      	b.n	80024ee <HAL_RCCEx_PeriphCLKConfig+0x20e>
      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
 8002500:	f7fd fed0 	bl	80002a4 <HAL_GetTick>
 8002504:	1b80      	subs	r0, r0, r6
 8002506:	2864      	cmp	r0, #100	; 0x64
 8002508:	f67f af49 	bls.w	800239e <HAL_RCCEx_PeriphCLKConfig+0xbe>
 800250c:	e7ef      	b.n	80024ee <HAL_RCCEx_PeriphCLKConfig+0x20e>
      if((HAL_GetTick() - tickstart ) > DBP_TIMEOUT_VALUE)
 800250e:	f7fd fec9 	bl	80002a4 <HAL_GetTick>
 8002512:	1b80      	subs	r0, r0, r6
 8002514:	2864      	cmp	r0, #100	; 0x64
 8002516:	f67f af56 	bls.w	80023c6 <HAL_RCCEx_PeriphCLKConfig+0xe6>
 800251a:	e7e8      	b.n	80024ee <HAL_RCCEx_PeriphCLKConfig+0x20e>
      tickstart = HAL_GetTick();
 800251c:	f7fd fec2 	bl	80002a4 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002520:	4d09      	ldr	r5, [pc, #36]	; (8002548 <HAL_RCCEx_PeriphCLKConfig+0x268>)
      tickstart = HAL_GetTick();
 8002522:	4606      	mov	r6, r0
        if((HAL_GetTick() - tickstart ) > LSE_TIMEOUT_VALUE)
 8002524:	f241 3788 	movw	r7, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002528:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800252a:	079b      	lsls	r3, r3, #30
 800252c:	f53f af64 	bmi.w	80023f8 <HAL_RCCEx_PeriphCLKConfig+0x118>
        if((HAL_GetTick() - tickstart ) > LSE_TIMEOUT_VALUE)
 8002530:	f7fd feb8 	bl	80002a4 <HAL_GetTick>
 8002534:	1b80      	subs	r0, r0, r6
 8002536:	42b8      	cmp	r0, r7
 8002538:	d9f6      	bls.n	8002528 <HAL_RCCEx_PeriphCLKConfig+0x248>
 800253a:	e7d8      	b.n	80024ee <HAL_RCCEx_PeriphCLKConfig+0x20e>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
 800253c:	6891      	ldr	r1, [r2, #8]
 800253e:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
 8002542:	e769      	b.n	8002418 <HAL_RCCEx_PeriphCLKConfig+0x138>
 8002544:	42470070 	.word	0x42470070
 8002548:	40023800 	.word	0x40023800
 800254c:	40007000 	.word	0x40007000
 8002550:	42470e40 	.word	0x42470e40
 8002554:	424711e0 	.word	0x424711e0
 8002558:	42470068 	.word	0x42470068

0800255c <HAL_SDRAM_MspInit>:
 800255c:	4770      	bx	lr

0800255e <HAL_SDRAM_Init>:
  *                the configuration information for SDRAM module.
  * @param  Timing: Pointer to SDRAM control timing structure 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{   
 800255e:	b538      	push	{r3, r4, r5, lr}
 8002560:	460d      	mov	r5, r1
  /* Check the SDRAM handle parameter */
  if(hsdram == NULL)
 8002562:	4604      	mov	r4, r0
 8002564:	b1a8      	cbz	r0, 8002592 <HAL_SDRAM_Init+0x34>
  {
    return HAL_ERROR;
  }
  
  if(hsdram->State == HAL_SDRAM_STATE_RESET)
 8002566:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 800256a:	b90b      	cbnz	r3, 8002570 <HAL_SDRAM_Init+0x12>
  {  
    /* Initialize the low level hardware (MSP) */
    HAL_SDRAM_MspInit(hsdram);
 800256c:	f7ff fff6 	bl	800255c <HAL_SDRAM_MspInit>
  }
  
  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8002570:	2302      	movs	r3, #2
 8002572:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  
  /* Initialize SDRAM control Interface */
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 8002576:	1d21      	adds	r1, r4, #4
 8002578:	6820      	ldr	r0, [r4, #0]
 800257a:	f000 fbb2 	bl	8002ce2 <FMC_SDRAM_Init>
  
  /* Initialize SDRAM timing Interface */
  FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
 800257e:	6862      	ldr	r2, [r4, #4]
 8002580:	6820      	ldr	r0, [r4, #0]
 8002582:	4629      	mov	r1, r5
 8002584:	f000 fbd4 	bl	8002d30 <FMC_SDRAM_Timing_Init>
  
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 8002588:	2301      	movs	r3, #1
 800258a:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  
  return HAL_OK;
 800258e:	2000      	movs	r0, #0
 8002590:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8002592:	2001      	movs	r0, #1
}
 8002594:	bd38      	pop	{r3, r4, r5, pc}

08002596 <HAL_SDRAM_SendCommand>:
  * @param  Command: SDRAM command structure
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */  
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 8002596:	b538      	push	{r3, r4, r5, lr}
 8002598:	4604      	mov	r4, r0
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 800259a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800259e:	b2c0      	uxtb	r0, r0
 80025a0:	2802      	cmp	r0, #2
{
 80025a2:	460d      	mov	r5, r1
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 80025a4:	d00d      	beq.n	80025c2 <HAL_SDRAM_SendCommand+0x2c>
  {
    return HAL_BUSY;
  }
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 80025a6:	2302      	movs	r3, #2
 80025a8:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  
  /* Send SDRAM command */
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 80025ac:	6820      	ldr	r0, [r4, #0]
 80025ae:	f000 fbf5 	bl	8002d9c <FMC_SDRAM_SendCommand>
  
  /* Update the SDRAM controller state state */
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
 80025b2:	682b      	ldr	r3, [r5, #0]
 80025b4:	2b02      	cmp	r3, #2
  {
    hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 80025b6:	bf0c      	ite	eq
 80025b8:	2305      	moveq	r3, #5
  }
  else
  {
    hsdram->State = HAL_SDRAM_STATE_READY;
 80025ba:	2301      	movne	r3, #1
 80025bc:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  }
  
  return HAL_OK;  
 80025c0:	2000      	movs	r0, #0
}
 80025c2:	bd38      	pop	{r3, r4, r5, pc}

080025c4 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.  
  * @param  RefreshRate: The SDRAM refresh rate value       
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
 80025c4:	b510      	push	{r4, lr}
 80025c6:	4604      	mov	r4, r0
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 80025c8:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 80025cc:	b2c0      	uxtb	r0, r0
 80025ce:	2802      	cmp	r0, #2
 80025d0:	d009      	beq.n	80025e6 <HAL_SDRAM_ProgramRefreshRate+0x22>
  {
    return HAL_BUSY;
  } 
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 80025d2:	2302      	movs	r3, #2
 80025d4:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  
  /* Program the refresh rate */
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
 80025d8:	6820      	ldr	r0, [r4, #0]
 80025da:	f000 fc05 	bl	8002de8 <FMC_SDRAM_ProgramRefreshRate>
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 80025de:	2301      	movs	r3, #1
 80025e0:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  
  return HAL_OK;   
 80025e4:	2000      	movs	r0, #0
}
 80025e6:	bd10      	pop	{r4, pc}

080025e8 <SPI_WaitOnFlagUntilTimeout>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitOnFlagUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus Status, uint32_t Timeout)  
{
 80025e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80025ec:	4604      	mov	r4, r0
 80025ee:	460e      	mov	r6, r1
 80025f0:	4690      	mov	r8, r2
 80025f2:	461d      	mov	r5, r3
  uint32_t tickstart = 0;

  /* Get tick */ 
  tickstart = HAL_GetTick();
 80025f4:	f7fd fe56 	bl	80002a4 <HAL_GetTick>
 80025f8:	4607      	mov	r7, r0

  /* Wait until flag is set */
  if(Status == RESET)
 80025fa:	f1b8 0f00 	cmp.w	r8, #0
 80025fe:	d033      	beq.n	8002668 <SPI_WaitOnFlagUntilTimeout+0x80>
      }
    }
  }
  else
  {
    while(__HAL_SPI_GET_FLAG(hspi, Flag) != RESET)
 8002600:	6822      	ldr	r2, [r4, #0]
 8002602:	6893      	ldr	r3, [r2, #8]
 8002604:	ea36 0303 	bics.w	r3, r6, r3
 8002608:	d133      	bne.n	8002672 <SPI_WaitOnFlagUntilTimeout+0x8a>
    {
      if(Timeout != HAL_MAX_DELAY)
 800260a:	1c6b      	adds	r3, r5, #1
 800260c:	d0f9      	beq.n	8002602 <SPI_WaitOnFlagUntilTimeout+0x1a>
      {
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 800260e:	b145      	cbz	r5, 8002622 <SPI_WaitOnFlagUntilTimeout+0x3a>
 8002610:	f7fd fe48 	bl	80002a4 <HAL_GetTick>
 8002614:	1bc0      	subs	r0, r0, r7
 8002616:	4285      	cmp	r5, r0
 8002618:	d2f2      	bcs.n	8002600 <SPI_WaitOnFlagUntilTimeout+0x18>
 800261a:	e002      	b.n	8002622 <SPI_WaitOnFlagUntilTimeout+0x3a>
      if(Timeout != HAL_MAX_DELAY)
 800261c:	1c69      	adds	r1, r5, #1
 800261e:	d024      	beq.n	800266a <SPI_WaitOnFlagUntilTimeout+0x82>
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8002620:	b9ed      	cbnz	r5, 800265e <SPI_WaitOnFlagUntilTimeout+0x76>
          /* Disable the SPI and reset the CRC: the CRC value should be cleared
             on both master and slave sides in order to resynchronize the master
             and slave for their respective CRC calculation */

          /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
          __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8002622:	6823      	ldr	r3, [r4, #0]
 8002624:	685a      	ldr	r2, [r3, #4]
 8002626:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 800262a:	605a      	str	r2, [r3, #4]

          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 800262c:	681a      	ldr	r2, [r3, #0]
 800262e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002632:	601a      	str	r2, [r3, #0]

          /* Reset CRC Calculation */
          if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
 8002634:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8002636:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 800263a:	d107      	bne.n	800264c <SPI_WaitOnFlagUntilTimeout+0x64>
          {
            __HAL_SPI_RESET_CRC(hspi);
 800263c:	681a      	ldr	r2, [r3, #0]
 800263e:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8002642:	601a      	str	r2, [r3, #0]
 8002644:	681a      	ldr	r2, [r3, #0]
 8002646:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800264a:	601a      	str	r2, [r3, #0]
          }

          hspi->State= HAL_SPI_STATE_READY;
 800264c:	2301      	movs	r3, #1
 800264e:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51

          /* Process Unlocked */
          __HAL_UNLOCK(hspi);
 8002652:	2300      	movs	r3, #0
 8002654:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50

          return HAL_TIMEOUT;
 8002658:	2003      	movs	r0, #3
 800265a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 800265e:	f7fd fe21 	bl	80002a4 <HAL_GetTick>
 8002662:	1bc0      	subs	r0, r0, r7
 8002664:	4285      	cmp	r5, r0
 8002666:	d3dc      	bcc.n	8002622 <SPI_WaitOnFlagUntilTimeout+0x3a>
    while(__HAL_SPI_GET_FLAG(hspi, Flag) == RESET)
 8002668:	6822      	ldr	r2, [r4, #0]
 800266a:	6893      	ldr	r3, [r2, #8]
 800266c:	ea36 0303 	bics.w	r3, r6, r3
 8002670:	d1d4      	bne.n	800261c <SPI_WaitOnFlagUntilTimeout+0x34>
        }
      }
    }
  }
  return HAL_OK;
 8002672:	2000      	movs	r0, #0
 8002674:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08002678 <HAL_SPI_MspInit>:
 8002678:	4770      	bx	lr

0800267a <HAL_SPI_Init>:
{
 800267a:	b510      	push	{r4, lr}
  if(hspi == NULL)
 800267c:	4604      	mov	r4, r0
 800267e:	2800      	cmp	r0, #0
 8002680:	d033      	beq.n	80026ea <HAL_SPI_Init+0x70>
  if(hspi->State == HAL_SPI_STATE_RESET)
 8002682:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
 8002686:	b90b      	cbnz	r3, 800268c <HAL_SPI_Init+0x12>
    HAL_SPI_MspInit(hspi);
 8002688:	f7ff fff6 	bl	8002678 <HAL_SPI_MspInit>
  __HAL_SPI_DISABLE(hspi);
 800268c:	6821      	ldr	r1, [r4, #0]
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 800268e:	68a0      	ldr	r0, [r4, #8]
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
 8002690:	69a2      	ldr	r2, [r4, #24]
  hspi->State = HAL_SPI_STATE_BUSY;
 8002692:	2302      	movs	r3, #2
 8002694:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  __HAL_SPI_DISABLE(hspi);
 8002698:	680b      	ldr	r3, [r1, #0]
 800269a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800269e:	600b      	str	r3, [r1, #0]
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 80026a0:	6863      	ldr	r3, [r4, #4]
 80026a2:	4303      	orrs	r3, r0
 80026a4:	68e0      	ldr	r0, [r4, #12]
 80026a6:	4303      	orrs	r3, r0
 80026a8:	6920      	ldr	r0, [r4, #16]
 80026aa:	4303      	orrs	r3, r0
 80026ac:	6960      	ldr	r0, [r4, #20]
 80026ae:	4303      	orrs	r3, r0
 80026b0:	69e0      	ldr	r0, [r4, #28]
 80026b2:	4303      	orrs	r3, r0
 80026b4:	6a20      	ldr	r0, [r4, #32]
 80026b6:	4303      	orrs	r3, r0
 80026b8:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80026ba:	4303      	orrs	r3, r0
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
 80026bc:	f402 7000 	and.w	r0, r2, #512	; 0x200
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 80026c0:	4303      	orrs	r3, r0
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80026c2:	600b      	str	r3, [r1, #0]
  hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode);
 80026c4:	0c12      	lsrs	r2, r2, #16
 80026c6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80026c8:	f002 0204 	and.w	r2, r2, #4
 80026cc:	431a      	orrs	r2, r3
  hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;
 80026ce:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode);
 80026d0:	604a      	str	r2, [r1, #4]
  hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;
 80026d2:	610b      	str	r3, [r1, #16]
  hspi->Instance->I2SCFGR &= (uint32_t)(~SPI_I2SCFGR_I2SMOD);
 80026d4:	69cb      	ldr	r3, [r1, #28]
 80026d6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80026da:	61cb      	str	r3, [r1, #28]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80026dc:	2000      	movs	r0, #0
  hspi->State = HAL_SPI_STATE_READY;
 80026de:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80026e0:	f884 0052 	strb.w	r0, [r4, #82]	; 0x52
  hspi->State = HAL_SPI_STATE_READY;
 80026e4:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  return HAL_OK;
 80026e8:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 80026ea:	2001      	movs	r0, #1
}
 80026ec:	bd10      	pop	{r4, pc}

080026ee <HAL_SPI_MspDeInit>:
 80026ee:	4770      	bx	lr

080026f0 <HAL_SPI_DeInit>:
{
 80026f0:	b510      	push	{r4, lr}
  if(hspi == NULL)
 80026f2:	4604      	mov	r4, r0
 80026f4:	b170      	cbz	r0, 8002714 <HAL_SPI_DeInit+0x24>
  __HAL_SPI_DISABLE(hspi);
 80026f6:	6802      	ldr	r2, [r0, #0]
 80026f8:	6813      	ldr	r3, [r2, #0]
 80026fa:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80026fe:	6013      	str	r3, [r2, #0]
  HAL_SPI_MspDeInit(hspi);
 8002700:	f7ff fff5 	bl	80026ee <HAL_SPI_MspDeInit>
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8002704:	2000      	movs	r0, #0
 8002706:	f884 0052 	strb.w	r0, [r4, #82]	; 0x52
  __HAL_UNLOCK(hspi);
 800270a:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
  hspi->State = HAL_SPI_STATE_RESET;
 800270e:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
  return HAL_OK;
 8002712:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8002714:	2001      	movs	r0, #1
}
 8002716:	bd10      	pop	{r4, pc}

08002718 <HAL_SPI_Transmit>:
{
 8002718:	b570      	push	{r4, r5, r6, lr}
 800271a:	4604      	mov	r4, r0
  if(hspi->State == HAL_SPI_STATE_READY)
 800271c:	f890 0051 	ldrb.w	r0, [r0, #81]	; 0x51
 8002720:	b2c0      	uxtb	r0, r0
 8002722:	2801      	cmp	r0, #1
{
 8002724:	461d      	mov	r5, r3
  if(hspi->State == HAL_SPI_STATE_READY)
 8002726:	f040 80a2 	bne.w	800286e <HAL_SPI_Transmit+0x156>
    if((pData == NULL ) || (Size == 0)) 
 800272a:	2900      	cmp	r1, #0
 800272c:	f000 80a0 	beq.w	8002870 <HAL_SPI_Transmit+0x158>
 8002730:	2a00      	cmp	r2, #0
 8002732:	f000 809d 	beq.w	8002870 <HAL_SPI_Transmit+0x158>
    __HAL_LOCK(hspi);
 8002736:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
 800273a:	2b01      	cmp	r3, #1
 800273c:	f000 8097 	beq.w	800286e <HAL_SPI_Transmit+0x156>
    hspi->State = HAL_SPI_STATE_BUSY_TX;
 8002740:	2312      	movs	r3, #18
 8002742:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
    hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002746:	2300      	movs	r3, #0
 8002748:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
    hspi->TxISR = 0;
 800274c:	64e3      	str	r3, [r4, #76]	; 0x4c
    hspi->RxISR = 0;
 800274e:	64a3      	str	r3, [r4, #72]	; 0x48
    hspi->RxXferSize   = 0;
 8002750:	87a3      	strh	r3, [r4, #60]	; 0x3c
    hspi->RxXferCount  = 0;
 8002752:	87e3      	strh	r3, [r4, #62]	; 0x3e
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
 8002754:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    __HAL_LOCK(hspi);
 8002756:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
 800275a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    hspi->pTxBuffPtr = pData;
 800275e:	6321      	str	r1, [r4, #48]	; 0x30
    hspi->TxXferSize = Size;
 8002760:	86a2      	strh	r2, [r4, #52]	; 0x34
    hspi->TxXferCount = Size;
 8002762:	86e2      	strh	r2, [r4, #54]	; 0x36
 8002764:	6823      	ldr	r3, [r4, #0]
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
 8002766:	d107      	bne.n	8002778 <HAL_SPI_Transmit+0x60>
      __HAL_SPI_RESET_CRC(hspi);
 8002768:	6818      	ldr	r0, [r3, #0]
 800276a:	f420 5000 	bic.w	r0, r0, #8192	; 0x2000
 800276e:	6018      	str	r0, [r3, #0]
 8002770:	6818      	ldr	r0, [r3, #0]
 8002772:	f440 5000 	orr.w	r0, r0, #8192	; 0x2000
 8002776:	6018      	str	r0, [r3, #0]
    if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002778:	68a0      	ldr	r0, [r4, #8]
    if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
 800277a:	68e6      	ldr	r6, [r4, #12]
    if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800277c:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
      __HAL_SPI_1LINE_TX(hspi);
 8002780:	bf02      	ittt	eq
 8002782:	6818      	ldreq	r0, [r3, #0]
 8002784:	f440 4080 	orreq.w	r0, r0, #16384	; 0x4000
 8002788:	6018      	streq	r0, [r3, #0]
    if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 800278a:	6818      	ldr	r0, [r3, #0]
 800278c:	0640      	lsls	r0, r0, #25
      __HAL_SPI_ENABLE(hspi);
 800278e:	bf5e      	ittt	pl
 8002790:	6818      	ldrpl	r0, [r3, #0]
 8002792:	f040 0040 	orrpl.w	r0, r0, #64	; 0x40
 8002796:	6018      	strpl	r0, [r3, #0]
 8002798:	6860      	ldr	r0, [r4, #4]
    if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
 800279a:	2e00      	cmp	r6, #0
 800279c:	d135      	bne.n	800280a <HAL_SPI_Transmit+0xf2>
      if((hspi->Init.Mode == SPI_MODE_SLAVE)|| (hspi->TxXferCount == 0x01))
 800279e:	b108      	cbz	r0, 80027a4 <HAL_SPI_Transmit+0x8c>
 80027a0:	2a01      	cmp	r2, #1
 80027a2:	d105      	bne.n	80027b0 <HAL_SPI_Transmit+0x98>
        hspi->Instance->DR = (*hspi->pTxBuffPtr++);
 80027a4:	1c48      	adds	r0, r1, #1
 80027a6:	6320      	str	r0, [r4, #48]	; 0x30
 80027a8:	7809      	ldrb	r1, [r1, #0]
 80027aa:	60d9      	str	r1, [r3, #12]
        hspi->TxXferCount--;
 80027ac:	3a01      	subs	r2, #1
 80027ae:	86e2      	strh	r2, [r4, #54]	; 0x36
      while(hspi->TxXferCount > 0)
 80027b0:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80027b2:	b9bb      	cbnz	r3, 80027e4 <HAL_SPI_Transmit+0xcc>
      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED) 
 80027b4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80027b6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
        hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 80027ba:	bf01      	itttt	eq
 80027bc:	6822      	ldreq	r2, [r4, #0]
 80027be:	6813      	ldreq	r3, [r2, #0]
 80027c0:	f443 5380 	orreq.w	r3, r3, #4096	; 0x1000
 80027c4:	6013      	streq	r3, [r2, #0]
    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
 80027c6:	2102      	movs	r1, #2
 80027c8:	462b      	mov	r3, r5
 80027ca:	2200      	movs	r2, #0
 80027cc:	4620      	mov	r0, r4
 80027ce:	f7ff ff0b 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 80027d2:	2800      	cmp	r0, #0
 80027d4:	d037      	beq.n	8002846 <HAL_SPI_Transmit+0x12e>
      hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 80027d6:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 80027da:	f043 0320 	orr.w	r3, r3, #32
 80027de:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
 80027e2:	e006      	b.n	80027f2 <HAL_SPI_Transmit+0xda>
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
 80027e4:	462b      	mov	r3, r5
 80027e6:	2200      	movs	r2, #0
 80027e8:	2102      	movs	r1, #2
 80027ea:	4620      	mov	r0, r4
 80027ec:	f7ff fefc 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 80027f0:	b108      	cbz	r0, 80027f6 <HAL_SPI_Transmit+0xde>
      return HAL_TIMEOUT;
 80027f2:	2003      	movs	r0, #3
 80027f4:	bd70      	pop	{r4, r5, r6, pc}
        hspi->Instance->DR = (*hspi->pTxBuffPtr++);
 80027f6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80027f8:	6822      	ldr	r2, [r4, #0]
 80027fa:	1c59      	adds	r1, r3, #1
 80027fc:	6321      	str	r1, [r4, #48]	; 0x30
 80027fe:	781b      	ldrb	r3, [r3, #0]
 8002800:	60d3      	str	r3, [r2, #12]
        hspi->TxXferCount--;
 8002802:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002804:	3b01      	subs	r3, #1
 8002806:	86e3      	strh	r3, [r4, #54]	; 0x36
 8002808:	e7d2      	b.n	80027b0 <HAL_SPI_Transmit+0x98>
      if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01))
 800280a:	b108      	cbz	r0, 8002810 <HAL_SPI_Transmit+0xf8>
 800280c:	2a01      	cmp	r2, #1
 800280e:	d105      	bne.n	800281c <HAL_SPI_Transmit+0x104>
        hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 8002810:	f831 0b02 	ldrh.w	r0, [r1], #2
 8002814:	60d8      	str	r0, [r3, #12]
        hspi->TxXferCount--;
 8002816:	3a01      	subs	r2, #1
        hspi->pTxBuffPtr+=2;
 8002818:	6321      	str	r1, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 800281a:	86e2      	strh	r2, [r4, #54]	; 0x36
      while(hspi->TxXferCount > 0)
 800281c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800281e:	2b00      	cmp	r3, #0
 8002820:	d0c8      	beq.n	80027b4 <HAL_SPI_Transmit+0x9c>
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8002822:	462b      	mov	r3, r5
 8002824:	2200      	movs	r2, #0
 8002826:	2102      	movs	r1, #2
 8002828:	4620      	mov	r0, r4
 800282a:	f7ff fedd 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 800282e:	2800      	cmp	r0, #0
 8002830:	d1df      	bne.n	80027f2 <HAL_SPI_Transmit+0xda>
        hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 8002832:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002834:	6822      	ldr	r2, [r4, #0]
 8002836:	f833 1b02 	ldrh.w	r1, [r3], #2
 800283a:	60d1      	str	r1, [r2, #12]
        hspi->pTxBuffPtr+=2;
 800283c:	6323      	str	r3, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 800283e:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002840:	3b01      	subs	r3, #1
 8002842:	86e3      	strh	r3, [r4, #54]	; 0x36
 8002844:	e7ea      	b.n	800281c <HAL_SPI_Transmit+0x104>
    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, Timeout) != HAL_OK)
 8002846:	462b      	mov	r3, r5
 8002848:	2201      	movs	r2, #1
 800284a:	2180      	movs	r1, #128	; 0x80
 800284c:	4620      	mov	r0, r4
 800284e:	f7ff fecb 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 8002852:	2800      	cmp	r0, #0
 8002854:	d1bf      	bne.n	80027d6 <HAL_SPI_Transmit+0xbe>
    if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8002856:	68a3      	ldr	r3, [r4, #8]
 8002858:	b913      	cbnz	r3, 8002860 <HAL_SPI_Transmit+0x148>
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800285a:	6823      	ldr	r3, [r4, #0]
 800285c:	68da      	ldr	r2, [r3, #12]
 800285e:	689b      	ldr	r3, [r3, #8]
    hspi->State = HAL_SPI_STATE_READY; 
 8002860:	2301      	movs	r3, #1
 8002862:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
    __HAL_UNLOCK(hspi);
 8002866:	2300      	movs	r3, #0
 8002868:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    return HAL_OK;
 800286c:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
 800286e:	2002      	movs	r0, #2
}
 8002870:	bd70      	pop	{r4, r5, r6, pc}

08002872 <HAL_SPI_TransmitReceive>:
{
 8002872:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8002874:	4604      	mov	r4, r0
  tmpstate = hspi->State; 
 8002876:	f890 0051 	ldrb.w	r0, [r0, #81]	; 0x51
{
 800287a:	9d06      	ldr	r5, [sp, #24]
  tmpstate = hspi->State; 
 800287c:	b2c0      	uxtb	r0, r0
  if((tmpstate == HAL_SPI_STATE_READY) || (tmpstate == HAL_SPI_STATE_BUSY_RX))
 800287e:	2801      	cmp	r0, #1
 8002880:	d002      	beq.n	8002888 <HAL_SPI_TransmitReceive+0x16>
 8002882:	2822      	cmp	r0, #34	; 0x22
 8002884:	f040 8141 	bne.w	8002b0a <HAL_SPI_TransmitReceive+0x298>
    if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
 8002888:	2900      	cmp	r1, #0
 800288a:	f000 8138 	beq.w	8002afe <HAL_SPI_TransmitReceive+0x28c>
 800288e:	2a00      	cmp	r2, #0
 8002890:	f000 8135 	beq.w	8002afe <HAL_SPI_TransmitReceive+0x28c>
 8002894:	2b00      	cmp	r3, #0
 8002896:	f000 8132 	beq.w	8002afe <HAL_SPI_TransmitReceive+0x28c>
    __HAL_LOCK(hspi);
 800289a:	f894 0050 	ldrb.w	r0, [r4, #80]	; 0x50
 800289e:	2801      	cmp	r0, #1
 80028a0:	f000 8133 	beq.w	8002b0a <HAL_SPI_TransmitReceive+0x298>
 80028a4:	2001      	movs	r0, #1
 80028a6:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
    if(hspi->State == HAL_SPI_STATE_READY)
 80028aa:	f894 0051 	ldrb.w	r0, [r4, #81]	; 0x51
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
 80028ae:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    hspi->pRxBuffPtr  = pRxData;
 80028b0:	63a2      	str	r2, [r4, #56]	; 0x38
    if(hspi->State == HAL_SPI_STATE_READY)
 80028b2:	2801      	cmp	r0, #1
      hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 80028b4:	bf04      	itt	eq
 80028b6:	2032      	moveq	r0, #50	; 0x32
 80028b8:	f884 0051 	strbeq.w	r0, [r4, #81]	; 0x51
    hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80028bc:	2000      	movs	r0, #0
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
 80028be:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
    hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80028c2:	f884 0052 	strb.w	r0, [r4, #82]	; 0x52
    hspi->RxXferSize  = Size;
 80028c6:	87a3      	strh	r3, [r4, #60]	; 0x3c
    hspi->RxXferCount = Size;  
 80028c8:	87e3      	strh	r3, [r4, #62]	; 0x3e
    hspi->pTxBuffPtr  = pTxData;
 80028ca:	6321      	str	r1, [r4, #48]	; 0x30
    hspi->TxXferSize  = Size; 
 80028cc:	86a3      	strh	r3, [r4, #52]	; 0x34
    hspi->TxXferCount = Size;
 80028ce:	86e3      	strh	r3, [r4, #54]	; 0x36
    hspi->RxISR = 0;
 80028d0:	64a0      	str	r0, [r4, #72]	; 0x48
    hspi->TxISR = 0;
 80028d2:	64e0      	str	r0, [r4, #76]	; 0x4c
 80028d4:	6822      	ldr	r2, [r4, #0]
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
 80028d6:	d107      	bne.n	80028e8 <HAL_SPI_TransmitReceive+0x76>
      __HAL_SPI_RESET_CRC(hspi);
 80028d8:	6810      	ldr	r0, [r2, #0]
 80028da:	f420 5000 	bic.w	r0, r0, #8192	; 0x2000
 80028de:	6010      	str	r0, [r2, #0]
 80028e0:	6810      	ldr	r0, [r2, #0]
 80028e2:	f440 5000 	orr.w	r0, r0, #8192	; 0x2000
 80028e6:	6010      	str	r0, [r2, #0]
    if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 80028e8:	6810      	ldr	r0, [r2, #0]
 80028ea:	0640      	lsls	r0, r0, #25
      __HAL_SPI_ENABLE(hspi);
 80028ec:	bf5e      	ittt	pl
 80028ee:	6810      	ldrpl	r0, [r2, #0]
 80028f0:	f040 0040 	orrpl.w	r0, r0, #64	; 0x40
 80028f4:	6010      	strpl	r0, [r2, #0]
    if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 80028f6:	68e0      	ldr	r0, [r4, #12]
 80028f8:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
 80028fc:	6860      	ldr	r0, [r4, #4]
 80028fe:	d170      	bne.n	80029e2 <HAL_SPI_TransmitReceive+0x170>
      if((hspi->Init.Mode == SPI_MODE_SLAVE) || ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->TxXferCount == 0x01)))
 8002900:	b120      	cbz	r0, 800290c <HAL_SPI_TransmitReceive+0x9a>
 8002902:	f5b0 7f82 	cmp.w	r0, #260	; 0x104
 8002906:	d107      	bne.n	8002918 <HAL_SPI_TransmitReceive+0xa6>
 8002908:	2b01      	cmp	r3, #1
 800290a:	d105      	bne.n	8002918 <HAL_SPI_TransmitReceive+0xa6>
        hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 800290c:	f831 0b02 	ldrh.w	r0, [r1], #2
 8002910:	60d0      	str	r0, [r2, #12]
        hspi->TxXferCount--;
 8002912:	3b01      	subs	r3, #1
        hspi->pTxBuffPtr+=2;
 8002914:	6321      	str	r1, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 8002916:	86e3      	strh	r3, [r4, #54]	; 0x36
      if(hspi->TxXferCount == 0)
 8002918:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800291a:	2b00      	cmp	r3, #0
 800291c:	d159      	bne.n	80029d2 <HAL_SPI_TransmitReceive+0x160>
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
 800291e:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
          hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 8002922:	bf02      	ittt	eq
 8002924:	6813      	ldreq	r3, [r2, #0]
 8002926:	f443 5380 	orreq.w	r3, r3, #4096	; 0x1000
 800292a:	6013      	streq	r3, [r2, #0]
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 800292c:	462b      	mov	r3, r5
 800292e:	2200      	movs	r2, #0
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8002930:	2101      	movs	r1, #1
 8002932:	4620      	mov	r0, r4
 8002934:	f7ff fe58 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 8002938:	b9e0      	cbnz	r0, 8002974 <HAL_SPI_TransmitReceive+0x102>
          *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 800293a:	6823      	ldr	r3, [r4, #0]
 800293c:	68da      	ldr	r2, [r3, #12]
 800293e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002940:	f823 2b02 	strh.w	r2, [r3], #2
          hspi->pRxBuffPtr+=2;
 8002944:	63a3      	str	r3, [r4, #56]	; 0x38
          hspi->RxXferCount--;
 8002946:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002948:	3b01      	subs	r3, #1
 800294a:	87e3      	strh	r3, [r4, #62]	; 0x3e
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
 800294c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800294e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8002952:	f040 80ad 	bne.w	8002ab0 <HAL_SPI_TransmitReceive+0x23e>
      if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8002956:	462b      	mov	r3, r5
 8002958:	2200      	movs	r2, #0
 800295a:	2101      	movs	r1, #1
 800295c:	4620      	mov	r0, r4
 800295e:	f7ff fe43 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 8002962:	2800      	cmp	r0, #0
 8002964:	f000 809f 	beq.w	8002aa6 <HAL_SPI_TransmitReceive+0x234>
        hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
 8002968:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 800296c:	f043 0302 	orr.w	r3, r3, #2
      hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 8002970:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
      return HAL_TIMEOUT;
 8002974:	2003      	movs	r0, #3
}
 8002976:	b002      	add	sp, #8
 8002978:	bd70      	pop	{r4, r5, r6, pc}
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
 800297a:	462b      	mov	r3, r5
 800297c:	2200      	movs	r2, #0
 800297e:	2102      	movs	r1, #2
 8002980:	4620      	mov	r0, r4
 8002982:	f7ff fe31 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 8002986:	2800      	cmp	r0, #0
 8002988:	d1f4      	bne.n	8002974 <HAL_SPI_TransmitReceive+0x102>
          hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 800298a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800298c:	6822      	ldr	r2, [r4, #0]
 800298e:	f833 1b02 	ldrh.w	r1, [r3], #2
 8002992:	60d1      	str	r1, [r2, #12]
          hspi->pTxBuffPtr+=2;
 8002994:	6323      	str	r3, [r4, #48]	; 0x30
          hspi->TxXferCount--;
 8002996:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002998:	3b01      	subs	r3, #1
 800299a:	b29b      	uxth	r3, r3
 800299c:	86e3      	strh	r3, [r4, #54]	; 0x36
          if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED))
 800299e:	b93b      	cbnz	r3, 80029b0 <HAL_SPI_TransmitReceive+0x13e>
 80029a0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80029a2:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
            hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 80029a6:	bf02      	ittt	eq
 80029a8:	6813      	ldreq	r3, [r2, #0]
 80029aa:	f443 5380 	orreq.w	r3, r3, #4096	; 0x1000
 80029ae:	6013      	streq	r3, [r2, #0]
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 80029b0:	462b      	mov	r3, r5
 80029b2:	2200      	movs	r2, #0
 80029b4:	2101      	movs	r1, #1
 80029b6:	4620      	mov	r0, r4
 80029b8:	f7ff fe16 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 80029bc:	2800      	cmp	r0, #0
 80029be:	d1d9      	bne.n	8002974 <HAL_SPI_TransmitReceive+0x102>
          *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 80029c0:	6823      	ldr	r3, [r4, #0]
 80029c2:	68da      	ldr	r2, [r3, #12]
 80029c4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80029c6:	f823 2b02 	strh.w	r2, [r3], #2
          hspi->pRxBuffPtr+=2;
 80029ca:	63a3      	str	r3, [r4, #56]	; 0x38
          hspi->RxXferCount--;
 80029cc:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80029ce:	3b01      	subs	r3, #1
 80029d0:	87e3      	strh	r3, [r4, #62]	; 0x3e
        while(hspi->TxXferCount > 0)
 80029d2:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80029d4:	2b00      	cmp	r3, #0
 80029d6:	d1d0      	bne.n	800297a <HAL_SPI_TransmitReceive+0x108>
        if(hspi->Init.Mode == SPI_MODE_SLAVE)
 80029d8:	6862      	ldr	r2, [r4, #4]
 80029da:	2a00      	cmp	r2, #0
 80029dc:	d1b6      	bne.n	800294c <HAL_SPI_TransmitReceive+0xda>
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 80029de:	462b      	mov	r3, r5
 80029e0:	e7a6      	b.n	8002930 <HAL_SPI_TransmitReceive+0xbe>
      if((hspi->Init.Mode == SPI_MODE_SLAVE) || ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->TxXferCount == 0x01)))
 80029e2:	b120      	cbz	r0, 80029ee <HAL_SPI_TransmitReceive+0x17c>
 80029e4:	f5b0 7f82 	cmp.w	r0, #260	; 0x104
 80029e8:	d107      	bne.n	80029fa <HAL_SPI_TransmitReceive+0x188>
 80029ea:	2b01      	cmp	r3, #1
 80029ec:	d105      	bne.n	80029fa <HAL_SPI_TransmitReceive+0x188>
        hspi->Instance->DR = (*hspi->pTxBuffPtr++);
 80029ee:	1c48      	adds	r0, r1, #1
 80029f0:	6320      	str	r0, [r4, #48]	; 0x30
 80029f2:	7809      	ldrb	r1, [r1, #0]
 80029f4:	60d1      	str	r1, [r2, #12]
        hspi->TxXferCount--;
 80029f6:	3b01      	subs	r3, #1
 80029f8:	86e3      	strh	r3, [r4, #54]	; 0x36
      if(hspi->TxXferCount == 0)
 80029fa:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80029fc:	2b00      	cmp	r3, #0
 80029fe:	d13f      	bne.n	8002a80 <HAL_SPI_TransmitReceive+0x20e>
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
 8002a00:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
          hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 8002a04:	bf02      	ittt	eq
 8002a06:	6813      	ldreq	r3, [r2, #0]
 8002a08:	f443 5380 	orreq.w	r3, r3, #4096	; 0x1000
 8002a0c:	6013      	streq	r3, [r2, #0]
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8002a0e:	2101      	movs	r1, #1
 8002a10:	462b      	mov	r3, r5
 8002a12:	2200      	movs	r2, #0
 8002a14:	4620      	mov	r0, r4
 8002a16:	f7ff fde7 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 8002a1a:	2800      	cmp	r0, #0
 8002a1c:	d1aa      	bne.n	8002974 <HAL_SPI_TransmitReceive+0x102>
        (*hspi->pRxBuffPtr) = hspi->Instance->DR;
 8002a1e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
          (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
 8002a20:	6822      	ldr	r2, [r4, #0]
 8002a22:	68d2      	ldr	r2, [r2, #12]
 8002a24:	701a      	strb	r2, [r3, #0]
 8002a26:	e78e      	b.n	8002946 <HAL_SPI_TransmitReceive+0xd4>
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8002a28:	462b      	mov	r3, r5
 8002a2a:	2200      	movs	r2, #0
 8002a2c:	2102      	movs	r1, #2
 8002a2e:	4620      	mov	r0, r4
 8002a30:	f7ff fdda 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 8002a34:	2800      	cmp	r0, #0
 8002a36:	d19d      	bne.n	8002974 <HAL_SPI_TransmitReceive+0x102>
          hspi->Instance->DR = (*hspi->pTxBuffPtr++);
 8002a38:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002a3a:	6822      	ldr	r2, [r4, #0]
 8002a3c:	1c59      	adds	r1, r3, #1
 8002a3e:	6321      	str	r1, [r4, #48]	; 0x30
 8002a40:	781b      	ldrb	r3, [r3, #0]
 8002a42:	60d3      	str	r3, [r2, #12]
          hspi->TxXferCount--;
 8002a44:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002a46:	3b01      	subs	r3, #1
 8002a48:	b29b      	uxth	r3, r3
 8002a4a:	86e3      	strh	r3, [r4, #54]	; 0x36
          if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED))
 8002a4c:	b93b      	cbnz	r3, 8002a5e <HAL_SPI_TransmitReceive+0x1ec>
 8002a4e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002a50:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
            hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 8002a54:	bf02      	ittt	eq
 8002a56:	6813      	ldreq	r3, [r2, #0]
 8002a58:	f443 5380 	orreq.w	r3, r3, #4096	; 0x1000
 8002a5c:	6013      	streq	r3, [r2, #0]
            if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8002a5e:	462b      	mov	r3, r5
 8002a60:	2200      	movs	r2, #0
 8002a62:	2101      	movs	r1, #1
 8002a64:	4620      	mov	r0, r4
 8002a66:	f7ff fdbf 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 8002a6a:	2800      	cmp	r0, #0
 8002a6c:	d182      	bne.n	8002974 <HAL_SPI_TransmitReceive+0x102>
            (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
 8002a6e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002a70:	1c5a      	adds	r2, r3, #1
 8002a72:	63a2      	str	r2, [r4, #56]	; 0x38
 8002a74:	6822      	ldr	r2, [r4, #0]
 8002a76:	68d2      	ldr	r2, [r2, #12]
 8002a78:	701a      	strb	r2, [r3, #0]
            hspi->RxXferCount--;
 8002a7a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002a7c:	3b01      	subs	r3, #1
 8002a7e:	87e3      	strh	r3, [r4, #62]	; 0x3e
        while(hspi->TxXferCount > 0)
 8002a80:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8002a82:	2b00      	cmp	r3, #0
 8002a84:	d1d0      	bne.n	8002a28 <HAL_SPI_TransmitReceive+0x1b6>
        if(hspi->Init.Mode == SPI_MODE_SLAVE)
 8002a86:	6862      	ldr	r2, [r4, #4]
 8002a88:	2a00      	cmp	r2, #0
 8002a8a:	f47f af5f 	bne.w	800294c <HAL_SPI_TransmitReceive+0xda>
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8002a8e:	462b      	mov	r3, r5
 8002a90:	2101      	movs	r1, #1
 8002a92:	4620      	mov	r0, r4
 8002a94:	f7ff fda8 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 8002a98:	2800      	cmp	r0, #0
 8002a9a:	f47f af6b 	bne.w	8002974 <HAL_SPI_TransmitReceive+0x102>
          (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
 8002a9e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002aa0:	1c5a      	adds	r2, r3, #1
 8002aa2:	63a2      	str	r2, [r4, #56]	; 0x38
 8002aa4:	e7bc      	b.n	8002a20 <HAL_SPI_TransmitReceive+0x1ae>
      tmpreg = hspi->Instance->DR;
 8002aa6:	6823      	ldr	r3, [r4, #0]
 8002aa8:	68db      	ldr	r3, [r3, #12]
 8002aaa:	b29b      	uxth	r3, r3
 8002aac:	f8ad 3006 	strh.w	r3, [sp, #6]
    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, Timeout) != HAL_OK)
 8002ab0:	462b      	mov	r3, r5
 8002ab2:	2201      	movs	r2, #1
 8002ab4:	2180      	movs	r1, #128	; 0x80
 8002ab6:	4620      	mov	r0, r4
 8002ab8:	f7ff fd96 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 8002abc:	b120      	cbz	r0, 8002ac8 <HAL_SPI_TransmitReceive+0x256>
      hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
 8002abe:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 8002ac2:	f043 0320 	orr.w	r3, r3, #32
 8002ac6:	e753      	b.n	8002970 <HAL_SPI_TransmitReceive+0xfe>
    if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED) && (tmp != RESET))
 8002ac8:	6aa5      	ldr	r5, [r4, #40]	; 0x28
    tmp = __HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR);
 8002aca:	6823      	ldr	r3, [r4, #0]
    hspi->State = HAL_SPI_STATE_READY;
 8002acc:	2101      	movs	r1, #1
 8002ace:	f884 1051 	strb.w	r1, [r4, #81]	; 0x51
    if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED) && (tmp != RESET))
 8002ad2:	f5b5 5f00 	cmp.w	r5, #8192	; 0x2000
    tmp = __HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR);
 8002ad6:	689a      	ldr	r2, [r3, #8]
    if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED) && (tmp != RESET))
 8002ad8:	d113      	bne.n	8002b02 <HAL_SPI_TransmitReceive+0x290>
 8002ada:	06d2      	lsls	r2, r2, #27
 8002adc:	d511      	bpl.n	8002b02 <HAL_SPI_TransmitReceive+0x290>
      hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
 8002ade:	f894 2052 	ldrb.w	r2, [r4, #82]	; 0x52
 8002ae2:	f042 0202 	orr.w	r2, r2, #2
 8002ae6:	f884 2052 	strb.w	r2, [r4, #82]	; 0x52
        __HAL_SPI_RESET_CRC(hspi);
 8002aea:	681a      	ldr	r2, [r3, #0]
 8002aec:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8002af0:	601a      	str	r2, [r3, #0]
 8002af2:	681a      	ldr	r2, [r3, #0]
 8002af4:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8002af8:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hspi);
 8002afa:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
      return  HAL_ERROR;
 8002afe:	2001      	movs	r0, #1
 8002b00:	e739      	b.n	8002976 <HAL_SPI_TransmitReceive+0x104>
    __HAL_UNLOCK(hspi);
 8002b02:	2300      	movs	r3, #0
 8002b04:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
 8002b08:	e735      	b.n	8002976 <HAL_SPI_TransmitReceive+0x104>
    return HAL_BUSY;
 8002b0a:	2002      	movs	r0, #2
 8002b0c:	e733      	b.n	8002976 <HAL_SPI_TransmitReceive+0x104>

08002b0e <HAL_SPI_Receive>:
{
 8002b0e:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  if(hspi->State == HAL_SPI_STATE_READY)
 8002b10:	f890 5051 	ldrb.w	r5, [r0, #81]	; 0x51
 8002b14:	b2ed      	uxtb	r5, r5
 8002b16:	2d01      	cmp	r5, #1
{
 8002b18:	4604      	mov	r4, r0
 8002b1a:	461e      	mov	r6, r3
  if(hspi->State == HAL_SPI_STATE_READY)
 8002b1c:	f040 80dc 	bne.w	8002cd8 <HAL_SPI_Receive+0x1ca>
    if((pData == NULL ) || (Size == 0)) 
 8002b20:	2900      	cmp	r1, #0
 8002b22:	d039      	beq.n	8002b98 <HAL_SPI_Receive+0x8a>
 8002b24:	2a00      	cmp	r2, #0
 8002b26:	d037      	beq.n	8002b98 <HAL_SPI_Receive+0x8a>
    __HAL_LOCK(hspi);
 8002b28:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
 8002b2c:	2b01      	cmp	r3, #1
 8002b2e:	f000 80d3 	beq.w	8002cd8 <HAL_SPI_Receive+0x1ca>
    hspi->State       = HAL_SPI_STATE_BUSY_RX;
 8002b32:	2322      	movs	r3, #34	; 0x22
 8002b34:	f880 3051 	strb.w	r3, [r0, #81]	; 0x51
    hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002b38:	2300      	movs	r3, #0
 8002b3a:	f880 3052 	strb.w	r3, [r0, #82]	; 0x52
    hspi->RxISR = 0;
 8002b3e:	6483      	str	r3, [r0, #72]	; 0x48
    hspi->TxISR = 0;
 8002b40:	64c3      	str	r3, [r0, #76]	; 0x4c
    hspi->TxXferSize   = 0;
 8002b42:	8683      	strh	r3, [r0, #52]	; 0x34
    hspi->TxXferCount  = 0;
 8002b44:	86c3      	strh	r3, [r0, #54]	; 0x36
    __HAL_LOCK(hspi);
 8002b46:	f880 5050 	strb.w	r5, [r0, #80]	; 0x50
    hspi->pRxBuffPtr  = pData;
 8002b4a:	6381      	str	r1, [r0, #56]	; 0x38
    hspi->RxXferSize  = Size;
 8002b4c:	8782      	strh	r2, [r0, #60]	; 0x3c
    hspi->RxXferCount = Size;
 8002b4e:	87c2      	strh	r2, [r0, #62]	; 0x3e
    if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002b50:	6880      	ldr	r0, [r0, #8]
 8002b52:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
      __HAL_SPI_1LINE_RX(hspi);
 8002b56:	bf01      	itttt	eq
 8002b58:	6825      	ldreq	r5, [r4, #0]
 8002b5a:	682b      	ldreq	r3, [r5, #0]
 8002b5c:	f423 4380 	biceq.w	r3, r3, #16384	; 0x4000
 8002b60:	602b      	streq	r3, [r5, #0]
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
 8002b62:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002b64:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8002b68:	d108      	bne.n	8002b7c <HAL_SPI_Receive+0x6e>
      __HAL_SPI_RESET_CRC(hspi);
 8002b6a:	6823      	ldr	r3, [r4, #0]
 8002b6c:	681d      	ldr	r5, [r3, #0]
 8002b6e:	f425 5500 	bic.w	r5, r5, #8192	; 0x2000
 8002b72:	601d      	str	r5, [r3, #0]
 8002b74:	681d      	ldr	r5, [r3, #0]
 8002b76:	f445 5500 	orr.w	r5, r5, #8192	; 0x2000
 8002b7a:	601d      	str	r5, [r3, #0]
    if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8002b7c:	6863      	ldr	r3, [r4, #4]
 8002b7e:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8002b82:	d10c      	bne.n	8002b9e <HAL_SPI_Receive+0x90>
 8002b84:	b958      	cbnz	r0, 8002b9e <HAL_SPI_Receive+0x90>
      __HAL_UNLOCK(hspi);
 8002b86:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
      return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
 8002b8a:	4613      	mov	r3, r2
 8002b8c:	9600      	str	r6, [sp, #0]
 8002b8e:	460a      	mov	r2, r1
 8002b90:	4620      	mov	r0, r4
 8002b92:	f7ff fe6e 	bl	8002872 <HAL_SPI_TransmitReceive>
 8002b96:	4605      	mov	r5, r0
}
 8002b98:	4628      	mov	r0, r5
 8002b9a:	b004      	add	sp, #16
 8002b9c:	bd70      	pop	{r4, r5, r6, pc}
    if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 8002b9e:	6823      	ldr	r3, [r4, #0]
 8002ba0:	681a      	ldr	r2, [r3, #0]
 8002ba2:	0651      	lsls	r1, r2, #25
      __HAL_SPI_ENABLE(hspi);
 8002ba4:	bf5e      	ittt	pl
 8002ba6:	681a      	ldrpl	r2, [r3, #0]
 8002ba8:	f042 0240 	orrpl.w	r2, r2, #64	; 0x40
 8002bac:	601a      	strpl	r2, [r3, #0]
    if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
 8002bae:	68e3      	ldr	r3, [r4, #12]
 8002bb0:	b32b      	cbz	r3, 8002bfe <HAL_SPI_Receive+0xf0>
      while(hspi->RxXferCount > 1)
 8002bb2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002bb4:	2b01      	cmp	r3, #1
 8002bb6:	d925      	bls.n	8002c04 <HAL_SPI_Receive+0xf6>
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8002bb8:	4633      	mov	r3, r6
 8002bba:	2200      	movs	r2, #0
 8002bbc:	2101      	movs	r1, #1
 8002bbe:	4620      	mov	r0, r4
 8002bc0:	f7ff fd12 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 8002bc4:	b980      	cbnz	r0, 8002be8 <HAL_SPI_Receive+0xda>
        *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8002bc6:	6823      	ldr	r3, [r4, #0]
 8002bc8:	68da      	ldr	r2, [r3, #12]
 8002bca:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002bcc:	f823 2b02 	strh.w	r2, [r3], #2
        hspi->pRxBuffPtr+=2;
 8002bd0:	63a3      	str	r3, [r4, #56]	; 0x38
        hspi->RxXferCount--;
 8002bd2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002bd4:	3b01      	subs	r3, #1
 8002bd6:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8002bd8:	e7eb      	b.n	8002bb2 <HAL_SPI_Receive+0xa4>
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8002bda:	4633      	mov	r3, r6
 8002bdc:	2200      	movs	r2, #0
 8002bde:	2101      	movs	r1, #1
 8002be0:	4620      	mov	r0, r4
 8002be2:	f7ff fd01 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 8002be6:	b108      	cbz	r0, 8002bec <HAL_SPI_Receive+0xde>
        return HAL_TIMEOUT;
 8002be8:	2503      	movs	r5, #3
 8002bea:	e7d5      	b.n	8002b98 <HAL_SPI_Receive+0x8a>
        (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
 8002bec:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002bee:	1c5a      	adds	r2, r3, #1
 8002bf0:	63a2      	str	r2, [r4, #56]	; 0x38
 8002bf2:	6822      	ldr	r2, [r4, #0]
 8002bf4:	68d2      	ldr	r2, [r2, #12]
 8002bf6:	701a      	strb	r2, [r3, #0]
        hspi->RxXferCount--;
 8002bf8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002bfa:	3b01      	subs	r3, #1
 8002bfc:	87e3      	strh	r3, [r4, #62]	; 0x3e
      while(hspi->RxXferCount > 1)
 8002bfe:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002c00:	2b01      	cmp	r3, #1
 8002c02:	d8ea      	bhi.n	8002bda <HAL_SPI_Receive+0xcc>
      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED) 
 8002c04:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002c06:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
        hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
 8002c0a:	bf01      	itttt	eq
 8002c0c:	6822      	ldreq	r2, [r4, #0]
 8002c0e:	6813      	ldreq	r3, [r2, #0]
 8002c10:	f443 5380 	orreq.w	r3, r3, #4096	; 0x1000
 8002c14:	6013      	streq	r3, [r2, #0]
    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8002c16:	2101      	movs	r1, #1
 8002c18:	4633      	mov	r3, r6
 8002c1a:	2200      	movs	r2, #0
 8002c1c:	4620      	mov	r0, r4
 8002c1e:	f7ff fce3 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 8002c22:	4605      	mov	r5, r0
 8002c24:	2800      	cmp	r0, #0
 8002c26:	d1df      	bne.n	8002be8 <HAL_SPI_Receive+0xda>
    if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
 8002c28:	68e1      	ldr	r1, [r4, #12]
 8002c2a:	6822      	ldr	r2, [r4, #0]
 8002c2c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002c2e:	b9c1      	cbnz	r1, 8002c62 <HAL_SPI_Receive+0x154>
      (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
 8002c30:	1c59      	adds	r1, r3, #1
 8002c32:	68d2      	ldr	r2, [r2, #12]
 8002c34:	63a1      	str	r1, [r4, #56]	; 0x38
 8002c36:	701a      	strb	r2, [r3, #0]
    hspi->RxXferCount--;
 8002c38:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002c3a:	3b01      	subs	r3, #1
 8002c3c:	87e3      	strh	r3, [r4, #62]	; 0x3e
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
 8002c3e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002c40:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8002c44:	d117      	bne.n	8002c76 <HAL_SPI_Receive+0x168>
      if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8002c46:	4633      	mov	r3, r6
 8002c48:	2200      	movs	r2, #0
 8002c4a:	2101      	movs	r1, #1
 8002c4c:	4620      	mov	r0, r4
 8002c4e:	f7ff fccb 	bl	80025e8 <SPI_WaitOnFlagUntilTimeout>
 8002c52:	b158      	cbz	r0, 8002c6c <HAL_SPI_Receive+0x15e>
        hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
 8002c54:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 8002c58:	f043 0302 	orr.w	r3, r3, #2
 8002c5c:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
 8002c60:	e7c2      	b.n	8002be8 <HAL_SPI_Receive+0xda>
      *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8002c62:	68d2      	ldr	r2, [r2, #12]
 8002c64:	f823 2b02 	strh.w	r2, [r3], #2
      hspi->pRxBuffPtr+=2;
 8002c68:	63a3      	str	r3, [r4, #56]	; 0x38
 8002c6a:	e7e5      	b.n	8002c38 <HAL_SPI_Receive+0x12a>
      tmpreg = hspi->Instance->DR;
 8002c6c:	6823      	ldr	r3, [r4, #0]
 8002c6e:	68db      	ldr	r3, [r3, #12]
 8002c70:	b29b      	uxth	r3, r3
 8002c72:	f8ad 300e 	strh.w	r3, [sp, #14]
    if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8002c76:	6863      	ldr	r3, [r4, #4]
 8002c78:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8002c7c:	6823      	ldr	r3, [r4, #0]
 8002c7e:	d10a      	bne.n	8002c96 <HAL_SPI_Receive+0x188>
 8002c80:	68a2      	ldr	r2, [r4, #8]
 8002c82:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8002c86:	d002      	beq.n	8002c8e <HAL_SPI_Receive+0x180>
 8002c88:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8002c8c:	d103      	bne.n	8002c96 <HAL_SPI_Receive+0x188>
      __HAL_SPI_DISABLE(hspi);
 8002c8e:	681a      	ldr	r2, [r3, #0]
 8002c90:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002c94:	601a      	str	r2, [r3, #0]
    if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED) && (tmp != RESET))
 8002c96:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    hspi->State = HAL_SPI_STATE_READY;
 8002c98:	2101      	movs	r1, #1
 8002c9a:	f884 1051 	strb.w	r1, [r4, #81]	; 0x51
    if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED) && (tmp != RESET))
 8002c9e:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
    tmp = __HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR);
 8002ca2:	689a      	ldr	r2, [r3, #8]
    if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED) && (tmp != RESET))
 8002ca4:	d114      	bne.n	8002cd0 <HAL_SPI_Receive+0x1c2>
 8002ca6:	06d2      	lsls	r2, r2, #27
 8002ca8:	d512      	bpl.n	8002cd0 <HAL_SPI_Receive+0x1c2>
      hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
 8002caa:	f894 2052 	ldrb.w	r2, [r4, #82]	; 0x52
 8002cae:	f042 0202 	orr.w	r2, r2, #2
 8002cb2:	f884 2052 	strb.w	r2, [r4, #82]	; 0x52
      __HAL_SPI_RESET_CRC(hspi);
 8002cb6:	681a      	ldr	r2, [r3, #0]
 8002cb8:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8002cbc:	601a      	str	r2, [r3, #0]
 8002cbe:	681a      	ldr	r2, [r3, #0]
 8002cc0:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8002cc4:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hspi);
 8002cc6:	2300      	movs	r3, #0
 8002cc8:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
      return HAL_ERROR; 
 8002ccc:	460d      	mov	r5, r1
 8002cce:	e763      	b.n	8002b98 <HAL_SPI_Receive+0x8a>
    __HAL_UNLOCK(hspi);
 8002cd0:	2300      	movs	r3, #0
 8002cd2:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    return HAL_OK;
 8002cd6:	e75f      	b.n	8002b98 <HAL_SPI_Receive+0x8a>
    return HAL_BUSY;
 8002cd8:	2502      	movs	r5, #2
 8002cda:	e75d      	b.n	8002b98 <HAL_SPI_Receive+0x8a>

08002cdc <HAL_SPI_GetState>:
  return hspi->State;
 8002cdc:	f890 0051 	ldrb.w	r0, [r0, #81]	; 0x51
}
 8002ce0:	4770      	bx	lr

08002ce2 <FMC_SDRAM_Init>:
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
 8002ce2:	680b      	ldr	r3, [r1, #0]
 8002ce4:	f101 0208 	add.w	r2, r1, #8
 8002ce8:	2b01      	cmp	r3, #1
{
 8002cea:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002cec:	684b      	ldr	r3, [r1, #4]
 8002cee:	694e      	ldr	r6, [r1, #20]
 8002cf0:	698d      	ldr	r5, [r1, #24]
 8002cf2:	69cc      	ldr	r4, [r1, #28]
 8002cf4:	6a0f      	ldr	r7, [r1, #32]
 8002cf6:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8002cf8:	e892 5004 	ldmia.w	r2, {r2, ip, lr}
  if (Init->SDBank != FMC_SDRAM_BANK2) 
 8002cfc:	d00c      	beq.n	8002d18 <FMC_SDRAM_Init+0x36>
  {                                      
    Device->SDCR[FMC_SDRAM_BANK1] = (uint32_t)(Init->ColumnBitsNumber   |\
 8002cfe:	431a      	orrs	r2, r3
                                               Init->RowBitsNumber      |\
 8002d00:	ea42 020c 	orr.w	r2, r2, ip
                                               Init->MemoryDataWidth    |\
 8002d04:	ea42 030e 	orr.w	r3, r2, lr
                                               Init->InternalBankNumber |\
 8002d08:	4333      	orrs	r3, r6
                                               Init->CASLatency         |\
 8002d0a:	432b      	orrs	r3, r5
                                               Init->WriteProtection    |\
 8002d0c:	4323      	orrs	r3, r4
                                               Init->SDClockPeriod      |\
 8002d0e:	433b      	orrs	r3, r7
                                               Init->ReadBurst          |\
 8002d10:	430b      	orrs	r3, r1
    Device->SDCR[FMC_SDRAM_BANK1] = (uint32_t)(Init->ColumnBitsNumber   |\
 8002d12:	6003      	str	r3, [r0, #0]
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
  }  
  
  return HAL_OK;
}
 8002d14:	2000      	movs	r0, #0
 8002d16:	bdf0      	pop	{r4, r5, r6, r7, pc}
    tmpr2 = (uint32_t)(Init->ColumnBitsNumber   |\
 8002d18:	4313      	orrs	r3, r2
                       Init->RowBitsNumber      |\
 8002d1a:	ea43 030c 	orr.w	r3, r3, ip
                       Init->MemoryDataWidth    |\
 8002d1e:	ea43 030e 	orr.w	r3, r3, lr
    tmpr1 = (uint32_t)(Init->SDClockPeriod      |\
 8002d22:	433c      	orrs	r4, r7
                       Init->InternalBankNumber |\
 8002d24:	4333      	orrs	r3, r6
    tmpr1 = (uint32_t)(Init->SDClockPeriod      |\
 8002d26:	430c      	orrs	r4, r1
    tmpr2 = (uint32_t)(Init->ColumnBitsNumber   |\
 8002d28:	432b      	orrs	r3, r5
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 8002d2a:	6004      	str	r4, [r0, #0]
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
 8002d2c:	6043      	str	r3, [r0, #4]
 8002d2e:	e7f1      	b.n	8002d14 <FMC_SDRAM_Init+0x32>

08002d30 <FMC_SDRAM_Timing_Init>:
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));
  
  /* Set SDRAM device timing parameters */ 
  if (Bank != FMC_SDRAM_BANK2) 
 8002d30:	2a01      	cmp	r2, #1
{
 8002d32:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002d34:	684a      	ldr	r2, [r1, #4]
 8002d36:	688b      	ldr	r3, [r1, #8]
 8002d38:	680f      	ldr	r7, [r1, #0]
 8002d3a:	68cd      	ldr	r5, [r1, #12]
 8002d3c:	690e      	ldr	r6, [r1, #16]
 8002d3e:	694c      	ldr	r4, [r1, #20]
 8002d40:	6989      	ldr	r1, [r1, #24]
  if (Bank != FMC_SDRAM_BANK2) 
 8002d42:	d016      	beq.n	8002d72 <FMC_SDRAM_Timing_Init+0x42>
  {                                         
    Device->SDTR[FMC_SDRAM_BANK1] = (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                                               (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 8002d44:	f102 3eff 	add.w	lr, r2, #4294967295	; 0xffffffff
                                               (((Timing->SelfRefreshTime)-1) << 8)      |\
 8002d48:	1e5a      	subs	r2, r3, #1
 8002d4a:	0212      	lsls	r2, r2, #8
    Device->SDTR[FMC_SDRAM_BANK1] = (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8002d4c:	1e7b      	subs	r3, r7, #1
                                               (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 8002d4e:	ea42 120e 	orr.w	r2, r2, lr, lsl #4
 8002d52:	431a      	orrs	r2, r3
                                               (((Timing->RowCycleDelay)-1) << 12)       |\
 8002d54:	1e6b      	subs	r3, r5, #1
                                               (((Timing->SelfRefreshTime)-1) << 8)      |\
 8002d56:	ea42 3203 	orr.w	r2, r2, r3, lsl #12
                                               (((Timing->WriteRecoveryTime)-1) <<16)    |\
 8002d5a:	1e73      	subs	r3, r6, #1
                                               (((Timing->RowCycleDelay)-1) << 12)       |\
 8002d5c:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
                                               (((Timing->RPDelay)-1) << 20)             |\
 8002d60:	3c01      	subs	r4, #1
                                               (((Timing->WriteRecoveryTime)-1) <<16)    |\
 8002d62:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
                                               (((Timing->RCDDelay)-1) << 24)
 8002d66:	3901      	subs	r1, #1
    Device->SDTR[FMC_SDRAM_BANK1] = (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8002d68:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8002d6c:	6083      	str	r3, [r0, #8]
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr1;
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr2;
  }   
  
  return HAL_OK;
}
 8002d6e:	2000      	movs	r0, #0
 8002d70:	bdf0      	pop	{r4, r5, r6, r7, pc}
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 8002d72:	3b01      	subs	r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 8002d74:	3a01      	subs	r2, #1
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 8002d76:	021b      	lsls	r3, r3, #8
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 8002d78:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
    tmpr1 = (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8002d7c:	3f01      	subs	r7, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 8002d7e:	433b      	orrs	r3, r7
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 8002d80:	3e01      	subs	r6, #1
                        (((Timing->RPDelay)-1) << 20)
 8002d82:	3c01      	subs	r4, #1
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 8002d84:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
                       (((Timing->RCDDelay)-1) << 24)
 8002d88:	3901      	subs	r1, #1
    tmpr2  = (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 8002d8a:	3d01      	subs	r5, #1
                        (((Timing->RPDelay)-1) << 20)
 8002d8c:	0524      	lsls	r4, r4, #20
    tmpr1 = (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8002d8e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    tmpr2  = (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 8002d92:	ea44 3505 	orr.w	r5, r4, r5, lsl #12
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr1;
 8002d96:	60c3      	str	r3, [r0, #12]
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr2;
 8002d98:	6085      	str	r5, [r0, #8]
 8002d9a:	e7e8      	b.n	8002d6e <FMC_SDRAM_Timing_Init+0x3e>

08002d9c <FMC_SDRAM_SendCommand>:
  * @param  Timing: Pointer to SDRAM Timing structure
  * @param  Timeout: Timeout wait value
  * @retval HAL state
  */  
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 8002d9c:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __IO uint32_t tmpr = 0;
 8002d9e:	2300      	movs	r3, #0
 8002da0:	9301      	str	r3, [sp, #4]
{
 8002da2:	4615      	mov	r5, r2
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 8002da4:	e891 000c 	ldmia.w	r1, {r2, r3}
 8002da8:	4313      	orrs	r3, r2
                    (Command->CommandTarget)                |\
                    (((Command->AutoRefreshNumber)-1) << 5) |\
                    ((Command->ModeRegisterDefinition) << 9)
 8002daa:	68ca      	ldr	r2, [r1, #12]
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 8002dac:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
                    (((Command->AutoRefreshNumber)-1) << 5) |\
 8002db0:	688a      	ldr	r2, [r1, #8]
 8002db2:	3a01      	subs	r2, #1
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 8002db4:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
 8002db8:	9301      	str	r3, [sp, #4]
                    );
    
  Device->SDCMR = tmpr;
 8002dba:	9b01      	ldr	r3, [sp, #4]
 8002dbc:	6103      	str	r3, [r0, #16]
{
 8002dbe:	4606      	mov	r6, r0

  /* Get tick */ 
  tickstart = HAL_GetTick();
 8002dc0:	f7fd fa70 	bl	80002a4 <HAL_GetTick>
 8002dc4:	4604      	mov	r4, r0

  /* wait until command is send */
  while(HAL_IS_BIT_SET(Device->SDSR, FMC_SDSR_BUSY))
 8002dc6:	69b0      	ldr	r0, [r6, #24]
 8002dc8:	f010 0020 	ands.w	r0, r0, #32
 8002dcc:	d002      	beq.n	8002dd4 <FMC_SDRAM_SendCommand+0x38>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 8002dce:	1c6b      	adds	r3, r5, #1
 8002dd0:	d102      	bne.n	8002dd8 <FMC_SDRAM_SendCommand+0x3c>
      {
        return HAL_TIMEOUT;
      }
    }     
    
    return HAL_ERROR;
 8002dd2:	2001      	movs	r0, #1
  }
  
  return HAL_OK;  
}
 8002dd4:	b002      	add	sp, #8
 8002dd6:	bd70      	pop	{r4, r5, r6, pc}
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8002dd8:	b125      	cbz	r5, 8002de4 <FMC_SDRAM_SendCommand+0x48>
 8002dda:	f7fd fa63 	bl	80002a4 <HAL_GetTick>
 8002dde:	1b00      	subs	r0, r0, r4
 8002de0:	4285      	cmp	r5, r0
 8002de2:	d2f6      	bcs.n	8002dd2 <FMC_SDRAM_SendCommand+0x36>
        return HAL_TIMEOUT;
 8002de4:	2003      	movs	r0, #3
 8002de6:	e7f5      	b.n	8002dd4 <FMC_SDRAM_SendCommand+0x38>

08002de8 <FMC_SDRAM_ProgramRefreshRate>:
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
  
  /* Set the refresh rate in command register */
  Device->SDRTR |= (RefreshRate<<1);
 8002de8:	6943      	ldr	r3, [r0, #20]
 8002dea:	ea43 0141 	orr.w	r1, r3, r1, lsl #1
 8002dee:	6141      	str	r1, [r0, #20]
  
  return HAL_OK;   
}
 8002df0:	2000      	movs	r0, #0
 8002df2:	4770      	bx	lr

08002df4 <USB_CoreInit>:
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8002df4:	b084      	sub	sp, #16
 8002df6:	b538      	push	{r3, r4, r5, lr}
 8002df8:	ad05      	add	r5, sp, #20
 8002dfa:	e885 000e 	stmia.w	r5, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8002dfe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002e00:	2b01      	cmp	r3, #1
{
 8002e02:	4604      	mov	r4, r0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8002e04:	d126      	bne.n	8002e54 <USB_CoreInit+0x60>
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8002e06:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8002e08:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8002e0c:	6383      	str	r3, [r0, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8002e0e:	68c3      	ldr	r3, [r0, #12]
 8002e10:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 8002e14:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002e18:	60c3      	str	r3, [r0, #12]
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8002e1a:	68c3      	ldr	r3, [r0, #12]
 8002e1c:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8002e20:	60c3      	str	r3, [r0, #12]
    if(cfg.use_external_vbus == 1)
 8002e22:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8002e24:	2b01      	cmp	r3, #1
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 8002e26:	bf02      	ittt	eq
 8002e28:	68c3      	ldreq	r3, [r0, #12]
 8002e2a:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
 8002e2e:	60c3      	streq	r3, [r0, #12]
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
 8002e30:	f000 fbba 	bl	80035a8 <USB_CoreReset>
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
  }
 
  if(cfg.dma_enable == ENABLE)
 8002e34:	9b08      	ldr	r3, [sp, #32]
 8002e36:	2b01      	cmp	r3, #1
 8002e38:	d107      	bne.n	8002e4a <USB_CoreInit+0x56>
  {
    USBx->GAHBCFG |= (USB_OTG_GAHBCFG_HBSTLEN_1 | USB_OTG_GAHBCFG_HBSTLEN_2);
 8002e3a:	68a3      	ldr	r3, [r4, #8]
 8002e3c:	f043 030c 	orr.w	r3, r3, #12
 8002e40:	60a3      	str	r3, [r4, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8002e42:	68a3      	ldr	r3, [r4, #8]
 8002e44:	f043 0320 	orr.w	r3, r3, #32
 8002e48:	60a3      	str	r3, [r4, #8]
  }  

  return HAL_OK;
}
 8002e4a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8002e4e:	2000      	movs	r0, #0
 8002e50:	b004      	add	sp, #16
 8002e52:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8002e54:	68c3      	ldr	r3, [r0, #12]
 8002e56:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002e5a:	60c3      	str	r3, [r0, #12]
    USB_CoreReset(USBx);
 8002e5c:	f000 fba4 	bl	80035a8 <USB_CoreReset>
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
 8002e60:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8002e64:	63a3      	str	r3, [r4, #56]	; 0x38
 8002e66:	e7e5      	b.n	8002e34 <USB_CoreInit+0x40>

08002e68 <USB_EnableGlobalInt>:
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8002e68:	6883      	ldr	r3, [r0, #8]
 8002e6a:	f043 0301 	orr.w	r3, r3, #1
 8002e6e:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 8002e70:	2000      	movs	r0, #0
 8002e72:	4770      	bx	lr

08002e74 <USB_DisableGlobalInt>:
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8002e74:	6883      	ldr	r3, [r0, #8]
 8002e76:	f023 0301 	bic.w	r3, r3, #1
 8002e7a:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 8002e7c:	2000      	movs	r0, #0
 8002e7e:	4770      	bx	lr

08002e80 <USB_SetCurrentMode>:
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
 8002e80:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 8002e82:	68c3      	ldr	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 8002e84:	2901      	cmp	r1, #1
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 8002e86:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8002e8a:	60c3      	str	r3, [r0, #12]
  if ( mode == USB_OTG_HOST_MODE)
 8002e8c:	d108      	bne.n	8002ea0 <USB_SetCurrentMode+0x20>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
 8002e8e:	68c3      	ldr	r3, [r0, #12]
 8002e90:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8002e94:	60c3      	str	r3, [r0, #12]
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
  }
  HAL_Delay(50);
 8002e96:	2032      	movs	r0, #50	; 0x32
 8002e98:	f7fd fa0a 	bl	80002b0 <HAL_Delay>
  
  return HAL_OK;
}
 8002e9c:	2000      	movs	r0, #0
 8002e9e:	bd08      	pop	{r3, pc}
  else if ( mode == USB_OTG_DEVICE_MODE)
 8002ea0:	2900      	cmp	r1, #0
 8002ea2:	d1f8      	bne.n	8002e96 <USB_SetCurrentMode+0x16>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
 8002ea4:	68c3      	ldr	r3, [r0, #12]
 8002ea6:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8002eaa:	60c3      	str	r3, [r0, #12]
 8002eac:	e7f3      	b.n	8002e96 <USB_SetCurrentMode+0x16>
	...

08002eb0 <USB_DevInit>:
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8002eb0:	b084      	sub	sp, #16
 8002eb2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002eb6:	4604      	mov	r4, r0
 8002eb8:	a807      	add	r0, sp, #28
 8002eba:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  uint32_t i = 0;

  /*Activate VBUS Sensing B */
  USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 8002ebe:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002ec0:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 8002ec2:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8002ec4:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8002ec8:	4688      	mov	r8, r1
 8002eca:	63a3      	str	r3, [r4, #56]	; 0x38
  
  if (cfg.vbus_sensing_enable == 0)
 8002ecc:	b91e      	cbnz	r6, 8002ed6 <USB_DevInit+0x26>
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 8002ece:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002ed0:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8002ed4:	63a3      	str	r3, [r4, #56]	; 0x38
  }
   
  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0;
 8002ed6:	2300      	movs	r3, #0
 8002ed8:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8002edc:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 8002ee0:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 8002ee4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8002ee6:	2b01      	cmp	r3, #1
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8002ee8:	f504 6500 	add.w	r5, r4, #2048	; 0x800
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 8002eec:	d15a      	bne.n	8002fa4 <USB_DevInit+0xf4>
  {
    if(cfg.speed == USB_OTG_SPEED_HIGH)
 8002eee:	9909      	ldr	r1, [sp, #36]	; 0x24
 8002ef0:	b919      	cbnz	r1, 8002efa <USB_DevInit+0x4a>
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 8002ef2:	4620      	mov	r0, r4
 8002ef4:	f000 f89a 	bl	800302c <USB_SetDevSpeed>
 8002ef8:	e003      	b.n	8002f02 <USB_DevInit+0x52>
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
 8002efa:	4619      	mov	r1, r3
 8002efc:	4620      	mov	r0, r4
 8002efe:	f000 f895 	bl	800302c <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10); /* all Tx FIFOs */
 8002f02:	2110      	movs	r1, #16
 8002f04:	4620      	mov	r0, r4
 8002f06:	f000 f86f 	bl	8002fe8 <USB_FlushTxFifo>
  USB_FlushRxFifo(USBx);
 8002f0a:	4620      	mov	r0, r4
 8002f0c:	f000 f87e 	bl	800300c <USB_FlushRxFifo>

  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0;
 8002f10:	2300      	movs	r3, #0
  USBx_DEVICE->DOEPMSK = 0;
  USBx_DEVICE->DAINT = 0xFFFFFFFF;
 8002f12:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  USBx_DEVICE->DIEPMSK = 0;
 8002f16:	612b      	str	r3, [r5, #16]
 8002f18:	4619      	mov	r1, r3
  USBx_DEVICE->DOEPMSK = 0;
 8002f1a:	616b      	str	r3, [r5, #20]
  
  for (i = 0; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 8002f1c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  USBx_DEVICE->DAINT = 0xFFFFFFFF;
 8002f20:	61aa      	str	r2, [r5, #24]
    {
      USBx_INEP(i)->DIEPCTL = 0;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0;
    USBx_INEP(i)->DIEPINT  = 0xFF;
 8002f22:	f04f 0eff 	mov.w	lr, #255	; 0xff
  USBx_DEVICE->DAINTMSK = 0;
 8002f26:	61eb      	str	r3, [r5, #28]
 8002f28:	f504 6210 	add.w	r2, r4, #2304	; 0x900
  for (i = 0; i < cfg.dev_endpoints; i++)
 8002f2c:	4543      	cmp	r3, r8
 8002f2e:	d13b      	bne.n	8002fa8 <USB_DevInit+0xf8>
 8002f30:	2100      	movs	r1, #0
 8002f32:	f504 6230 	add.w	r2, r4, #2816	; 0xb00
 8002f36:	4608      	mov	r0, r1
  
  for (i = 0; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 8002f38:	f04f 4e90 	mov.w	lr, #1207959552	; 0x48000000
    {
      USBx_OUTEP(i)->DOEPCTL = 0;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0;
    USBx_OUTEP(i)->DOEPINT  = 0xFF;
 8002f3c:	f04f 0cff 	mov.w	ip, #255	; 0xff
  for (i = 0; i < cfg.dev_endpoints; i++)
 8002f40:	428b      	cmp	r3, r1
 8002f42:	d13e      	bne.n	8002fc2 <USB_DevInit+0x112>
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8002f44:	692b      	ldr	r3, [r5, #16]
  
  if (cfg.dma_enable == 1)
 8002f46:	2f01      	cmp	r7, #1
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8002f48:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8002f4c:	612b      	str	r3, [r5, #16]
  if (cfg.dma_enable == 1)
 8002f4e:	d108      	bne.n	8002f62 <USB_DevInit+0xb2>
  {
    /*Set threshold parameters */
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
 8002f50:	4b23      	ldr	r3, [pc, #140]	; (8002fe0 <USB_DevInit+0x130>)
 8002f52:	632b      	str	r3, [r5, #48]	; 0x30
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
 8002f54:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8002f56:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002f5a:	f043 0303 	orr.w	r3, r3, #3
 8002f5e:	632b      	str	r3, [r5, #48]	; 0x30
    
    i= USBx_DEVICE->DTHRCTL;
 8002f60:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0;
 8002f62:	2300      	movs	r3, #0
 8002f64:	61a3      	str	r3, [r4, #24]
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFF;
 8002f66:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 8002f6a:	6163      	str	r3, [r4, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 8002f6c:	b91f      	cbnz	r7, 8002f76 <USB_DevInit+0xc6>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 8002f6e:	69a3      	ldr	r3, [r4, #24]
 8002f70:	f043 0310 	orr.w	r3, r3, #16
 8002f74:	61a3      	str	r3, [r4, #24]
  }
  
  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 8002f76:	69a2      	ldr	r2, [r4, #24]
 8002f78:	4b1a      	ldr	r3, [pc, #104]	; (8002fe4 <USB_DevInit+0x134>)
 8002f7a:	4313      	orrs	r3, r2
 8002f7c:	61a3      	str	r3, [r4, #24]
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
  
  if(cfg.Sof_enable)
 8002f7e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8002f80:	b11b      	cbz	r3, 8002f8a <USB_DevInit+0xda>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8002f82:	69a3      	ldr	r3, [r4, #24]
 8002f84:	f043 0308 	orr.w	r3, r3, #8
 8002f88:	61a3      	str	r3, [r4, #24]
  }

  if (cfg.vbus_sensing_enable == ENABLE)
 8002f8a:	2e01      	cmp	r6, #1
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
 8002f8c:	bf01      	itttt	eq
 8002f8e:	69a3      	ldreq	r3, [r4, #24]
 8002f90:	f043 4380 	orreq.w	r3, r3, #1073741824	; 0x40000000
 8002f94:	f043 0304 	orreq.w	r3, r3, #4
 8002f98:	61a3      	streq	r3, [r4, #24]
  }
  
  return HAL_OK;
}
 8002f9a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8002f9e:	2000      	movs	r0, #0
 8002fa0:	b004      	add	sp, #16
 8002fa2:	4770      	bx	lr
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 8002fa4:	2103      	movs	r1, #3
 8002fa6:	e7a4      	b.n	8002ef2 <USB_DevInit+0x42>
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8002fa8:	f8d2 c000 	ldr.w	ip, [r2]
 8002fac:	f1bc 0f00 	cmp.w	ip, #0
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 8002fb0:	bfb4      	ite	lt
 8002fb2:	6010      	strlt	r0, [r2, #0]
      USBx_INEP(i)->DIEPCTL = 0;
 8002fb4:	6011      	strge	r1, [r2, #0]
  for (i = 0; i < cfg.dev_endpoints; i++)
 8002fb6:	3301      	adds	r3, #1
    USBx_INEP(i)->DIEPTSIZ = 0;
 8002fb8:	6111      	str	r1, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFF;
 8002fba:	f8c2 e008 	str.w	lr, [r2, #8]
 8002fbe:	3220      	adds	r2, #32
 8002fc0:	e7b4      	b.n	8002f2c <USB_DevInit+0x7c>
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8002fc2:	f8d2 8000 	ldr.w	r8, [r2]
 8002fc6:	f1b8 0f00 	cmp.w	r8, #0
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 8002fca:	bfb4      	ite	lt
 8002fcc:	f8c2 e000 	strlt.w	lr, [r2]
      USBx_OUTEP(i)->DOEPCTL = 0;
 8002fd0:	6010      	strge	r0, [r2, #0]
  for (i = 0; i < cfg.dev_endpoints; i++)
 8002fd2:	3101      	adds	r1, #1
    USBx_OUTEP(i)->DOEPTSIZ = 0;
 8002fd4:	6110      	str	r0, [r2, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFF;
 8002fd6:	f8c2 c008 	str.w	ip, [r2, #8]
 8002fda:	3220      	adds	r2, #32
 8002fdc:	e7b0      	b.n	8002f40 <USB_DevInit+0x90>
 8002fde:	bf00      	nop
 8002fe0:	00800100 	.word	0x00800100
 8002fe4:	803c3800 	.word	0x803c3800

08002fe8 <USB_FlushTxFifo>:
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0;
 
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 5 )); 
 8002fe8:	0149      	lsls	r1, r1, #5
 8002fea:	f041 0120 	orr.w	r1, r1, #32
 8002fee:	4a06      	ldr	r2, [pc, #24]	; (8003008 <USB_FlushTxFifo+0x20>)
 8002ff0:	6101      	str	r1, [r0, #16]
 
  do
  {
    if (++count > 200000)
 8002ff2:	3a01      	subs	r2, #1
 8002ff4:	d005      	beq.n	8003002 <USB_FlushTxFifo+0x1a>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8002ff6:	6903      	ldr	r3, [r0, #16]
 8002ff8:	f013 0320 	ands.w	r3, r3, #32
 8002ffc:	d1f9      	bne.n	8002ff2 <USB_FlushTxFifo+0xa>
  
  return HAL_OK;
 8002ffe:	4618      	mov	r0, r3
 8003000:	4770      	bx	lr
      return HAL_TIMEOUT;
 8003002:	2003      	movs	r0, #3
}
 8003004:	4770      	bx	lr
 8003006:	bf00      	nop
 8003008:	00030d41 	.word	0x00030d41

0800300c <USB_FlushRxFifo>:
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800300c:	2310      	movs	r3, #16
 800300e:	4a06      	ldr	r2, [pc, #24]	; (8003028 <USB_FlushRxFifo+0x1c>)
 8003010:	6103      	str	r3, [r0, #16]
  
  do
  {
    if (++count > 200000)
 8003012:	3a01      	subs	r2, #1
 8003014:	d005      	beq.n	8003022 <USB_FlushRxFifo+0x16>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8003016:	6903      	ldr	r3, [r0, #16]
 8003018:	f013 0310 	ands.w	r3, r3, #16
 800301c:	d1f9      	bne.n	8003012 <USB_FlushRxFifo+0x6>
  
  return HAL_OK;
 800301e:	4618      	mov	r0, r3
 8003020:	4770      	bx	lr
      return HAL_TIMEOUT;
 8003022:	2003      	movs	r0, #3
}
 8003024:	4770      	bx	lr
 8003026:	bf00      	nop
 8003028:	00030d41 	.word	0x00030d41

0800302c <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 800302c:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8003030:	4319      	orrs	r1, r3
 8003032:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
  return HAL_OK;
}
 8003036:	2000      	movs	r0, #0
 8003038:	4770      	bx	lr

0800303a <USB_GetDevSpeed>:
  */
uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
{
  uint8_t speed = 0;
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 800303a:	f500 6200 	add.w	r2, r0, #2048	; 0x800
 800303e:	f8d0 0808 	ldr.w	r0, [r0, #2056]	; 0x808
 8003042:	f010 0006 	ands.w	r0, r0, #6
 8003046:	d012      	beq.n	800306e <USB_GetDevSpeed+0x34>
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 8003048:	6893      	ldr	r3, [r2, #8]
 800304a:	f003 0306 	and.w	r3, r3, #6
 800304e:	2b02      	cmp	r3, #2
 8003050:	d00c      	beq.n	800306c <USB_GetDevSpeed+0x32>
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
 8003052:	6893      	ldr	r3, [r2, #8]
 8003054:	f003 0306 	and.w	r3, r3, #6
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 8003058:	2b06      	cmp	r3, #6
 800305a:	d007      	beq.n	800306c <USB_GetDevSpeed+0x32>
  {
    speed = USB_OTG_SPEED_FULL;
  }
  else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 800305c:	6893      	ldr	r3, [r2, #8]
 800305e:	f003 0306 	and.w	r3, r3, #6
 8003062:	2b04      	cmp	r3, #4
  {
    speed = USB_OTG_SPEED_LOW;
 8003064:	bf14      	ite	ne
 8003066:	2000      	movne	r0, #0
 8003068:	2002      	moveq	r0, #2
 800306a:	4770      	bx	lr
    speed = USB_OTG_SPEED_FULL;
 800306c:	2003      	movs	r0, #3
  }
  
  return speed;
}
 800306e:	4770      	bx	lr

08003070 <USB_ActivateEndpoint>:
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8003070:	b530      	push	{r4, r5, lr}
  if (ep->is_in == 1)
 8003072:	784b      	ldrb	r3, [r1, #1]
 8003074:	780c      	ldrb	r4, [r1, #0]
  {
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num)));
 8003076:	f8d0 581c 	ldr.w	r5, [r0, #2076]	; 0x81c
 800307a:	f500 6200 	add.w	r2, r0, #2048	; 0x800
  if (ep->is_in == 1)
 800307e:	2b01      	cmp	r3, #1
 8003080:	d11b      	bne.n	80030ba <USB_ActivateEndpoint+0x4a>
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num)));
 8003082:	40a3      	lsls	r3, r4
 8003084:	b29b      	uxth	r3, r3
 8003086:	432b      	orrs	r3, r5
   
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0)
 8003088:	f500 6010 	add.w	r0, r0, #2304	; 0x900
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num)));
 800308c:	61d3      	str	r3, [r2, #28]
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0)
 800308e:	eb00 1344 	add.w	r3, r0, r4, lsl #5
 8003092:	681a      	ldr	r2, [r3, #0]
 8003094:	0412      	lsls	r2, r2, #16
 8003096:	d40e      	bmi.n	80030b6 <USB_ActivateEndpoint+0x46>
    {
      USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18 ) |\
 8003098:	688a      	ldr	r2, [r1, #8]
 800309a:	78c8      	ldrb	r0, [r1, #3]
 800309c:	681d      	ldr	r5, [r3, #0]
 800309e:	f3c2 020a 	ubfx	r2, r2, #0, #11
 80030a2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80030a6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80030aa:	ea42 4080 	orr.w	r0, r2, r0, lsl #18
 80030ae:	ea40 5084 	orr.w	r0, r0, r4, lsl #22
 80030b2:	4328      	orrs	r0, r5
 80030b4:	6018      	str	r0, [r3, #0]
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
       (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));
    } 
  }
  return HAL_OK;
}
 80030b6:	2000      	movs	r0, #0
 80030b8:	bd30      	pop	{r4, r5, pc}
     USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16);
 80030ba:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80030be:	40a3      	lsls	r3, r4
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)
 80030c0:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
     USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16);
 80030c4:	432b      	orrs	r3, r5
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)
 80030c6:	eb00 1044 	add.w	r0, r0, r4, lsl #5
     USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16);
 80030ca:	61d3      	str	r3, [r2, #28]
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)
 80030cc:	6803      	ldr	r3, [r0, #0]
 80030ce:	041b      	lsls	r3, r3, #16
 80030d0:	d4f1      	bmi.n	80030b6 <USB_ActivateEndpoint+0x46>
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
 80030d2:	688b      	ldr	r3, [r1, #8]
 80030d4:	78c9      	ldrb	r1, [r1, #3]
 80030d6:	6802      	ldr	r2, [r0, #0]
 80030d8:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80030dc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80030e0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80030e4:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 80030e8:	4313      	orrs	r3, r2
 80030ea:	6003      	str	r3, [r0, #0]
 80030ec:	e7e3      	b.n	80030b6 <USB_ActivateEndpoint+0x46>

080030ee <USB_DeactivateEndpoint>:
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 80030ee:	b510      	push	{r4, lr}
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
 80030f0:	784b      	ldrb	r3, [r1, #1]
  {
   USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));
 80030f2:	f8d0 483c 	ldr.w	r4, [r0, #2108]	; 0x83c
 80030f6:	7809      	ldrb	r1, [r1, #0]
 80030f8:	f500 6200 	add.w	r2, r0, #2048	; 0x800
  if (ep->is_in == 1)
 80030fc:	2b01      	cmp	r3, #1
 80030fe:	d111      	bne.n	8003124 <USB_DeactivateEndpoint+0x36>
   USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));
 8003100:	408b      	lsls	r3, r1
 8003102:	b29b      	uxth	r3, r3
 8003104:	43db      	mvns	r3, r3
 8003106:	401c      	ands	r4, r3
 8003108:	63d4      	str	r4, [r2, #60]	; 0x3c
   USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));   
 800310a:	69d4      	ldr	r4, [r2, #28]
   USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;   
 800310c:	f500 6010 	add.w	r0, r0, #2304	; 0x900
   USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));   
 8003110:	4023      	ands	r3, r4
   USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;   
 8003112:	eb00 1041 	add.w	r0, r0, r1, lsl #5
   USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));   
 8003116:	61d3      	str	r3, [r2, #28]
   USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;   
 8003118:	6803      	ldr	r3, [r0, #0]
 800311a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800311e:	6003      	str	r3, [r0, #0]
     USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));
     USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));     
     USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;      
  }
  return HAL_OK;
}
 8003120:	2000      	movs	r0, #0
 8003122:	bd10      	pop	{r4, pc}
     USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));
 8003124:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8003128:	408b      	lsls	r3, r1
 800312a:	43db      	mvns	r3, r3
 800312c:	401c      	ands	r4, r3
 800312e:	63d4      	str	r4, [r2, #60]	; 0x3c
     USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));     
 8003130:	69d4      	ldr	r4, [r2, #28]
     USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;      
 8003132:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
     USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));     
 8003136:	4023      	ands	r3, r4
     USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;      
 8003138:	eb00 1041 	add.w	r0, r0, r1, lsl #5
     USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));     
 800313c:	61d3      	str	r3, [r2, #28]
     USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;      
 800313e:	6803      	ldr	r3, [r0, #0]
 8003140:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003144:	6003      	str	r3, [r0, #0]
 8003146:	e7eb      	b.n	8003120 <USB_DeactivateEndpoint+0x32>

08003148 <USB_EPStartXfer>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8003148:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uint16_t pktcnt = 0;
  
  /* IN endpoint */
  if (ep->is_in == 1)
 800314a:	784b      	ldrb	r3, [r1, #1]
 800314c:	780c      	ldrb	r4, [r1, #0]
 800314e:	2b01      	cmp	r3, #1
 8003150:	694b      	ldr	r3, [r1, #20]
 8003152:	d177      	bne.n	8003244 <USB_EPStartXfer+0xfc>
 8003154:	2620      	movs	r6, #32
 8003156:	f500 6510 	add.w	r5, r0, #2304	; 0x900
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 800315a:	fb16 5404 	smlabb	r4, r6, r4, r5
 800315e:	6926      	ldr	r6, [r4, #16]
    if (ep->xfer_len == 0)
 8003160:	2b00      	cmp	r3, #0
 8003162:	d138      	bne.n	80031d6 <USB_EPStartXfer+0x8e>
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8003164:	f026 56ff 	bic.w	r6, r6, #534773760	; 0x1fe00000
 8003168:	f426 16c0 	bic.w	r6, r6, #1572864	; 0x180000
 800316c:	6126      	str	r6, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
 800316e:	6926      	ldr	r6, [r4, #16]
 8003170:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
 8003174:	6126      	str	r6, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 8003176:	6926      	ldr	r6, [r4, #16]
 8003178:	0cf6      	lsrs	r6, r6, #19
 800317a:	04f6      	lsls	r6, r6, #19
 800317c:	6126      	str	r6, [r4, #16]
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1 << 29)); 
      }       
    }

    if (dma == 1)
 800317e:	2a01      	cmp	r2, #1
 8003180:	d150      	bne.n	8003224 <USB_EPStartXfer+0xdc>
    {
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8003182:	780c      	ldrb	r4, [r1, #0]
 8003184:	690e      	ldr	r6, [r1, #16]
 8003186:	eb05 1444 	add.w	r4, r5, r4, lsl #5
 800318a:	6166      	str	r6, [r4, #20]
          USBx_DEVICE->DIEPEMPMSK |= 1 << ep->num;
        }
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 800318c:	78ce      	ldrb	r6, [r1, #3]
 800318e:	2e01      	cmp	r6, #1
 8003190:	d10f      	bne.n	80031b2 <USB_EPStartXfer+0x6a>
    {
      if ((USBx_DEVICE->DSTS & ( 1 << 8 )) == 0)
 8003192:	f8d0 4808 	ldr.w	r4, [r0, #2056]	; 0x808
 8003196:	780f      	ldrb	r7, [r1, #0]
 8003198:	f414 7f80 	tst.w	r4, #256	; 0x100
 800319c:	f04f 0420 	mov.w	r4, #32
      {
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 80031a0:	fb14 5407 	smlabb	r4, r4, r7, r5
 80031a4:	6827      	ldr	r7, [r4, #0]
 80031a6:	bf0c      	ite	eq
 80031a8:	f047 5700 	orreq.w	r7, r7, #536870912	; 0x20000000
      }
      else
      {
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 80031ac:	f047 5780 	orrne.w	r7, r7, #268435456	; 0x10000000
 80031b0:	6027      	str	r7, [r4, #0]
      }
    } 
    
    /* EP enable, IN data in FIFO */
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80031b2:	780f      	ldrb	r7, [r1, #0]
 80031b4:	eb05 1547 	add.w	r5, r5, r7, lsl #5
    
    if (ep->type == EP_TYPE_ISOC)
 80031b8:	2e01      	cmp	r6, #1
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80031ba:	682c      	ldr	r4, [r5, #0]
 80031bc:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 80031c0:	602c      	str	r4, [r5, #0]
    if (ep->type == EP_TYPE_ISOC)
 80031c2:	d105      	bne.n	80031d0 <USB_EPStartXfer+0x88>
    {
      USB_WritePacket(USBx, ep->xfer_buff, ep->num, ep->xfer_len, dma);   
 80031c4:	9200      	str	r2, [sp, #0]
 80031c6:	b29b      	uxth	r3, r3
 80031c8:	463a      	mov	r2, r7
 80031ca:	68c9      	ldr	r1, [r1, #12]
 80031cc:	f000 f8f9 	bl	80033c2 <USB_WritePacket>
    }
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
  }
  return HAL_OK;
}
 80031d0:	2000      	movs	r0, #0
 80031d2:	b003      	add	sp, #12
 80031d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80031d6:	0cf6      	lsrs	r6, r6, #19
 80031d8:	04f6      	lsls	r6, r6, #19
 80031da:	6126      	str	r6, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 80031dc:	6926      	ldr	r6, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket) << 19)) ;
 80031de:	688f      	ldr	r7, [r1, #8]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 80031e0:	f026 56ff 	bic.w	r6, r6, #534773760	; 0x1fe00000
 80031e4:	f426 16c0 	bic.w	r6, r6, #1572864	; 0x180000
 80031e8:	6126      	str	r6, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket) << 19)) ;
 80031ea:	19de      	adds	r6, r3, r7
 80031ec:	3e01      	subs	r6, #1
 80031ee:	fbb6 f7f7 	udiv	r7, r6, r7
 80031f2:	4e37      	ldr	r6, [pc, #220]	; (80032d0 <USB_EPStartXfer+0x188>)
 80031f4:	f8d4 e010 	ldr.w	lr, [r4, #16]
 80031f8:	ea06 46c7 	and.w	r6, r6, r7, lsl #19
 80031fc:	ea46 060e 	orr.w	r6, r6, lr
 8003200:	6126      	str	r6, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 8003202:	6927      	ldr	r7, [r4, #16]
 8003204:	f3c3 0612 	ubfx	r6, r3, #0, #19
 8003208:	433e      	orrs	r6, r7
 800320a:	6126      	str	r6, [r4, #16]
      if (ep->type == EP_TYPE_ISOC)
 800320c:	78ce      	ldrb	r6, [r1, #3]
 800320e:	2e01      	cmp	r6, #1
 8003210:	d15a      	bne.n	80032c8 <USB_EPStartXfer+0x180>
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
 8003212:	6926      	ldr	r6, [r4, #16]
 8003214:	f026 46c0 	bic.w	r6, r6, #1610612736	; 0x60000000
 8003218:	6126      	str	r6, [r4, #16]
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1 << 29)); 
 800321a:	6926      	ldr	r6, [r4, #16]
 800321c:	f046 5600 	orr.w	r6, r6, #536870912	; 0x20000000
 8003220:	6126      	str	r6, [r4, #16]
 8003222:	e7ac      	b.n	800317e <USB_EPStartXfer+0x36>
      if (ep->type != EP_TYPE_ISOC)
 8003224:	78ce      	ldrb	r6, [r1, #3]
 8003226:	2e01      	cmp	r6, #1
 8003228:	d0b3      	beq.n	8003192 <USB_EPStartXfer+0x4a>
        if (ep->xfer_len > 0)
 800322a:	2b00      	cmp	r3, #0
 800322c:	d0ae      	beq.n	800318c <USB_EPStartXfer+0x44>
          USBx_DEVICE->DIEPEMPMSK |= 1 << ep->num;
 800322e:	f891 e000 	ldrb.w	lr, [r1]
 8003232:	f8d0 7834 	ldr.w	r7, [r0, #2100]	; 0x834
 8003236:	2401      	movs	r4, #1
 8003238:	fa04 f40e 	lsl.w	r4, r4, lr
 800323c:	433c      	orrs	r4, r7
 800323e:	f8c0 4834 	str.w	r4, [r0, #2100]	; 0x834
 8003242:	e7a3      	b.n	800318c <USB_EPStartXfer+0x44>
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 8003244:	f500 6530 	add.w	r5, r0, #2816	; 0xb00
 8003248:	eb05 1444 	add.w	r4, r5, r4, lsl #5
 800324c:	6925      	ldr	r5, [r4, #16]
 800324e:	0ced      	lsrs	r5, r5, #19
 8003250:	04ed      	lsls	r5, r5, #19
 8003252:	6125      	str	r5, [r4, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 8003254:	6925      	ldr	r5, [r4, #16]
 8003256:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 800325a:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
 800325e:	6125      	str	r5, [r4, #16]
 8003260:	688d      	ldr	r5, [r1, #8]
    if (ep->xfer_len == 0)
 8003262:	b9fb      	cbnz	r3, 80032a4 <USB_EPStartXfer+0x15c>
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8003264:	6923      	ldr	r3, [r4, #16]
 8003266:	f3c5 0512 	ubfx	r5, r5, #0, #19
 800326a:	431d      	orrs	r5, r3
 800326c:	6125      	str	r5, [r4, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;      
 800326e:	6923      	ldr	r3, [r4, #16]
 8003270:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8003274:	6123      	str	r3, [r4, #16]
    if (dma == 1)
 8003276:	2a01      	cmp	r2, #1
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
 8003278:	bf04      	itt	eq
 800327a:	68cb      	ldreq	r3, [r1, #12]
 800327c:	6163      	streq	r3, [r4, #20]
    if (ep->type == EP_TYPE_ISOC)
 800327e:	78cb      	ldrb	r3, [r1, #3]
 8003280:	2b01      	cmp	r3, #1
 8003282:	d10a      	bne.n	800329a <USB_EPStartXfer+0x152>
      if ((USBx_DEVICE->DSTS & ( 1 << 8 )) == 0)
 8003284:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8003288:	f413 7f80 	tst.w	r3, #256	; 0x100
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 800328c:	6823      	ldr	r3, [r4, #0]
 800328e:	bf0c      	ite	eq
 8003290:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 8003294:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
 8003298:	6023      	str	r3, [r4, #0]
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 800329a:	6823      	ldr	r3, [r4, #0]
 800329c:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80032a0:	6023      	str	r3, [r4, #0]
  return HAL_OK;
 80032a2:	e795      	b.n	80031d0 <USB_EPStartXfer+0x88>
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19)); ;
 80032a4:	4e0a      	ldr	r6, [pc, #40]	; (80032d0 <USB_EPStartXfer+0x188>)
 80032a6:	6927      	ldr	r7, [r4, #16]
      pktcnt = (ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket; 
 80032a8:	442b      	add	r3, r5
 80032aa:	3b01      	subs	r3, #1
 80032ac:	fbb3 f3f5 	udiv	r3, r3, r5
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19)); ;
 80032b0:	ea06 46c3 	and.w	r6, r6, r3, lsl #19
 80032b4:	433e      	orrs	r6, r7
 80032b6:	6126      	str	r6, [r4, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt)); 
 80032b8:	b29b      	uxth	r3, r3
 80032ba:	6926      	ldr	r6, [r4, #16]
 80032bc:	435d      	muls	r5, r3
 80032be:	f3c5 0512 	ubfx	r5, r5, #0, #19
 80032c2:	4335      	orrs	r5, r6
 80032c4:	6125      	str	r5, [r4, #16]
 80032c6:	e7d6      	b.n	8003276 <USB_EPStartXfer+0x12e>
    if (dma == 1)
 80032c8:	2a01      	cmp	r2, #1
 80032ca:	d1ae      	bne.n	800322a <USB_EPStartXfer+0xe2>
 80032cc:	e759      	b.n	8003182 <USB_EPStartXfer+0x3a>
 80032ce:	bf00      	nop
 80032d0:	1ff80000 	.word	0x1ff80000

080032d4 <USB_EP0StartXfer>:
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
  /* IN endpoint */
  if (ep->is_in == 1)
 80032d4:	784b      	ldrb	r3, [r1, #1]
 80032d6:	2b01      	cmp	r3, #1
{
 80032d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80032da:	694d      	ldr	r5, [r1, #20]
 80032dc:	780f      	ldrb	r7, [r1, #0]
  if (ep->is_in == 1)
 80032de:	d14d      	bne.n	800337c <USB_EP0StartXfer+0xa8>
 80032e0:	f500 6410 	add.w	r4, r0, #2304	; 0x900
 80032e4:	2320      	movs	r3, #32
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 80032e6:	bb0d      	cbnz	r5, 800332c <USB_EP0StartXfer+0x58>
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 80032e8:	fb13 4007 	smlabb	r0, r3, r7, r4
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
    
    }
    
    if (dma == 1)
 80032ec:	2a01      	cmp	r2, #1
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 80032ee:	6903      	ldr	r3, [r0, #16]
 80032f0:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 80032f4:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 80032f8:	6103      	str	r3, [r0, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
 80032fa:	6903      	ldr	r3, [r0, #16]
 80032fc:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8003300:	6103      	str	r3, [r0, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 8003302:	6903      	ldr	r3, [r0, #16]
 8003304:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 8003308:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 800330c:	6103      	str	r3, [r0, #16]
    if (dma == 1)
 800330e:	d104      	bne.n	800331a <USB_EP0StartXfer+0x46>
    {
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8003310:	780b      	ldrb	r3, [r1, #0]
 8003312:	690a      	ldr	r2, [r1, #16]
 8003314:	eb04 1343 	add.w	r3, r4, r3, lsl #5
 8003318:	615a      	str	r2, [r3, #20]
        USBx_DEVICE->DIEPEMPMSK |= 1 << (ep->num);
      }
    }
    
    /* EP enable, IN data in FIFO */
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);   
 800331a:	780b      	ldrb	r3, [r1, #0]
 800331c:	eb04 1343 	add.w	r3, r4, r3, lsl #5
 8003320:	681a      	ldr	r2, [r3, #0]
 8003322:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8003326:	601a      	str	r2, [r3, #0]
    
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
  }
  return HAL_OK;
}
 8003328:	2000      	movs	r0, #0
 800332a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800332c:	fb13 4307 	smlabb	r3, r3, r7, r4
 8003330:	691e      	ldr	r6, [r3, #16]
 8003332:	0cf6      	lsrs	r6, r6, #19
 8003334:	04f6      	lsls	r6, r6, #19
 8003336:	611e      	str	r6, [r3, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8003338:	691e      	ldr	r6, [r3, #16]
 800333a:	f026 56ff 	bic.w	r6, r6, #534773760	; 0x1fe00000
 800333e:	f426 16c0 	bic.w	r6, r6, #1572864	; 0x180000
 8003342:	611e      	str	r6, [r3, #16]
      if(ep->xfer_len > ep->maxpacket)
 8003344:	688e      	ldr	r6, [r1, #8]
 8003346:	42b5      	cmp	r5, r6
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
 8003348:	691d      	ldr	r5, [r3, #16]
        ep->xfer_len = ep->maxpacket;
 800334a:	bf88      	it	hi
 800334c:	614e      	strhi	r6, [r1, #20]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
 800334e:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 8003352:	611d      	str	r5, [r3, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 8003354:	694e      	ldr	r6, [r1, #20]
 8003356:	f8d3 e010 	ldr.w	lr, [r3, #16]
 800335a:	f3c6 0512 	ubfx	r5, r6, #0, #19
 800335e:	ea45 050e 	orr.w	r5, r5, lr
    if (dma == 1)
 8003362:	2a01      	cmp	r2, #1
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 8003364:	611d      	str	r5, [r3, #16]
    if (dma == 1)
 8003366:	d0d3      	beq.n	8003310 <USB_EP0StartXfer+0x3c>
      if (ep->xfer_len > 0)
 8003368:	2e00      	cmp	r6, #0
 800336a:	d0d6      	beq.n	800331a <USB_EP0StartXfer+0x46>
        USBx_DEVICE->DIEPEMPMSK |= 1 << (ep->num);
 800336c:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
 8003370:	2301      	movs	r3, #1
 8003372:	40bb      	lsls	r3, r7
 8003374:	4313      	orrs	r3, r2
 8003376:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
 800337a:	e7ce      	b.n	800331a <USB_EP0StartXfer+0x46>
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 800337c:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
 8003380:	eb00 1047 	add.w	r0, r0, r7, lsl #5
 8003384:	6903      	ldr	r3, [r0, #16]
 8003386:	0cdb      	lsrs	r3, r3, #19
 8003388:	04db      	lsls	r3, r3, #19
 800338a:	6103      	str	r3, [r0, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 800338c:	6903      	ldr	r3, [r0, #16]
 800338e:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 8003392:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 8003396:	6103      	str	r3, [r0, #16]
 8003398:	688b      	ldr	r3, [r1, #8]
    if (ep->xfer_len > 0)
 800339a:	b105      	cbz	r5, 800339e <USB_EP0StartXfer+0xca>
      ep->xfer_len = ep->maxpacket;
 800339c:	614b      	str	r3, [r1, #20]
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19));
 800339e:	6904      	ldr	r4, [r0, #16]
 80033a0:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 80033a4:	6104      	str	r4, [r0, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 80033a6:	6904      	ldr	r4, [r0, #16]
 80033a8:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80033ac:	4323      	orrs	r3, r4
    if (dma == 1)
 80033ae:	2a01      	cmp	r2, #1
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 80033b0:	6103      	str	r3, [r0, #16]
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 80033b2:	bf04      	itt	eq
 80033b4:	68cb      	ldreq	r3, [r1, #12]
 80033b6:	6143      	streq	r3, [r0, #20]
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
 80033b8:	6803      	ldr	r3, [r0, #0]
 80033ba:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80033be:	6003      	str	r3, [r0, #0]
 80033c0:	e7b2      	b.n	8003328 <USB_EP0StartXfer+0x54>

080033c2 <USB_WritePacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 80033c2:	b510      	push	{r4, lr}
 80033c4:	f89d 4008 	ldrb.w	r4, [sp, #8]
  uint32_t count32b= 0 , i= 0;
  
  if (dma == 0)
 80033c8:	b93c      	cbnz	r4, 80033da <USB_WritePacket+0x18>
  {
    count32b =  (len + 3) / 4;
 80033ca:	3303      	adds	r3, #3
    for (i = 0; i < count32b; i++, src += 4)
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 80033cc:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
    count32b =  (len + 3) / 4;
 80033d0:	109b      	asrs	r3, r3, #2
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 80033d2:	eb00 3202 	add.w	r2, r0, r2, lsl #12
    for (i = 0; i < count32b; i++, src += 4)
 80033d6:	42a3      	cmp	r3, r4
 80033d8:	d101      	bne.n	80033de <USB_WritePacket+0x1c>
    }
  }
  return HAL_OK;
}
 80033da:	2000      	movs	r0, #0
 80033dc:	bd10      	pop	{r4, pc}
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 80033de:	f851 0024 	ldr.w	r0, [r1, r4, lsl #2]
 80033e2:	6010      	str	r0, [r2, #0]
    for (i = 0; i < count32b; i++, src += 4)
 80033e4:	3401      	adds	r4, #1
 80033e6:	e7f6      	b.n	80033d6 <USB_WritePacket+0x14>

080033e8 <USB_ReadPacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval pointer to desctination buffer
  */
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 80033e8:	b510      	push	{r4, lr}
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
 80033ea:	3203      	adds	r2, #3
 80033ec:	1092      	asrs	r2, r2, #2
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 80033ee:	2300      	movs	r3, #0
  {
    *(__packed uint32_t *)dest = USBx_DFIFO(0);
 80033f0:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
  for ( i = 0; i < count32b; i++, dest += 4 )
 80033f4:	4293      	cmp	r3, r2
 80033f6:	d102      	bne.n	80033fe <USB_ReadPacket+0x16>
    
  }
  return ((void *)dest);
}
 80033f8:	eb01 0083 	add.w	r0, r1, r3, lsl #2
 80033fc:	bd10      	pop	{r4, pc}
    *(__packed uint32_t *)dest = USBx_DFIFO(0);
 80033fe:	6804      	ldr	r4, [r0, #0]
 8003400:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
  for ( i = 0; i < count32b; i++, dest += 4 )
 8003404:	3301      	adds	r3, #1
 8003406:	e7f5      	b.n	80033f4 <USB_ReadPacket+0xc>

08003408 <USB_EPSetStall>:
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1)
 8003408:	784b      	ldrb	r3, [r1, #1]
 800340a:	780a      	ldrb	r2, [r1, #0]
 800340c:	2b01      	cmp	r3, #1
 800340e:	f04f 0320 	mov.w	r3, #32
 8003412:	d10b      	bne.n	800342c <USB_EPSetStall+0x24>
  {
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == 0)
 8003414:	f500 6010 	add.w	r0, r0, #2304	; 0x900
 8003418:	fb13 0002 	smlabb	r0, r3, r2, r0
 800341c:	6803      	ldr	r3, [r0, #0]
 800341e:	2b00      	cmp	r3, #0
 8003420:	db0b      	blt.n	800343a <USB_EPSetStall+0x32>
  }
  else
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0)
    {
      USBx_OUTEP(ep->num)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS); 
 8003422:	6803      	ldr	r3, [r0, #0]
 8003424:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8003428:	6003      	str	r3, [r0, #0]
 800342a:	e006      	b.n	800343a <USB_EPSetStall+0x32>
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0)
 800342c:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
 8003430:	fb13 0002 	smlabb	r0, r3, r2, r0
 8003434:	6803      	ldr	r3, [r0, #0]
 8003436:	2b00      	cmp	r3, #0
 8003438:	daf3      	bge.n	8003422 <USB_EPSetStall+0x1a>
    } 
    USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 800343a:	6803      	ldr	r3, [r0, #0]
 800343c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8003440:	6003      	str	r3, [r0, #0]
  }
  return HAL_OK;
}
 8003442:	2000      	movs	r0, #0
 8003444:	4770      	bx	lr

08003446 <USB_EPClearStall>:
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1)
 8003446:	784b      	ldrb	r3, [r1, #1]
 8003448:	780a      	ldrb	r2, [r1, #0]
 800344a:	2b01      	cmp	r3, #1
  {
    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800344c:	bf0c      	ite	eq
 800344e:	f500 6010 	addeq.w	r0, r0, #2304	; 0x900
       USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }    
  }
  else
  {
    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8003452:	f500 6030 	addne.w	r0, r0, #2816	; 0xb00
 8003456:	2320      	movs	r3, #32
 8003458:	fb13 0002 	smlabb	r0, r3, r2, r0
 800345c:	6803      	ldr	r3, [r0, #0]
 800345e:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8003462:	6003      	str	r3, [r0, #0]
    if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 8003464:	78cb      	ldrb	r3, [r1, #3]
 8003466:	3b02      	subs	r3, #2
 8003468:	2b01      	cmp	r3, #1
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 800346a:	bf9e      	ittt	ls
 800346c:	6803      	ldrls	r3, [r0, #0]
 800346e:	f043 5380 	orrls.w	r3, r3, #268435456	; 0x10000000
 8003472:	6003      	strls	r3, [r0, #0]
    }    
  }
  return HAL_OK;
}
 8003474:	2000      	movs	r0, #0
 8003476:	4770      	bx	lr

08003478 <USB_SetDevAddress>:
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
  USBx_DEVICE->DCFG &= ~ (USB_OTG_DCFG_DAD);
 8003478:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 800347c:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8003480:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= (address << 4) & USB_OTG_DCFG_DAD ;
 8003484:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8003488:	0109      	lsls	r1, r1, #4
 800348a:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 800348e:	4319      	orrs	r1, r3
 8003490:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
  
  return HAL_OK;  
}
 8003494:	2000      	movs	r0, #0
 8003496:	4770      	bx	lr

08003498 <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling the pull-up/pull-down
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect (USB_OTG_GlobalTypeDef *USBx)
{
 8003498:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS ;
 800349a:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 800349e:	f023 0302 	bic.w	r3, r3, #2
 80034a2:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3);
 80034a6:	2003      	movs	r0, #3
 80034a8:	f7fc ff02 	bl	80002b0 <HAL_Delay>
  
  return HAL_OK;  
}
 80034ac:	2000      	movs	r0, #0
 80034ae:	bd08      	pop	{r3, pc}

080034b0 <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
{
 80034b0:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;
 80034b2:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 80034b6:	f043 0302 	orr.w	r3, r3, #2
 80034ba:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3);
 80034be:	2003      	movs	r0, #3
 80034c0:	f7fc fef6 	bl	80002b0 <HAL_Delay>
  
  return HAL_OK;  
}
 80034c4:	2000      	movs	r0, #0
 80034c6:	bd08      	pop	{r3, pc}

080034c8 <USB_ReadInterrupts>:
  */
uint32_t  USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v = 0;
  
  v = USBx->GINTSTS;
 80034c8:	6942      	ldr	r2, [r0, #20]
  v &= USBx->GINTMSK;
 80034ca:	6980      	ldr	r0, [r0, #24]
  return v;  
}
 80034cc:	4010      	ands	r0, r2
 80034ce:	4770      	bx	lr

080034d0 <USB_ReadDevAllOutEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 80034d0:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 80034d4:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  v &= USBx_DEVICE->DAINTMSK;
 80034d8:	69c0      	ldr	r0, [r0, #28]
 80034da:	4018      	ands	r0, r3
  return ((v & 0xffff0000) >> 16);
}
 80034dc:	0c00      	lsrs	r0, r0, #16
 80034de:	4770      	bx	lr

080034e0 <USB_ReadDevAllInEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 80034e0:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 80034e4:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  v &= USBx_DEVICE->DAINTMSK;
 80034e8:	69c0      	ldr	r0, [r0, #28]
 80034ea:	4018      	ands	r0, r3
  return ((v & 0xFFFF));
}
 80034ec:	b280      	uxth	r0, r0
 80034ee:	4770      	bx	lr

080034f0 <USB_ReadDevOutEPInterrupt>:
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v;
  v  = USBx_OUTEP(epnum)->DOEPINT;
 80034f0:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 80034f4:	eb03 1141 	add.w	r1, r3, r1, lsl #5
  v &= USBx_DEVICE->DOEPMSK;
 80034f8:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  v  = USBx_OUTEP(epnum)->DOEPINT;
 80034fc:	688a      	ldr	r2, [r1, #8]
  v &= USBx_DEVICE->DOEPMSK;
 80034fe:	6940      	ldr	r0, [r0, #20]
  return v;
}
 8003500:	4010      	ands	r0, r2
 8003502:	4770      	bx	lr

08003504 <USB_ReadDevInEPInterrupt>:
  * @param  epnum : endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
 8003504:	b510      	push	{r4, lr}
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
 8003506:	f8d0 4810 	ldr.w	r4, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 800350a:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
  msk |= ((emp >> epnum) & 0x1) << 7;
  v = USBx_INEP(epnum)->DIEPINT & msk;
 800350e:	eb00 1041 	add.w	r0, r0, r1, lsl #5
  msk |= ((emp >> epnum) & 0x1) << 7;
 8003512:	40cb      	lsrs	r3, r1
  v = USBx_INEP(epnum)->DIEPINT & msk;
 8003514:	f500 6010 	add.w	r0, r0, #2304	; 0x900
  msk |= ((emp >> epnum) & 0x1) << 7;
 8003518:	01db      	lsls	r3, r3, #7
  v = USBx_INEP(epnum)->DIEPINT & msk;
 800351a:	6880      	ldr	r0, [r0, #8]
  msk |= ((emp >> epnum) & 0x1) << 7;
 800351c:	b2db      	uxtb	r3, r3
 800351e:	4323      	orrs	r3, r4
  return v;
}
 8003520:	4018      	ands	r0, r3
 8003522:	bd10      	pop	{r4, pc}

08003524 <USB_GetMode>:
  *           0 : Host 
  *           1 : Device
  */
uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
{
  return ((USBx->GINTSTS ) & 0x1);
 8003524:	6940      	ldr	r0, [r0, #20]
}
 8003526:	f000 0001 	and.w	r0, r0, #1
 800352a:	4770      	bx	lr

0800352c <USB_ActivateSetup>:
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)
{
  /* Set the MPS of the IN EP based on the enumeration speed */
  USBx_INEP(0)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 800352c:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8003530:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8003534:	f023 0307 	bic.w	r3, r3, #7
 8003538:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 800353c:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 8003540:	689a      	ldr	r2, [r3, #8]
 8003542:	f002 0206 	and.w	r2, r2, #6
 8003546:	2a04      	cmp	r2, #4
  {
    USBx_INEP(0)->DIEPCTL |= 3;
 8003548:	bf02      	ittt	eq
 800354a:	f8d0 2900 	ldreq.w	r2, [r0, #2304]	; 0x900
 800354e:	f042 0203 	orreq.w	r2, r2, #3
 8003552:	f8c0 2900 	streq.w	r2, [r0, #2304]	; 0x900
  }
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8003556:	685a      	ldr	r2, [r3, #4]
 8003558:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800355c:	605a      	str	r2, [r3, #4]

  return HAL_OK;
}
 800355e:	2000      	movs	r0, #0
 8003560:	4770      	bx	lr

08003562 <USB_EP0_OutStart>:
  *           1 : DMA feature used  
  * @param  psetup : pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
 8003562:	b510      	push	{r4, lr}
  USBx_OUTEP(0)->DOEPTSIZ = 0;
 8003564:	2400      	movs	r4, #0
 8003566:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;
 800356a:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 800356e:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 8003572:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0)->DOEPTSIZ |= (3 * 8);
 8003576:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 800357a:	f044 0418 	orr.w	r4, r4, #24
 800357e:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 8003582:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
  
  if (dma == 1)
 8003586:	2901      	cmp	r1, #1
  USBx_OUTEP(0)->DOEPTSIZ = 0;
 8003588:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
  USBx_OUTEP(0)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 800358c:	f044 44c0 	orr.w	r4, r4, #1610612736	; 0x60000000
  {
    USBx_OUTEP(0)->DOEPDMA = (uint32_t)psetup;
    /* EP enable */
    USBx_OUTEP(0)->DOEPCTL = 0x80008000;
 8003590:	bf08      	it	eq
 8003592:	f04f 2380 	moveq.w	r3, #2147516416	; 0x80008000
  USBx_OUTEP(0)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 8003596:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
    USBx_OUTEP(0)->DOEPDMA = (uint32_t)psetup;
 800359a:	bf04      	itt	eq
 800359c:	f8c0 2b14 	streq.w	r2, [r0, #2836]	; 0xb14
    USBx_OUTEP(0)->DOEPCTL = 0x80008000;
 80035a0:	f8c0 3b00 	streq.w	r3, [r0, #2816]	; 0xb00
  }
  
  return HAL_OK;  
}
 80035a4:	2000      	movs	r0, #0
 80035a6:	bd10      	pop	{r4, pc}

080035a8 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx : Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 80035a8:	4b0a      	ldr	r3, [pc, #40]	; (80035d4 <USB_CoreReset+0x2c>)
  uint32_t count = 0;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000)
 80035aa:	3b01      	subs	r3, #1
 80035ac:	d101      	bne.n	80035b2 <USB_CoreReset+0xa>
    {
      return HAL_TIMEOUT;
 80035ae:	2003      	movs	r0, #3
 80035b0:	4770      	bx	lr
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0);
 80035b2:	6902      	ldr	r2, [r0, #16]
 80035b4:	2a00      	cmp	r2, #0
 80035b6:	daf8      	bge.n	80035aa <USB_CoreReset+0x2>
  
  /* Core Soft Reset */
  count = 0;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 80035b8:	6903      	ldr	r3, [r0, #16]
 80035ba:	4a06      	ldr	r2, [pc, #24]	; (80035d4 <USB_CoreReset+0x2c>)
 80035bc:	f043 0301 	orr.w	r3, r3, #1
 80035c0:	6103      	str	r3, [r0, #16]

  do
  {
    if (++count > 200000)
 80035c2:	3a01      	subs	r2, #1
 80035c4:	d0f3      	beq.n	80035ae <USB_CoreReset+0x6>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 80035c6:	6903      	ldr	r3, [r0, #16]
 80035c8:	f013 0301 	ands.w	r3, r3, #1
 80035cc:	d1f9      	bne.n	80035c2 <USB_CoreReset+0x1a>
  
  return HAL_OK;
 80035ce:	4618      	mov	r0, r3
}
 80035d0:	4770      	bx	lr
 80035d2:	bf00      	nop
 80035d4:	00030d41 	.word	0x00030d41

080035d8 <USBD_HID_GetCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_HID_GetCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_HID_CfgDesc);
 80035d8:	2322      	movs	r3, #34	; 0x22
 80035da:	8003      	strh	r3, [r0, #0]
  return USBD_HID_CfgDesc;
}
 80035dc:	4800      	ldr	r0, [pc, #0]	; (80035e0 <USBD_HID_GetCfgDesc+0x8>)
 80035de:	4770      	bx	lr
 80035e0:	20000088 	.word	0x20000088

080035e4 <USBD_HID_DataIn>:
                              uint8_t epnum)
{
  
  /* Ensure that the FIFO is empty before a new transfer, this condition could 
  be caused by  a new transfer before the end of the previous transfer */
  ((USBD_HID_HandleTypeDef *)pdev->pClassData)->state = HID_IDLE;
 80035e4:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
 80035e8:	2000      	movs	r0, #0
 80035ea:	7318      	strb	r0, [r3, #12]
  return USBD_OK;
}
 80035ec:	4770      	bx	lr
	...

080035f0 <USBD_HID_GetDeviceQualifierDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
static uint8_t  *USBD_HID_GetDeviceQualifierDesc (uint16_t *length)
{
  *length = sizeof (USBD_HID_DeviceQualifierDesc);
 80035f0:	230a      	movs	r3, #10
 80035f2:	8003      	strh	r3, [r0, #0]
  return USBD_HID_DeviceQualifierDesc;
}
 80035f4:	4800      	ldr	r0, [pc, #0]	; (80035f8 <USBD_HID_GetDeviceQualifierDesc+0x8>)
 80035f6:	4770      	bx	lr
 80035f8:	200000b8 	.word	0x200000b8

080035fc <USBD_HID_Setup>:
{
 80035fc:	b538      	push	{r3, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80035fe:	780c      	ldrb	r4, [r1, #0]
  USBD_HID_HandleTypeDef     *hhid = pdev->pClassData;
 8003600:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8003604:	f014 0460 	ands.w	r4, r4, #96	; 0x60
{
 8003608:	4605      	mov	r5, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800360a:	d023      	beq.n	8003654 <USBD_HID_Setup+0x58>
 800360c:	2c20      	cmp	r4, #32
 800360e:	d10c      	bne.n	800362a <USBD_HID_Setup+0x2e>
    switch (req->bRequest)
 8003610:	784a      	ldrb	r2, [r1, #1]
 8003612:	3a02      	subs	r2, #2
 8003614:	2a09      	cmp	r2, #9
 8003616:	d817      	bhi.n	8003648 <USBD_HID_Setup+0x4c>
 8003618:	e8df f002 	tbb	[pc, r2]
 800361c:	16160913 	.word	0x16160913
 8003620:	16161616 	.word	0x16161616
 8003624:	050f      	.short	0x050f
      hhid->Protocol = (uint8_t)(req->wValue);
 8003626:	788a      	ldrb	r2, [r1, #2]
 8003628:	601a      	str	r2, [r3, #0]
  return USBD_OK;
 800362a:	2400      	movs	r4, #0
 800362c:	e010      	b.n	8003650 <USBD_HID_Setup+0x54>
      USBD_CtlSendData (pdev, 
 800362e:	2201      	movs	r2, #1
 8003630:	4619      	mov	r1, r3
      USBD_CtlSendData (pdev, 
 8003632:	4628      	mov	r0, r5
 8003634:	f000 fb42 	bl	8003cbc <USBD_CtlSendData>
 8003638:	e7f7      	b.n	800362a <USBD_HID_Setup+0x2e>
      hhid->IdleState = (uint8_t)(req->wValue >> 8);
 800363a:	884a      	ldrh	r2, [r1, #2]
 800363c:	0a12      	lsrs	r2, r2, #8
 800363e:	605a      	str	r2, [r3, #4]
 8003640:	e7f3      	b.n	800362a <USBD_HID_Setup+0x2e>
      USBD_CtlSendData (pdev, 
 8003642:	2201      	movs	r2, #1
 8003644:	1d19      	adds	r1, r3, #4
 8003646:	e7f4      	b.n	8003632 <USBD_HID_Setup+0x36>
      USBD_CtlError (pdev, req);
 8003648:	4628      	mov	r0, r5
 800364a:	f000 fb10 	bl	8003c6e <USBD_CtlError>
      return USBD_FAIL; 
 800364e:	2402      	movs	r4, #2
}
 8003650:	4620      	mov	r0, r4
 8003652:	bd38      	pop	{r3, r4, r5, pc}
    switch (req->bRequest)
 8003654:	784a      	ldrb	r2, [r1, #1]
 8003656:	2a0a      	cmp	r2, #10
 8003658:	d018      	beq.n	800368c <USBD_HID_Setup+0x90>
 800365a:	2a0b      	cmp	r2, #11
 800365c:	d01c      	beq.n	8003698 <USBD_HID_Setup+0x9c>
 800365e:	2a06      	cmp	r2, #6
 8003660:	d1f6      	bne.n	8003650 <USBD_HID_Setup+0x54>
      if( req->wValue >> 8 == HID_REPORT_DESC)
 8003662:	884b      	ldrh	r3, [r1, #2]
 8003664:	0a1b      	lsrs	r3, r3, #8
 8003666:	2b22      	cmp	r3, #34	; 0x22
 8003668:	d105      	bne.n	8003676 <USBD_HID_Setup+0x7a>
        len = MIN(HID_MOUSE_REPORT_DESC_SIZE , req->wLength);
 800366a:	88ca      	ldrh	r2, [r1, #6]
        pbuf = HID_MOUSE_ReportDesc;
 800366c:	490c      	ldr	r1, [pc, #48]	; (80036a0 <USBD_HID_Setup+0xa4>)
        len = MIN(HID_MOUSE_REPORT_DESC_SIZE , req->wLength);
 800366e:	2a4a      	cmp	r2, #74	; 0x4a
 8003670:	bf28      	it	cs
 8003672:	224a      	movcs	r2, #74	; 0x4a
 8003674:	e7dd      	b.n	8003632 <USBD_HID_Setup+0x36>
      else if( req->wValue >> 8 == HID_DESCRIPTOR_TYPE)
 8003676:	2b21      	cmp	r3, #33	; 0x21
 8003678:	d105      	bne.n	8003686 <USBD_HID_Setup+0x8a>
        len = MIN(USB_HID_DESC_SIZ , req->wLength);
 800367a:	88ca      	ldrh	r2, [r1, #6]
        pbuf = USBD_HID_Desc;   
 800367c:	4909      	ldr	r1, [pc, #36]	; (80036a4 <USBD_HID_Setup+0xa8>)
        len = MIN(USB_HID_DESC_SIZ , req->wLength);
 800367e:	2a09      	cmp	r2, #9
 8003680:	bf28      	it	cs
 8003682:	2209      	movcs	r2, #9
 8003684:	e7d5      	b.n	8003632 <USBD_HID_Setup+0x36>
  uint8_t  *pbuf = NULL;
 8003686:	4621      	mov	r1, r4
  uint16_t len = 0;
 8003688:	4622      	mov	r2, r4
 800368a:	e7d2      	b.n	8003632 <USBD_HID_Setup+0x36>
      USBD_CtlSendData (pdev,
 800368c:	2201      	movs	r2, #1
 800368e:	f103 0108 	add.w	r1, r3, #8
 8003692:	f000 fb13 	bl	8003cbc <USBD_CtlSendData>
      break;
 8003696:	e7db      	b.n	8003650 <USBD_HID_Setup+0x54>
      hhid->AltSetting = (uint8_t)(req->wValue);
 8003698:	788a      	ldrb	r2, [r1, #2]
 800369a:	609a      	str	r2, [r3, #8]
      break;
 800369c:	e7d8      	b.n	8003650 <USBD_HID_Setup+0x54>
 800369e:	bf00      	nop
 80036a0:	20000004 	.word	0x20000004
 80036a4:	200000ac 	.word	0x200000ac

080036a8 <USBD_HID_DeInit>:
{
 80036a8:	b510      	push	{r4, lr}
 80036aa:	4604      	mov	r4, r0
  USBD_LL_CloseEP(pdev,
 80036ac:	2104      	movs	r1, #4
 80036ae:	f002 fcf4 	bl	800609a <USBD_LL_CloseEP>
  if(pdev->pClassData != NULL)
 80036b2:	f8d4 0218 	ldr.w	r0, [r4, #536]	; 0x218
 80036b6:	b120      	cbz	r0, 80036c2 <USBD_HID_DeInit+0x1a>
    USBD_free(pdev->pClassData);
 80036b8:	f002 fdfe 	bl	80062b8 <free>
    pdev->pClassData = NULL;
 80036bc:	2300      	movs	r3, #0
 80036be:	f8c4 3218 	str.w	r3, [r4, #536]	; 0x218
}
 80036c2:	2000      	movs	r0, #0
 80036c4:	bd10      	pop	{r4, pc}

080036c6 <USBD_HID_Init>:
{
 80036c6:	b510      	push	{r4, lr}
  USBD_LL_OpenEP(pdev,
 80036c8:	2304      	movs	r3, #4
 80036ca:	2203      	movs	r2, #3
 80036cc:	2181      	movs	r1, #129	; 0x81
{
 80036ce:	4604      	mov	r4, r0
  USBD_LL_OpenEP(pdev,
 80036d0:	f002 fcd9 	bl	8006086 <USBD_LL_OpenEP>
  pdev->pClassData = USBD_malloc(sizeof (USBD_HID_HandleTypeDef));
 80036d4:	2010      	movs	r0, #16
 80036d6:	f002 fde7 	bl	80062a8 <malloc>
 80036da:	f8c4 0218 	str.w	r0, [r4, #536]	; 0x218
  if(pdev->pClassData == NULL)
 80036de:	b118      	cbz	r0, 80036e8 <USBD_HID_Init+0x22>
    ((USBD_HID_HandleTypeDef *)pdev->pClassData)->state = HID_IDLE;
 80036e0:	2300      	movs	r3, #0
 80036e2:	7303      	strb	r3, [r0, #12]
  uint8_t ret = 0;
 80036e4:	4618      	mov	r0, r3
 80036e6:	bd10      	pop	{r4, pc}
    ret = 1; 
 80036e8:	2001      	movs	r0, #1
}
 80036ea:	bd10      	pop	{r4, pc}

080036ec <USBD_HID_SendReport>:
{
 80036ec:	b510      	push	{r4, lr}
 80036ee:	4613      	mov	r3, r2
  if (pdev->dev_state == USBD_STATE_CONFIGURED )
 80036f0:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 80036f4:	2a03      	cmp	r2, #3
 80036f6:	d109      	bne.n	800370c <USBD_HID_SendReport+0x20>
  USBD_HID_HandleTypeDef     *hhid = pdev->pClassData;
 80036f8:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
    if(hhid->state == HID_IDLE)
 80036fc:	7b22      	ldrb	r2, [r4, #12]
 80036fe:	b92a      	cbnz	r2, 800370c <USBD_HID_SendReport+0x20>
      hhid->state = HID_BUSY;
 8003700:	2201      	movs	r2, #1
 8003702:	7322      	strb	r2, [r4, #12]
      USBD_LL_Transmit (pdev, 
 8003704:	460a      	mov	r2, r1
 8003706:	2181      	movs	r1, #129	; 0x81
 8003708:	f002 fcf6 	bl	80060f8 <USBD_LL_Transmit>
}
 800370c:	2000      	movs	r0, #0
 800370e:	bd10      	pop	{r4, pc}

08003710 <USBD_HID_GetPollingInterval>:
}
 8003710:	2001      	movs	r0, #1
 8003712:	4770      	bx	lr

08003714 <USBD_Init>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 8003714:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 8003716:	b180      	cbz	r0, 800373a <USBD_Init+0x26>
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 8003718:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800371c:	b113      	cbz	r3, 8003724 <USBD_Init+0x10>
  {
    pdev->pClass = NULL;
 800371e:	2300      	movs	r3, #0
 8003720:	f8c0 3214 	str.w	r3, [r0, #532]	; 0x214
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 8003724:	b109      	cbz	r1, 800372a <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 8003726:	f8c0 1210 	str.w	r1, [r0, #528]	; 0x210
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 800372a:	2301      	movs	r3, #1
 800372c:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  pdev->id = id;
 8003730:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 8003732:	f002 fc71 	bl	8006018 <USBD_LL_Init>
  
  return USBD_OK; 
 8003736:	2000      	movs	r0, #0
 8003738:	bd08      	pop	{r3, pc}
    return USBD_FAIL; 
 800373a:	2002      	movs	r0, #2
}
 800373c:	bd08      	pop	{r3, pc}

0800373e <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
 800373e:	b119      	cbz	r1, 8003748 <USBD_RegisterClass+0xa>
  {
    /* link the class tgo the USB Device handle */
    pdev->pClass = pclass;
 8003740:	f8c0 1214 	str.w	r1, [r0, #532]	; 0x214
    status = USBD_OK;
 8003744:	2000      	movs	r0, #0
 8003746:	4770      	bx	lr
  }
  else
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
 8003748:	2002      	movs	r0, #2
  }
  
  return status;
}
 800374a:	4770      	bx	lr

0800374c <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 800374c:	b508      	push	{r3, lr}
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
 800374e:	f002 fc93 	bl	8006078 <USBD_LL_Start>
  
  return USBD_OK;  
}
 8003752:	2000      	movs	r0, #0
 8003754:	bd08      	pop	{r3, pc}

08003756 <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8003756:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;
  
  if(pdev->pClass != NULL)
 8003758:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800375c:	b90b      	cbnz	r3, 8003762 <USBD_SetClassConfig+0xc>
  USBD_StatusTypeDef   ret = USBD_FAIL;
 800375e:	2002      	movs	r0, #2
 8003760:	bd08      	pop	{r3, pc}
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0)
 8003762:	681b      	ldr	r3, [r3, #0]
 8003764:	4798      	blx	r3
 8003766:	2800      	cmp	r0, #0
 8003768:	d1f9      	bne.n	800375e <USBD_SetClassConfig+0x8>
    {
      ret = USBD_OK;
    }
  }
  return ret; 
}
 800376a:	bd08      	pop	{r3, pc}

0800376c <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 800376c:	b508      	push	{r3, lr}
  /* Clear configuration  and Deinitialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);  
 800376e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003772:	685b      	ldr	r3, [r3, #4]
 8003774:	4798      	blx	r3
  return USBD_OK;
}
 8003776:	2000      	movs	r0, #0
 8003778:	bd08      	pop	{r3, pc}

0800377a <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 800377a:	b538      	push	{r3, r4, r5, lr}
 800377c:	4604      	mov	r4, r0

  USBD_ParseSetupRequest(&pdev->request, psetup);
 800377e:	f500 7502 	add.w	r5, r0, #520	; 0x208
 8003782:	4628      	mov	r0, r5
 8003784:	f000 fa5f 	bl	8003c46 <USBD_ParseSetupRequest>
  
  pdev->ep0_state = USBD_EP0_SETUP;
 8003788:	2301      	movs	r3, #1
  pdev->ep0_data_len = pdev->request.wLength;
  
  switch (pdev->request.bmRequest & 0x1F) 
 800378a:	f894 1208 	ldrb.w	r1, [r4, #520]	; 0x208
  pdev->ep0_state = USBD_EP0_SETUP;
 800378e:	f8c4 31f4 	str.w	r3, [r4, #500]	; 0x1f4
  pdev->ep0_data_len = pdev->request.wLength;
 8003792:	f8b4 320e 	ldrh.w	r3, [r4, #526]	; 0x20e
 8003796:	f8c4 31f8 	str.w	r3, [r4, #504]	; 0x1f8
  switch (pdev->request.bmRequest & 0x1F) 
 800379a:	f001 031f 	and.w	r3, r1, #31
 800379e:	2b01      	cmp	r3, #1
 80037a0:	d00e      	beq.n	80037c0 <USBD_LL_SetupStage+0x46>
 80037a2:	d307      	bcc.n	80037b4 <USBD_LL_SetupStage+0x3a>
 80037a4:	2b02      	cmp	r3, #2
 80037a6:	d010      	beq.n	80037ca <USBD_LL_SetupStage+0x50>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
 80037a8:	f001 0180 	and.w	r1, r1, #128	; 0x80
 80037ac:	4620      	mov	r0, r4
 80037ae:	f002 fc7b 	bl	80060a8 <USBD_LL_StallEP>
    break;
 80037b2:	e003      	b.n	80037bc <USBD_LL_SetupStage+0x42>
    USBD_StdDevReq (pdev, &pdev->request);
 80037b4:	4629      	mov	r1, r5
 80037b6:	4620      	mov	r0, r4
 80037b8:	f000 f8de 	bl	8003978 <USBD_StdDevReq>
  }  
  return USBD_OK;  
}
 80037bc:	2000      	movs	r0, #0
 80037be:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdItfReq(pdev, &pdev->request);
 80037c0:	4629      	mov	r1, r5
 80037c2:	4620      	mov	r0, r4
 80037c4:	f000 f9d2 	bl	8003b6c <USBD_StdItfReq>
    break;
 80037c8:	e7f8      	b.n	80037bc <USBD_LL_SetupStage+0x42>
    USBD_StdEPReq(pdev, &pdev->request);   
 80037ca:	4629      	mov	r1, r5
 80037cc:	4620      	mov	r0, r4
 80037ce:	f000 f9e5 	bl	8003b9c <USBD_StdEPReq>
    break;
 80037d2:	e7f3      	b.n	80037bc <USBD_LL_SetupStage+0x42>

080037d4 <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
 80037d4:	b538      	push	{r3, r4, r5, lr}
 80037d6:	4604      	mov	r4, r0
 80037d8:	4615      	mov	r5, r2
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
 80037da:	bb11      	cbnz	r1, 8003822 <USBD_LL_DataOutStage+0x4e>
  {
    pep = &pdev->ep_out[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 80037dc:	f8d0 31f4 	ldr.w	r3, [r0, #500]	; 0x1f4
 80037e0:	2b03      	cmp	r3, #3
 80037e2:	d10f      	bne.n	8003804 <USBD_LL_DataOutStage+0x30>
    {
      if(pep->rem_length > pep->maxpacket)
 80037e4:	f8d0 310c 	ldr.w	r3, [r0, #268]	; 0x10c
 80037e8:	f8d0 2110 	ldr.w	r2, [r0, #272]	; 0x110
 80037ec:	4293      	cmp	r3, r2
 80037ee:	d90b      	bls.n	8003808 <USBD_LL_DataOutStage+0x34>
      {
        pep->rem_length -=  pep->maxpacket;
 80037f0:	1a9b      	subs	r3, r3, r2
       
        USBD_CtlContinueRx (pdev, 
                            pdata,
                            MIN(pep->rem_length ,pep->maxpacket));
 80037f2:	429a      	cmp	r2, r3
 80037f4:	bf28      	it	cs
 80037f6:	461a      	movcs	r2, r3
        pep->rem_length -=  pep->maxpacket;
 80037f8:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
        USBD_CtlContinueRx (pdev, 
 80037fc:	b292      	uxth	r2, r2
 80037fe:	4629      	mov	r1, r5
 8003800:	f000 fa71 	bl	8003ce6 <USBD_CtlContinueRx>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataOut(pdev, epnum); 
  }  
  return USBD_OK;
}
 8003804:	2000      	movs	r0, #0
 8003806:	bd38      	pop	{r3, r4, r5, pc}
        if((pdev->pClass->EP0_RxReady != NULL)&&
 8003808:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800380c:	691b      	ldr	r3, [r3, #16]
 800380e:	b123      	cbz	r3, 800381a <USBD_LL_DataOutStage+0x46>
 8003810:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8003814:	2a03      	cmp	r2, #3
 8003816:	d100      	bne.n	800381a <USBD_LL_DataOutStage+0x46>
          pdev->pClass->EP0_RxReady(pdev); 
 8003818:	4798      	blx	r3
        USBD_CtlSendStatus(pdev);
 800381a:	4620      	mov	r0, r4
 800381c:	f000 fa6b 	bl	8003cf6 <USBD_CtlSendStatus>
 8003820:	e7f0      	b.n	8003804 <USBD_LL_DataOutStage+0x30>
  else if((pdev->pClass->DataOut != NULL)&&
 8003822:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003826:	699b      	ldr	r3, [r3, #24]
 8003828:	2b00      	cmp	r3, #0
 800382a:	d0eb      	beq.n	8003804 <USBD_LL_DataOutStage+0x30>
 800382c:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8003830:	2a03      	cmp	r2, #3
 8003832:	d1e7      	bne.n	8003804 <USBD_LL_DataOutStage+0x30>
    pdev->pClass->DataOut(pdev, epnum); 
 8003834:	4798      	blx	r3
 8003836:	e7e5      	b.n	8003804 <USBD_LL_DataOutStage+0x30>

08003838 <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
 8003838:	b538      	push	{r3, r4, r5, lr}
 800383a:	4604      	mov	r4, r0
 800383c:	4615      	mov	r5, r2
  USBD_EndpointTypeDef    *pep;
    
  if(epnum == 0) 
 800383e:	bbb1      	cbnz	r1, 80038ae <USBD_LL_DataInStage+0x76>
  {
    pep = &pdev->ep_in[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 8003840:	f8d0 31f4 	ldr.w	r3, [r0, #500]	; 0x1f4
 8003844:	2b02      	cmp	r3, #2
 8003846:	d109      	bne.n	800385c <USBD_LL_DataInStage+0x24>
    {
      if(pep->rem_length > pep->maxpacket)
 8003848:	69c3      	ldr	r3, [r0, #28]
 800384a:	6a02      	ldr	r2, [r0, #32]
 800384c:	4293      	cmp	r3, r2
 800384e:	d90e      	bls.n	800386e <USBD_LL_DataInStage+0x36>
      {
        pep->rem_length -=  pep->maxpacket;
 8003850:	1a9a      	subs	r2, r3, r2
 8003852:	61c2      	str	r2, [r0, #28]
        
        USBD_CtlContinueSendData (pdev, 
 8003854:	4629      	mov	r1, r5
 8003856:	b292      	uxth	r2, r2
 8003858:	f000 fa3d 	bl	8003cd6 <USBD_CtlContinueSendData>
          }          
          USBD_CtlReceiveStatus(pdev);
        }
      }
    }
    if (pdev->dev_test_mode == 1)
 800385c:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 8003860:	2b01      	cmp	r3, #1
 8003862:	d102      	bne.n	800386a <USBD_LL_DataInStage+0x32>
    {
      USBD_RunTestMode(pdev); 
      pdev->dev_test_mode = 0;
 8003864:	2300      	movs	r3, #0
 8003866:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum); 
  }  
  return USBD_OK;
}
 800386a:	2000      	movs	r0, #0
 800386c:	bd38      	pop	{r3, r4, r5, pc}
        if((pep->total_length % pep->maxpacket == 0) &&
 800386e:	6983      	ldr	r3, [r0, #24]
 8003870:	fbb3 f5f2 	udiv	r5, r3, r2
 8003874:	fb02 3515 	mls	r5, r2, r5, r3
 8003878:	b95d      	cbnz	r5, 8003892 <USBD_LL_DataInStage+0x5a>
 800387a:	429a      	cmp	r2, r3
 800387c:	d809      	bhi.n	8003892 <USBD_LL_DataInStage+0x5a>
           (pep->total_length >= pep->maxpacket) &&
 800387e:	f8d0 21f8 	ldr.w	r2, [r0, #504]	; 0x1f8
 8003882:	4293      	cmp	r3, r2
 8003884:	d205      	bcs.n	8003892 <USBD_LL_DataInStage+0x5a>
          USBD_CtlContinueSendData(pdev , NULL, 0);
 8003886:	462a      	mov	r2, r5
 8003888:	f000 fa25 	bl	8003cd6 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
 800388c:	f8c4 51f8 	str.w	r5, [r4, #504]	; 0x1f8
 8003890:	e7e4      	b.n	800385c <USBD_LL_DataInStage+0x24>
          if((pdev->pClass->EP0_TxSent != NULL)&&
 8003892:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8003896:	68db      	ldr	r3, [r3, #12]
 8003898:	b12b      	cbz	r3, 80038a6 <USBD_LL_DataInStage+0x6e>
 800389a:	f894 21fc 	ldrb.w	r2, [r4, #508]	; 0x1fc
 800389e:	2a03      	cmp	r2, #3
 80038a0:	d101      	bne.n	80038a6 <USBD_LL_DataInStage+0x6e>
            pdev->pClass->EP0_TxSent(pdev); 
 80038a2:	4620      	mov	r0, r4
 80038a4:	4798      	blx	r3
          USBD_CtlReceiveStatus(pdev);
 80038a6:	4620      	mov	r0, r4
 80038a8:	f000 fa30 	bl	8003d0c <USBD_CtlReceiveStatus>
 80038ac:	e7d6      	b.n	800385c <USBD_LL_DataInStage+0x24>
  else if((pdev->pClass->DataIn != NULL)&& 
 80038ae:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80038b2:	695b      	ldr	r3, [r3, #20]
 80038b4:	2b00      	cmp	r3, #0
 80038b6:	d0d8      	beq.n	800386a <USBD_LL_DataInStage+0x32>
 80038b8:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 80038bc:	2a03      	cmp	r2, #3
 80038be:	d1d4      	bne.n	800386a <USBD_LL_DataInStage+0x32>
    pdev->pClass->DataIn(pdev, epnum); 
 80038c0:	4798      	blx	r3
 80038c2:	e7d2      	b.n	800386a <USBD_LL_DataInStage+0x32>

080038c4 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 80038c4:	b538      	push	{r3, r4, r5, lr}
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 80038c6:	2200      	movs	r2, #0
{
 80038c8:	4604      	mov	r4, r0
  USBD_LL_OpenEP(pdev,
 80038ca:	4611      	mov	r1, r2
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 80038cc:	2540      	movs	r5, #64	; 0x40
  USBD_LL_OpenEP(pdev,
 80038ce:	2340      	movs	r3, #64	; 0x40
 80038d0:	f002 fbd9 	bl	8006086 <USBD_LL_OpenEP>
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 80038d4:	462b      	mov	r3, r5
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 80038d6:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
  USBD_LL_OpenEP(pdev,
 80038da:	2200      	movs	r2, #0
 80038dc:	2180      	movs	r1, #128	; 0x80
 80038de:	4620      	mov	r0, r4
 80038e0:	f002 fbd1 	bl	8006086 <USBD_LL_OpenEP>
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call usr call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 80038e4:	2301      	movs	r3, #1
 80038e6:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
  
  if (pdev->pClassData) 
 80038ea:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 80038ee:	6225      	str	r5, [r4, #32]
  if (pdev->pClassData) 
 80038f0:	b12b      	cbz	r3, 80038fe <USBD_LL_Reset+0x3a>
    pdev->pClass->DeInit(pdev, pdev->dev_config);  
 80038f2:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 80038f6:	7921      	ldrb	r1, [r4, #4]
 80038f8:	685b      	ldr	r3, [r3, #4]
 80038fa:	4620      	mov	r0, r4
 80038fc:	4798      	blx	r3
 
  
  return USBD_OK;
}
 80038fe:	2000      	movs	r0, #0
 8003900:	bd38      	pop	{r3, r4, r5, pc}

08003902 <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 8003902:	7401      	strb	r1, [r0, #16]
  return USBD_OK;
}
 8003904:	2000      	movs	r0, #0
 8003906:	4770      	bx	lr

08003908 <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 8003908:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800390c:	f880 31fd 	strb.w	r3, [r0, #509]	; 0x1fd
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8003910:	2304      	movs	r3, #4
 8003912:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8003916:	2000      	movs	r0, #0
 8003918:	4770      	bx	lr

0800391a <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_state = pdev->dev_old_state;  
 800391a:	f890 31fd 	ldrb.w	r3, [r0, #509]	; 0x1fd
 800391e:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8003922:	2000      	movs	r0, #0
 8003924:	4770      	bx	lr

08003926 <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
 8003926:	b508      	push	{r3, lr}
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 8003928:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 800392c:	2a03      	cmp	r2, #3
 800392e:	d104      	bne.n	800393a <USBD_LL_SOF+0x14>
  {
    if(pdev->pClass->SOF != NULL)
 8003930:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003934:	69db      	ldr	r3, [r3, #28]
 8003936:	b103      	cbz	r3, 800393a <USBD_LL_SOF+0x14>
    {
      pdev->pClass->SOF(pdev);
 8003938:	4798      	blx	r3
    }
  }
  return USBD_OK;
}
 800393a:	2000      	movs	r0, #0
 800393c:	bd08      	pop	{r3, pc}

0800393e <USBD_LL_IsoINIncomplete>:
 800393e:	2000      	movs	r0, #0
 8003940:	4770      	bx	lr

08003942 <USBD_LL_IsoOUTIncomplete>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
  return USBD_OK;
}
 8003942:	2000      	movs	r0, #0
 8003944:	4770      	bx	lr

08003946 <USBD_LL_DevConnected>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef  *pdev)
{
  return USBD_OK;
}
 8003946:	2000      	movs	r0, #0
 8003948:	4770      	bx	lr

0800394a <USBD_LL_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
{
 800394a:	b508      	push	{r3, lr}
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800394c:	2201      	movs	r2, #1
 800394e:	f880 21fc 	strb.w	r2, [r0, #508]	; 0x1fc
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8003952:	f8d0 2214 	ldr.w	r2, [r0, #532]	; 0x214
 8003956:	7901      	ldrb	r1, [r0, #4]
 8003958:	6852      	ldr	r2, [r2, #4]
 800395a:	4790      	blx	r2
   
  return USBD_OK;
}
 800395c:	2000      	movs	r0, #0
 800395e:	bd08      	pop	{r3, pc}

08003960 <USBD_CtlError.constprop.0>:
* @param  pdev: device instance
* @param  req: usb request
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
 8003960:	b510      	push	{r4, lr}
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80);
 8003962:	2180      	movs	r1, #128	; 0x80
void USBD_CtlError( USBD_HandleTypeDef *pdev ,
 8003964:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80);
 8003966:	f002 fb9f 	bl	80060a8 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 800396a:	4620      	mov	r0, r4
 800396c:	2100      	movs	r1, #0
}
 800396e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_StallEP(pdev , 0);
 8003972:	f002 bb99 	b.w	80060a8 <USBD_LL_StallEP>
	...

08003978 <USBD_StdDevReq>:
{
 8003978:	b537      	push	{r0, r1, r2, r4, r5, lr}
  switch (req->bRequest) 
 800397a:	784b      	ldrb	r3, [r1, #1]
{
 800397c:	4604      	mov	r4, r0
 800397e:	460d      	mov	r5, r1
  switch (req->bRequest) 
 8003980:	2b09      	cmp	r3, #9
 8003982:	d879      	bhi.n	8003a78 <USBD_StdDevReq+0x100>
 8003984:	e8df f013 	tbh	[pc, r3, lsl #1]
 8003988:	00e500c9 	.word	0x00e500c9
 800398c:	00d90078 	.word	0x00d90078
 8003990:	006d0078 	.word	0x006d0078
 8003994:	0078000a 	.word	0x0078000a
 8003998:	008d00b9 	.word	0x008d00b9
  switch (req->wValue >> 8)
 800399c:	884b      	ldrh	r3, [r1, #2]
 800399e:	0a1a      	lsrs	r2, r3, #8
 80039a0:	3a01      	subs	r2, #1
 80039a2:	2a06      	cmp	r2, #6
 80039a4:	d868      	bhi.n	8003a78 <USBD_StdDevReq+0x100>
 80039a6:	e8df f002 	tbb	[pc, r2]
 80039aa:	1c04      	.short	0x1c04
 80039ac:	49676729 	.word	0x49676729
 80039b0:	52          	.byte	0x52
 80039b1:	00          	.byte	0x00
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 80039b2:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 80039b6:	681b      	ldr	r3, [r3, #0]
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 80039b8:	7c20      	ldrb	r0, [r4, #16]
 80039ba:	f10d 0106 	add.w	r1, sp, #6
 80039be:	4798      	blx	r3
  if((len != 0)&& (req->wLength != 0))
 80039c0:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 80039c4:	2a00      	cmp	r2, #0
 80039c6:	d067      	beq.n	8003a98 <USBD_StdDevReq+0x120>
 80039c8:	88eb      	ldrh	r3, [r5, #6]
 80039ca:	2b00      	cmp	r3, #0
 80039cc:	d064      	beq.n	8003a98 <USBD_StdDevReq+0x120>
    len = MIN(len , req->wLength);
 80039ce:	429a      	cmp	r2, r3
 80039d0:	bf28      	it	cs
 80039d2:	461a      	movcs	r2, r3
 80039d4:	f8ad 2006 	strh.w	r2, [sp, #6]
    USBD_CtlSendData (pdev, 
 80039d8:	4601      	mov	r1, r0
    USBD_CtlSendData (pdev, 
 80039da:	4620      	mov	r0, r4
 80039dc:	f000 f96e 	bl	8003cbc <USBD_CtlSendData>
 80039e0:	e05a      	b.n	8003a98 <USBD_StdDevReq+0x120>
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
 80039e2:	7c02      	ldrb	r2, [r0, #16]
 80039e4:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80039e8:	b932      	cbnz	r2, 80039f8 <USBD_StdDevReq+0x80>
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 80039ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 80039ec:	f10d 0006 	add.w	r0, sp, #6
 80039f0:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 80039f2:	2302      	movs	r3, #2
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 80039f4:	7043      	strb	r3, [r0, #1]
 80039f6:	e7e3      	b.n	80039c0 <USBD_StdDevReq+0x48>
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 80039f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80039fa:	e7f7      	b.n	80039ec <USBD_StdDevReq+0x74>
    switch ((uint8_t)(req->wValue))
 80039fc:	b2db      	uxtb	r3, r3
 80039fe:	2b05      	cmp	r3, #5
 8003a00:	d83a      	bhi.n	8003a78 <USBD_StdDevReq+0x100>
 8003a02:	e8df f003 	tbb	[pc, r3]
 8003a06:	0703      	.short	0x0703
 8003a08:	17130f0b 	.word	0x17130f0b
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 8003a0c:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003a10:	685b      	ldr	r3, [r3, #4]
 8003a12:	e7d1      	b.n	80039b8 <USBD_StdDevReq+0x40>
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8003a14:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003a18:	689b      	ldr	r3, [r3, #8]
 8003a1a:	e7cd      	b.n	80039b8 <USBD_StdDevReq+0x40>
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8003a1c:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003a20:	68db      	ldr	r3, [r3, #12]
 8003a22:	e7c9      	b.n	80039b8 <USBD_StdDevReq+0x40>
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8003a24:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003a28:	691b      	ldr	r3, [r3, #16]
 8003a2a:	e7c5      	b.n	80039b8 <USBD_StdDevReq+0x40>
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8003a2c:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003a30:	695b      	ldr	r3, [r3, #20]
 8003a32:	e7c1      	b.n	80039b8 <USBD_StdDevReq+0x40>
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8003a34:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003a38:	699b      	ldr	r3, [r3, #24]
 8003a3a:	e7bd      	b.n	80039b8 <USBD_StdDevReq+0x40>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8003a3c:	7c03      	ldrb	r3, [r0, #16]
 8003a3e:	b9db      	cbnz	r3, 8003a78 <USBD_StdDevReq+0x100>
      pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8003a40:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003a44:	f10d 0006 	add.w	r0, sp, #6
 8003a48:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003a4a:	4798      	blx	r3
 8003a4c:	e7b8      	b.n	80039c0 <USBD_StdDevReq+0x48>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8003a4e:	7c03      	ldrb	r3, [r0, #16]
 8003a50:	b993      	cbnz	r3, 8003a78 <USBD_StdDevReq+0x100>
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8003a52:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003a56:	f10d 0006 	add.w	r0, sp, #6
 8003a5a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003a5c:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8003a5e:	2307      	movs	r3, #7
 8003a60:	e7c8      	b.n	80039f4 <USBD_StdDevReq+0x7c>
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 8003a62:	888b      	ldrh	r3, [r1, #4]
 8003a64:	b943      	cbnz	r3, 8003a78 <USBD_StdDevReq+0x100>
 8003a66:	88cb      	ldrh	r3, [r1, #6]
 8003a68:	b933      	cbnz	r3, 8003a78 <USBD_StdDevReq+0x100>
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8003a6a:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8003a6e:	788d      	ldrb	r5, [r1, #2]
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8003a70:	2b03      	cmp	r3, #3
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8003a72:	f005 057f 	and.w	r5, r5, #127	; 0x7f
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8003a76:	d103      	bne.n	8003a80 <USBD_StdDevReq+0x108>
    USBD_CtlError(pdev , req);
 8003a78:	4620      	mov	r0, r4
 8003a7a:	f7ff ff71 	bl	8003960 <USBD_CtlError.constprop.0>
    break;
 8003a7e:	e00b      	b.n	8003a98 <USBD_StdDevReq+0x120>
      pdev->dev_address = dev_addr;
 8003a80:	f880 51fe 	strb.w	r5, [r0, #510]	; 0x1fe
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 8003a84:	4629      	mov	r1, r5
 8003a86:	f002 fb30 	bl	80060ea <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
 8003a8a:	4620      	mov	r0, r4
 8003a8c:	f000 f933 	bl	8003cf6 <USBD_CtlSendStatus>
      if (dev_addr != 0) 
 8003a90:	b12d      	cbz	r5, 8003a9e <USBD_StdDevReq+0x126>
        pdev->dev_state  = USBD_STATE_ADDRESSED;
 8003a92:	2302      	movs	r3, #2
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 8003a94:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
}
 8003a98:	2000      	movs	r0, #0
 8003a9a:	b003      	add	sp, #12
 8003a9c:	bd30      	pop	{r4, r5, pc}
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 8003a9e:	2301      	movs	r3, #1
 8003aa0:	e7f8      	b.n	8003a94 <USBD_StdDevReq+0x11c>
  cfgidx = (uint8_t)(req->wValue);                 
 8003aa2:	7889      	ldrb	r1, [r1, #2]
 8003aa4:	4d30      	ldr	r5, [pc, #192]	; (8003b68 <USBD_StdDevReq+0x1f0>)
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8003aa6:	2901      	cmp	r1, #1
  cfgidx = (uint8_t)(req->wValue);                 
 8003aa8:	7029      	strb	r1, [r5, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8003aaa:	d8e5      	bhi.n	8003a78 <USBD_StdDevReq+0x100>
    switch (pdev->dev_state) 
 8003aac:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003ab0:	2b02      	cmp	r3, #2
 8003ab2:	d00c      	beq.n	8003ace <USBD_StdDevReq+0x156>
 8003ab4:	2b03      	cmp	r3, #3
 8003ab6:	d1df      	bne.n	8003a78 <USBD_StdDevReq+0x100>
      if (cfgidx == 0) 
 8003ab8:	b9b1      	cbnz	r1, 8003ae8 <USBD_StdDevReq+0x170>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8003aba:	2302      	movs	r3, #2
 8003abc:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        pdev->dev_config = cfgidx;          
 8003ac0:	6041      	str	r1, [r0, #4]
        USBD_ClrClassConfig(pdev , cfgidx);
 8003ac2:	f7ff fe53 	bl	800376c <USBD_ClrClassConfig>
      USBD_CtlSendStatus(pdev);
 8003ac6:	4620      	mov	r0, r4
 8003ac8:	f000 f915 	bl	8003cf6 <USBD_CtlSendStatus>
 8003acc:	e7e4      	b.n	8003a98 <USBD_StdDevReq+0x120>
      if (cfgidx) 
 8003ace:	2900      	cmp	r1, #0
 8003ad0:	d0f9      	beq.n	8003ac6 <USBD_StdDevReq+0x14e>
        pdev->dev_config = cfgidx;
 8003ad2:	2101      	movs	r1, #1
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8003ad4:	2303      	movs	r3, #3
        pdev->dev_config = cfgidx;
 8003ad6:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8003ad8:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8003adc:	4620      	mov	r0, r4
 8003ade:	f7ff fe3a 	bl	8003756 <USBD_SetClassConfig>
 8003ae2:	2802      	cmp	r0, #2
 8003ae4:	d1ef      	bne.n	8003ac6 <USBD_StdDevReq+0x14e>
 8003ae6:	e7c7      	b.n	8003a78 <USBD_StdDevReq+0x100>
      else  if (cfgidx != pdev->dev_config) 
 8003ae8:	6841      	ldr	r1, [r0, #4]
 8003aea:	2901      	cmp	r1, #1
 8003aec:	d0eb      	beq.n	8003ac6 <USBD_StdDevReq+0x14e>
        USBD_ClrClassConfig(pdev , pdev->dev_config);
 8003aee:	b2c9      	uxtb	r1, r1
 8003af0:	f7ff fe3c 	bl	800376c <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 8003af4:	7829      	ldrb	r1, [r5, #0]
 8003af6:	6061      	str	r1, [r4, #4]
 8003af8:	e7f0      	b.n	8003adc <USBD_StdDevReq+0x164>
  if (req->wLength != 1) 
 8003afa:	88ca      	ldrh	r2, [r1, #6]
 8003afc:	2a01      	cmp	r2, #1
 8003afe:	d1bb      	bne.n	8003a78 <USBD_StdDevReq+0x100>
    switch (pdev->dev_state )  
 8003b00:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003b04:	2b02      	cmp	r3, #2
 8003b06:	d003      	beq.n	8003b10 <USBD_StdDevReq+0x198>
 8003b08:	2b03      	cmp	r3, #3
 8003b0a:	d1b5      	bne.n	8003a78 <USBD_StdDevReq+0x100>
      USBD_CtlSendData (pdev, 
 8003b0c:	1d01      	adds	r1, r0, #4
 8003b0e:	e764      	b.n	80039da <USBD_StdDevReq+0x62>
      pdev->dev_default_config = 0;
 8003b10:	4601      	mov	r1, r0
 8003b12:	2300      	movs	r3, #0
 8003b14:	f841 3f08 	str.w	r3, [r1, #8]!
 8003b18:	e75f      	b.n	80039da <USBD_StdDevReq+0x62>
  switch (pdev->dev_state) 
 8003b1a:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003b1e:	3b02      	subs	r3, #2
 8003b20:	2b01      	cmp	r3, #1
 8003b22:	d8a9      	bhi.n	8003a78 <USBD_StdDevReq+0x100>
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 8003b24:	2301      	movs	r3, #1
 8003b26:	60c3      	str	r3, [r0, #12]
    if (pdev->dev_remote_wakeup) 
 8003b28:	f8d0 3204 	ldr.w	r3, [r0, #516]	; 0x204
 8003b2c:	b10b      	cbz	r3, 8003b32 <USBD_StdDevReq+0x1ba>
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 8003b2e:	2303      	movs	r3, #3
 8003b30:	60c3      	str	r3, [r0, #12]
    USBD_CtlSendData (pdev, 
 8003b32:	2202      	movs	r2, #2
 8003b34:	f104 010c 	add.w	r1, r4, #12
 8003b38:	e74f      	b.n	80039da <USBD_StdDevReq+0x62>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8003b3a:	884b      	ldrh	r3, [r1, #2]
 8003b3c:	2b01      	cmp	r3, #1
 8003b3e:	d1ab      	bne.n	8003a98 <USBD_StdDevReq+0x120>
      pdev->dev_remote_wakeup = 0; 
 8003b40:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
      pdev->pClass->Setup (pdev, req);   
 8003b44:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8003b48:	4629      	mov	r1, r5
 8003b4a:	689b      	ldr	r3, [r3, #8]
 8003b4c:	4620      	mov	r0, r4
 8003b4e:	4798      	blx	r3
 8003b50:	e7b9      	b.n	8003ac6 <USBD_StdDevReq+0x14e>
  switch (pdev->dev_state)
 8003b52:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003b56:	3b02      	subs	r3, #2
 8003b58:	2b01      	cmp	r3, #1
 8003b5a:	d88d      	bhi.n	8003a78 <USBD_StdDevReq+0x100>
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 8003b5c:	884b      	ldrh	r3, [r1, #2]
 8003b5e:	2b01      	cmp	r3, #1
 8003b60:	d19a      	bne.n	8003a98 <USBD_StdDevReq+0x120>
      pdev->dev_remote_wakeup = 0; 
 8003b62:	2300      	movs	r3, #0
 8003b64:	e7ec      	b.n	8003b40 <USBD_StdDevReq+0x1c8>
 8003b66:	bf00      	nop
 8003b68:	20000254 	.word	0x20000254

08003b6c <USBD_StdItfReq>:
{
 8003b6c:	b538      	push	{r3, r4, r5, lr}
  switch (pdev->dev_state) 
 8003b6e:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003b72:	2b03      	cmp	r3, #3
{
 8003b74:	4604      	mov	r4, r0
 8003b76:	460d      	mov	r5, r1
  switch (pdev->dev_state) 
 8003b78:	d10d      	bne.n	8003b96 <USBD_StdItfReq+0x2a>
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
 8003b7a:	790b      	ldrb	r3, [r1, #4]
 8003b7c:	2b01      	cmp	r3, #1
 8003b7e:	d80a      	bhi.n	8003b96 <USBD_StdItfReq+0x2a>
      pdev->pClass->Setup (pdev, req); 
 8003b80:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003b84:	689b      	ldr	r3, [r3, #8]
 8003b86:	4798      	blx	r3
      if((req->wLength == 0)&& (ret == USBD_OK))
 8003b88:	88eb      	ldrh	r3, [r5, #6]
 8003b8a:	b913      	cbnz	r3, 8003b92 <USBD_StdItfReq+0x26>
         USBD_CtlSendStatus(pdev);
 8003b8c:	4620      	mov	r0, r4
 8003b8e:	f000 f8b2 	bl	8003cf6 <USBD_CtlSendStatus>
}
 8003b92:	2000      	movs	r0, #0
 8003b94:	bd38      	pop	{r3, r4, r5, pc}
     USBD_CtlError(pdev , req);
 8003b96:	f7ff fee3 	bl	8003960 <USBD_CtlError.constprop.0>
    break;
 8003b9a:	e7fa      	b.n	8003b92 <USBD_StdItfReq+0x26>

08003b9c <USBD_StdEPReq>:
{
 8003b9c:	b538      	push	{r3, r4, r5, lr}
 8003b9e:	460d      	mov	r5, r1
  ep_addr  = LOBYTE(req->wIndex);   
 8003ba0:	888b      	ldrh	r3, [r1, #4]
  switch (req->bRequest) 
 8003ba2:	786a      	ldrb	r2, [r5, #1]
 8003ba4:	2a01      	cmp	r2, #1
{
 8003ba6:	4604      	mov	r4, r0
  ep_addr  = LOBYTE(req->wIndex);   
 8003ba8:	b2d9      	uxtb	r1, r3
  switch (req->bRequest) 
 8003baa:	d01c      	beq.n	8003be6 <USBD_StdEPReq+0x4a>
 8003bac:	d329      	bcc.n	8003c02 <USBD_StdEPReq+0x66>
 8003bae:	2a03      	cmp	r2, #3
 8003bb0:	d117      	bne.n	8003be2 <USBD_StdEPReq+0x46>
    switch (pdev->dev_state) 
 8003bb2:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003bb6:	2b02      	cmp	r3, #2
 8003bb8:	d03e      	beq.n	8003c38 <USBD_StdEPReq+0x9c>
 8003bba:	2b03      	cmp	r3, #3
 8003bbc:	d002      	beq.n	8003bc4 <USBD_StdEPReq+0x28>
      USBD_CtlError(pdev , req);
 8003bbe:	f7ff fecf 	bl	8003960 <USBD_CtlError.constprop.0>
      break;
 8003bc2:	e00e      	b.n	8003be2 <USBD_StdEPReq+0x46>
      if (req->wValue == USB_FEATURE_EP_HALT)
 8003bc4:	886b      	ldrh	r3, [r5, #2]
 8003bc6:	b91b      	cbnz	r3, 8003bd0 <USBD_StdEPReq+0x34>
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8003bc8:	064b      	lsls	r3, r1, #25
 8003bca:	d001      	beq.n	8003bd0 <USBD_StdEPReq+0x34>
          USBD_LL_StallEP(pdev , ep_addr);
 8003bcc:	f002 fa6c 	bl	80060a8 <USBD_LL_StallEP>
          pdev->pClass->Setup (pdev, req);
 8003bd0:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8003bd4:	4629      	mov	r1, r5
 8003bd6:	689b      	ldr	r3, [r3, #8]
 8003bd8:	4620      	mov	r0, r4
 8003bda:	4798      	blx	r3
        USBD_CtlSendStatus(pdev);
 8003bdc:	4620      	mov	r0, r4
 8003bde:	f000 f88a 	bl	8003cf6 <USBD_CtlSendStatus>
}
 8003be2:	2000      	movs	r0, #0
 8003be4:	bd38      	pop	{r3, r4, r5, pc}
    switch (pdev->dev_state) 
 8003be6:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003bea:	2b02      	cmp	r3, #2
 8003bec:	d024      	beq.n	8003c38 <USBD_StdEPReq+0x9c>
 8003bee:	2b03      	cmp	r3, #3
 8003bf0:	d1e5      	bne.n	8003bbe <USBD_StdEPReq+0x22>
      if (req->wValue == USB_FEATURE_EP_HALT)
 8003bf2:	886b      	ldrh	r3, [r5, #2]
 8003bf4:	2b00      	cmp	r3, #0
 8003bf6:	d1f4      	bne.n	8003be2 <USBD_StdEPReq+0x46>
        if ((ep_addr & 0x7F) != 0x00) 
 8003bf8:	064a      	lsls	r2, r1, #25
 8003bfa:	d0ef      	beq.n	8003bdc <USBD_StdEPReq+0x40>
          USBD_LL_ClearStallEP(pdev , ep_addr);
 8003bfc:	f002 fa5b 	bl	80060b6 <USBD_LL_ClearStallEP>
 8003c00:	e7e6      	b.n	8003bd0 <USBD_StdEPReq+0x34>
    switch (pdev->dev_state) 
 8003c02:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8003c06:	2a02      	cmp	r2, #2
 8003c08:	d016      	beq.n	8003c38 <USBD_StdEPReq+0x9c>
 8003c0a:	2a03      	cmp	r2, #3
 8003c0c:	d1d7      	bne.n	8003bbe <USBD_StdEPReq+0x22>
 8003c0e:	f001 057f 	and.w	r5, r1, #127	; 0x7f
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 8003c12:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003c16:	eb00 1505 	add.w	r5, r0, r5, lsl #4
 8003c1a:	bf14      	ite	ne
 8003c1c:	3514      	addne	r5, #20
 8003c1e:	f505 7582 	addeq.w	r5, r5, #260	; 0x104
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 8003c22:	f002 fa4f 	bl	80060c4 <USBD_LL_IsStallEP>
 8003c26:	b160      	cbz	r0, 8003c42 <USBD_StdEPReq+0xa6>
        pep->status = 0x0001;     
 8003c28:	2301      	movs	r3, #1
 8003c2a:	602b      	str	r3, [r5, #0]
      USBD_CtlSendData (pdev,
 8003c2c:	2202      	movs	r2, #2
 8003c2e:	4629      	mov	r1, r5
 8003c30:	4620      	mov	r0, r4
 8003c32:	f000 f843 	bl	8003cbc <USBD_CtlSendData>
      break;
 8003c36:	e7d4      	b.n	8003be2 <USBD_StdEPReq+0x46>
      if ((ep_addr & 0x7F) != 0x00) 
 8003c38:	064b      	lsls	r3, r1, #25
 8003c3a:	d0d2      	beq.n	8003be2 <USBD_StdEPReq+0x46>
        USBD_LL_StallEP(pdev , ep_addr);
 8003c3c:	f002 fa34 	bl	80060a8 <USBD_LL_StallEP>
 8003c40:	e7cf      	b.n	8003be2 <USBD_StdEPReq+0x46>
        pep->status = 0x0000;  
 8003c42:	6028      	str	r0, [r5, #0]
 8003c44:	e7f2      	b.n	8003c2c <USBD_StdEPReq+0x90>

08003c46 <USBD_ParseSetupRequest>:
  req->bmRequest     = *(uint8_t *)  (pdata);
 8003c46:	780b      	ldrb	r3, [r1, #0]
 8003c48:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 8003c4a:	784b      	ldrb	r3, [r1, #1]
 8003c4c:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 8003c4e:	78ca      	ldrb	r2, [r1, #3]
 8003c50:	788b      	ldrb	r3, [r1, #2]
 8003c52:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8003c56:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 8003c58:	794a      	ldrb	r2, [r1, #5]
 8003c5a:	790b      	ldrb	r3, [r1, #4]
 8003c5c:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8003c60:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 8003c62:	79ca      	ldrb	r2, [r1, #7]
 8003c64:	798b      	ldrb	r3, [r1, #6]
 8003c66:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8003c6a:	80c3      	strh	r3, [r0, #6]
 8003c6c:	4770      	bx	lr

08003c6e <USBD_CtlError>:
{
 8003c6e:	b510      	push	{r4, lr}
  USBD_LL_StallEP(pdev , 0x80);
 8003c70:	2180      	movs	r1, #128	; 0x80
{
 8003c72:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80);
 8003c74:	f002 fa18 	bl	80060a8 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 8003c78:	4620      	mov	r0, r4
 8003c7a:	2100      	movs	r1, #0
}
 8003c7c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_StallEP(pdev , 0);
 8003c80:	f002 ba12 	b.w	80060a8 <USBD_LL_StallEP>

08003c84 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8003c84:	b530      	push	{r4, r5, lr}
  uint8_t idx = 0;
  
  if (desc != NULL) 
 8003c86:	b188      	cbz	r0, 8003cac <USBD_GetString+0x28>
 8003c88:	4605      	mov	r5, r0
 8003c8a:	1a2b      	subs	r3, r5, r0
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
 8003c8c:	f815 4b01 	ldrb.w	r4, [r5], #1
 8003c90:	b2db      	uxtb	r3, r3
 8003c92:	2c00      	cmp	r4, #0
 8003c94:	d1f9      	bne.n	8003c8a <USBD_GetString+0x6>
    *len =  USBD_GetLen(desc) * 2 + 2;    
 8003c96:	005b      	lsls	r3, r3, #1
 8003c98:	3302      	adds	r3, #2
 8003c9a:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
 8003c9c:	700b      	strb	r3, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 8003c9e:	2303      	movs	r3, #3
 8003ca0:	704b      	strb	r3, [r1, #1]
 8003ca2:	3801      	subs	r0, #1
 8003ca4:	2302      	movs	r3, #2
    while (*desc != '\0') 
 8003ca6:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 8003caa:	b905      	cbnz	r5, 8003cae <USBD_GetString+0x2a>
 8003cac:	bd30      	pop	{r4, r5, pc}
      unicode[idx++] = *desc++;
 8003cae:	1c5a      	adds	r2, r3, #1
 8003cb0:	b2d2      	uxtb	r2, r2
 8003cb2:	54cd      	strb	r5, [r1, r3]
      unicode[idx++] =  0x00;
 8003cb4:	3302      	adds	r3, #2
 8003cb6:	b2db      	uxtb	r3, r3
 8003cb8:	548c      	strb	r4, [r1, r2]
 8003cba:	e7f4      	b.n	8003ca6 <USBD_GetString+0x22>

08003cbc <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 8003cbc:	b510      	push	{r4, lr}
 8003cbe:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 8003cc0:	2202      	movs	r2, #2
 8003cc2:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_in[0].total_length = len;
 8003cc6:	6183      	str	r3, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 8003cc8:	460a      	mov	r2, r1
  pdev->ep_in[0].rem_length   = len;
 8003cca:	61c3      	str	r3, [r0, #28]
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 8003ccc:	2100      	movs	r1, #0
 8003cce:	f002 fa13 	bl	80060f8 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8003cd2:	2000      	movs	r0, #0
 8003cd4:	bd10      	pop	{r4, pc}

08003cd6 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 8003cd6:	b508      	push	{r3, lr}
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
 8003cd8:	4613      	mov	r3, r2
 8003cda:	460a      	mov	r2, r1
 8003cdc:	2100      	movs	r1, #0
 8003cde:	f002 fa0b 	bl	80060f8 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8003ce2:	2000      	movs	r0, #0
 8003ce4:	bd08      	pop	{r3, pc}

08003ce6 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8003ce6:	b508      	push	{r3, lr}

  USBD_LL_PrepareReceive (pdev,
 8003ce8:	4613      	mov	r3, r2
 8003cea:	460a      	mov	r2, r1
 8003cec:	2100      	movs	r1, #0
 8003cee:	f002 fa0a 	bl	8006106 <USBD_LL_PrepareReceive>
                          0,                     
                          pbuf,                         
                          len);
  return USBD_OK;
}
 8003cf2:	2000      	movs	r0, #0
 8003cf4:	bd08      	pop	{r3, pc}

08003cf6 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
 8003cf6:	b508      	push	{r3, lr}

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8003cf8:	2304      	movs	r3, #4
 8003cfa:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 8003cfe:	2300      	movs	r3, #0
 8003d00:	461a      	mov	r2, r3
 8003d02:	4619      	mov	r1, r3
 8003d04:	f002 f9f8 	bl	80060f8 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8003d08:	2000      	movs	r0, #0
 8003d0a:	bd08      	pop	{r3, pc}

08003d0c <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
 8003d0c:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 8003d0e:	2305      	movs	r3, #5
 8003d10:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
 8003d14:	2300      	movs	r3, #0
 8003d16:	461a      	mov	r2, r3
 8003d18:	4619      	mov	r1, r3
 8003d1a:	f002 f9f4 	bl	8006106 <USBD_LL_PrepareReceive>
                    0,
                    NULL,
                    0);  

  return USBD_OK;
}
 8003d1e:	2000      	movs	r0, #0
 8003d20:	bd08      	pop	{r3, pc}

08003d22 <ili9341_GetLcdPixelWidth>:
  */
uint16_t ili9341_GetLcdPixelWidth(void)
{
  /* Return LCD PIXEL WIDTH */
  return ILI9341_LCD_PIXEL_WIDTH;
}
 8003d22:	20f0      	movs	r0, #240	; 0xf0
 8003d24:	4770      	bx	lr

08003d26 <ili9341_GetLcdPixelHeight>:
  */
uint16_t ili9341_GetLcdPixelHeight(void)
{
  /* Return LCD PIXEL HEIGHT */
  return ILI9341_LCD_PIXEL_HEIGHT;
}
 8003d26:	f44f 70a0 	mov.w	r0, #320	; 0x140
 8003d2a:	4770      	bx	lr

08003d2c <ili9341_DisplayOn>:
  LCD_IO_WriteReg(LCD_Reg);
 8003d2c:	2029      	movs	r0, #41	; 0x29
 8003d2e:	f000 bdc1 	b.w	80048b4 <LCD_IO_WriteReg>

08003d32 <ili9341_DisplayOff>:
 8003d32:	2028      	movs	r0, #40	; 0x28
 8003d34:	f000 bdbe 	b.w	80048b4 <LCD_IO_WriteReg>

08003d38 <ili9341_Init>:
{
 8003d38:	b508      	push	{r3, lr}
  LCD_IO_Init();
 8003d3a:	f000 fd55 	bl	80047e8 <LCD_IO_Init>
  LCD_IO_WriteReg(LCD_Reg);
 8003d3e:	20ca      	movs	r0, #202	; 0xca
 8003d40:	f000 fdb8 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003d44:	20c3      	movs	r0, #195	; 0xc3
 8003d46:	f000 fd99 	bl	800487c <LCD_IO_WriteData>
 8003d4a:	2008      	movs	r0, #8
 8003d4c:	f000 fd96 	bl	800487c <LCD_IO_WriteData>
 8003d50:	2050      	movs	r0, #80	; 0x50
 8003d52:	f000 fd93 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003d56:	20cf      	movs	r0, #207	; 0xcf
 8003d58:	f000 fdac 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003d5c:	2000      	movs	r0, #0
 8003d5e:	f000 fd8d 	bl	800487c <LCD_IO_WriteData>
 8003d62:	20c1      	movs	r0, #193	; 0xc1
 8003d64:	f000 fd8a 	bl	800487c <LCD_IO_WriteData>
 8003d68:	2030      	movs	r0, #48	; 0x30
 8003d6a:	f000 fd87 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003d6e:	20ed      	movs	r0, #237	; 0xed
 8003d70:	f000 fda0 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003d74:	2064      	movs	r0, #100	; 0x64
 8003d76:	f000 fd81 	bl	800487c <LCD_IO_WriteData>
 8003d7a:	2003      	movs	r0, #3
 8003d7c:	f000 fd7e 	bl	800487c <LCD_IO_WriteData>
 8003d80:	2012      	movs	r0, #18
 8003d82:	f000 fd7b 	bl	800487c <LCD_IO_WriteData>
 8003d86:	2081      	movs	r0, #129	; 0x81
 8003d88:	f000 fd78 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003d8c:	20e8      	movs	r0, #232	; 0xe8
 8003d8e:	f000 fd91 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003d92:	2085      	movs	r0, #133	; 0x85
 8003d94:	f000 fd72 	bl	800487c <LCD_IO_WriteData>
 8003d98:	2000      	movs	r0, #0
 8003d9a:	f000 fd6f 	bl	800487c <LCD_IO_WriteData>
 8003d9e:	2078      	movs	r0, #120	; 0x78
 8003da0:	f000 fd6c 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003da4:	20cb      	movs	r0, #203	; 0xcb
 8003da6:	f000 fd85 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003daa:	2039      	movs	r0, #57	; 0x39
 8003dac:	f000 fd66 	bl	800487c <LCD_IO_WriteData>
 8003db0:	202c      	movs	r0, #44	; 0x2c
 8003db2:	f000 fd63 	bl	800487c <LCD_IO_WriteData>
 8003db6:	2000      	movs	r0, #0
 8003db8:	f000 fd60 	bl	800487c <LCD_IO_WriteData>
 8003dbc:	2034      	movs	r0, #52	; 0x34
 8003dbe:	f000 fd5d 	bl	800487c <LCD_IO_WriteData>
 8003dc2:	2002      	movs	r0, #2
 8003dc4:	f000 fd5a 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003dc8:	20f7      	movs	r0, #247	; 0xf7
 8003dca:	f000 fd73 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003dce:	2020      	movs	r0, #32
 8003dd0:	f000 fd54 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003dd4:	20ea      	movs	r0, #234	; 0xea
 8003dd6:	f000 fd6d 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003dda:	2000      	movs	r0, #0
 8003ddc:	f000 fd4e 	bl	800487c <LCD_IO_WriteData>
 8003de0:	2000      	movs	r0, #0
 8003de2:	f000 fd4b 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003de6:	20b1      	movs	r0, #177	; 0xb1
 8003de8:	f000 fd64 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003dec:	2000      	movs	r0, #0
 8003dee:	f000 fd45 	bl	800487c <LCD_IO_WriteData>
 8003df2:	201b      	movs	r0, #27
 8003df4:	f000 fd42 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003df8:	20b6      	movs	r0, #182	; 0xb6
 8003dfa:	f000 fd5b 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003dfe:	200a      	movs	r0, #10
 8003e00:	f000 fd3c 	bl	800487c <LCD_IO_WriteData>
 8003e04:	20a2      	movs	r0, #162	; 0xa2
 8003e06:	f000 fd39 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003e0a:	20c0      	movs	r0, #192	; 0xc0
 8003e0c:	f000 fd52 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003e10:	2010      	movs	r0, #16
 8003e12:	f000 fd33 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003e16:	20c1      	movs	r0, #193	; 0xc1
 8003e18:	f000 fd4c 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003e1c:	2010      	movs	r0, #16
 8003e1e:	f000 fd2d 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003e22:	20c5      	movs	r0, #197	; 0xc5
 8003e24:	f000 fd46 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003e28:	2045      	movs	r0, #69	; 0x45
 8003e2a:	f000 fd27 	bl	800487c <LCD_IO_WriteData>
 8003e2e:	2015      	movs	r0, #21
 8003e30:	f000 fd24 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003e34:	20c7      	movs	r0, #199	; 0xc7
 8003e36:	f000 fd3d 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003e3a:	2090      	movs	r0, #144	; 0x90
 8003e3c:	f000 fd1e 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003e40:	2036      	movs	r0, #54	; 0x36
 8003e42:	f000 fd37 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003e46:	20c8      	movs	r0, #200	; 0xc8
 8003e48:	f000 fd18 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003e4c:	20f2      	movs	r0, #242	; 0xf2
 8003e4e:	f000 fd31 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003e52:	2000      	movs	r0, #0
 8003e54:	f000 fd12 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003e58:	20b0      	movs	r0, #176	; 0xb0
 8003e5a:	f000 fd2b 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003e5e:	20c2      	movs	r0, #194	; 0xc2
 8003e60:	f000 fd0c 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003e64:	20b6      	movs	r0, #182	; 0xb6
 8003e66:	f000 fd25 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003e6a:	200a      	movs	r0, #10
 8003e6c:	f000 fd06 	bl	800487c <LCD_IO_WriteData>
 8003e70:	20a7      	movs	r0, #167	; 0xa7
 8003e72:	f000 fd03 	bl	800487c <LCD_IO_WriteData>
 8003e76:	2027      	movs	r0, #39	; 0x27
 8003e78:	f000 fd00 	bl	800487c <LCD_IO_WriteData>
 8003e7c:	2004      	movs	r0, #4
 8003e7e:	f000 fcfd 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003e82:	202a      	movs	r0, #42	; 0x2a
 8003e84:	f000 fd16 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003e88:	2000      	movs	r0, #0
 8003e8a:	f000 fcf7 	bl	800487c <LCD_IO_WriteData>
 8003e8e:	2000      	movs	r0, #0
 8003e90:	f000 fcf4 	bl	800487c <LCD_IO_WriteData>
 8003e94:	2000      	movs	r0, #0
 8003e96:	f000 fcf1 	bl	800487c <LCD_IO_WriteData>
 8003e9a:	20ef      	movs	r0, #239	; 0xef
 8003e9c:	f000 fcee 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003ea0:	202b      	movs	r0, #43	; 0x2b
 8003ea2:	f000 fd07 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003ea6:	2000      	movs	r0, #0
 8003ea8:	f000 fce8 	bl	800487c <LCD_IO_WriteData>
 8003eac:	2000      	movs	r0, #0
 8003eae:	f000 fce5 	bl	800487c <LCD_IO_WriteData>
 8003eb2:	2001      	movs	r0, #1
 8003eb4:	f000 fce2 	bl	800487c <LCD_IO_WriteData>
 8003eb8:	203f      	movs	r0, #63	; 0x3f
 8003eba:	f000 fcdf 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003ebe:	20f6      	movs	r0, #246	; 0xf6
 8003ec0:	f000 fcf8 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003ec4:	2001      	movs	r0, #1
 8003ec6:	f000 fcd9 	bl	800487c <LCD_IO_WriteData>
 8003eca:	2000      	movs	r0, #0
 8003ecc:	f000 fcd6 	bl	800487c <LCD_IO_WriteData>
 8003ed0:	2006      	movs	r0, #6
 8003ed2:	f000 fcd3 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003ed6:	202c      	movs	r0, #44	; 0x2c
 8003ed8:	f000 fcec 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_Delay(200);
 8003edc:	20c8      	movs	r0, #200	; 0xc8
 8003ede:	f000 fd3b 	bl	8004958 <LCD_Delay>
  LCD_IO_WriteReg(LCD_Reg);
 8003ee2:	2026      	movs	r0, #38	; 0x26
 8003ee4:	f000 fce6 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003ee8:	2001      	movs	r0, #1
 8003eea:	f000 fcc7 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003eee:	20e0      	movs	r0, #224	; 0xe0
 8003ef0:	f000 fce0 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003ef4:	200f      	movs	r0, #15
 8003ef6:	f000 fcc1 	bl	800487c <LCD_IO_WriteData>
 8003efa:	2029      	movs	r0, #41	; 0x29
 8003efc:	f000 fcbe 	bl	800487c <LCD_IO_WriteData>
 8003f00:	2024      	movs	r0, #36	; 0x24
 8003f02:	f000 fcbb 	bl	800487c <LCD_IO_WriteData>
 8003f06:	200c      	movs	r0, #12
 8003f08:	f000 fcb8 	bl	800487c <LCD_IO_WriteData>
 8003f0c:	200e      	movs	r0, #14
 8003f0e:	f000 fcb5 	bl	800487c <LCD_IO_WriteData>
 8003f12:	2009      	movs	r0, #9
 8003f14:	f000 fcb2 	bl	800487c <LCD_IO_WriteData>
 8003f18:	204e      	movs	r0, #78	; 0x4e
 8003f1a:	f000 fcaf 	bl	800487c <LCD_IO_WriteData>
 8003f1e:	2078      	movs	r0, #120	; 0x78
 8003f20:	f000 fcac 	bl	800487c <LCD_IO_WriteData>
 8003f24:	203c      	movs	r0, #60	; 0x3c
 8003f26:	f000 fca9 	bl	800487c <LCD_IO_WriteData>
 8003f2a:	2009      	movs	r0, #9
 8003f2c:	f000 fca6 	bl	800487c <LCD_IO_WriteData>
 8003f30:	2013      	movs	r0, #19
 8003f32:	f000 fca3 	bl	800487c <LCD_IO_WriteData>
 8003f36:	2005      	movs	r0, #5
 8003f38:	f000 fca0 	bl	800487c <LCD_IO_WriteData>
 8003f3c:	2017      	movs	r0, #23
 8003f3e:	f000 fc9d 	bl	800487c <LCD_IO_WriteData>
 8003f42:	2011      	movs	r0, #17
 8003f44:	f000 fc9a 	bl	800487c <LCD_IO_WriteData>
 8003f48:	2000      	movs	r0, #0
 8003f4a:	f000 fc97 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003f4e:	20e1      	movs	r0, #225	; 0xe1
 8003f50:	f000 fcb0 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_IO_WriteData(RegValue);
 8003f54:	2000      	movs	r0, #0
 8003f56:	f000 fc91 	bl	800487c <LCD_IO_WriteData>
 8003f5a:	2016      	movs	r0, #22
 8003f5c:	f000 fc8e 	bl	800487c <LCD_IO_WriteData>
 8003f60:	201b      	movs	r0, #27
 8003f62:	f000 fc8b 	bl	800487c <LCD_IO_WriteData>
 8003f66:	2004      	movs	r0, #4
 8003f68:	f000 fc88 	bl	800487c <LCD_IO_WriteData>
 8003f6c:	2011      	movs	r0, #17
 8003f6e:	f000 fc85 	bl	800487c <LCD_IO_WriteData>
 8003f72:	2007      	movs	r0, #7
 8003f74:	f000 fc82 	bl	800487c <LCD_IO_WriteData>
 8003f78:	2031      	movs	r0, #49	; 0x31
 8003f7a:	f000 fc7f 	bl	800487c <LCD_IO_WriteData>
 8003f7e:	2033      	movs	r0, #51	; 0x33
 8003f80:	f000 fc7c 	bl	800487c <LCD_IO_WriteData>
 8003f84:	2042      	movs	r0, #66	; 0x42
 8003f86:	f000 fc79 	bl	800487c <LCD_IO_WriteData>
 8003f8a:	2005      	movs	r0, #5
 8003f8c:	f000 fc76 	bl	800487c <LCD_IO_WriteData>
 8003f90:	200c      	movs	r0, #12
 8003f92:	f000 fc73 	bl	800487c <LCD_IO_WriteData>
 8003f96:	200a      	movs	r0, #10
 8003f98:	f000 fc70 	bl	800487c <LCD_IO_WriteData>
 8003f9c:	2028      	movs	r0, #40	; 0x28
 8003f9e:	f000 fc6d 	bl	800487c <LCD_IO_WriteData>
 8003fa2:	202f      	movs	r0, #47	; 0x2f
 8003fa4:	f000 fc6a 	bl	800487c <LCD_IO_WriteData>
 8003fa8:	200f      	movs	r0, #15
 8003faa:	f000 fc67 	bl	800487c <LCD_IO_WriteData>
  LCD_IO_WriteReg(LCD_Reg);
 8003fae:	2011      	movs	r0, #17
 8003fb0:	f000 fc80 	bl	80048b4 <LCD_IO_WriteReg>
  LCD_Delay(200);
 8003fb4:	20c8      	movs	r0, #200	; 0xc8
 8003fb6:	f000 fccf 	bl	8004958 <LCD_Delay>
  LCD_IO_WriteReg(LCD_Reg);
 8003fba:	2029      	movs	r0, #41	; 0x29
 8003fbc:	f000 fc7a 	bl	80048b4 <LCD_IO_WriteReg>
 8003fc0:	202c      	movs	r0, #44	; 0x2c
}
 8003fc2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  LCD_IO_WriteReg(LCD_Reg);
 8003fc6:	f000 bc75 	b.w	80048b4 <LCD_IO_WriteReg>

08003fca <ili9341_ReadID>:
{
 8003fca:	b508      	push	{r3, lr}
  LCD_IO_Init();
 8003fcc:	f000 fc0c 	bl	80047e8 <LCD_IO_Init>
  return (LCD_IO_ReadData(RegValue, ReadSize));
 8003fd0:	2103      	movs	r1, #3
 8003fd2:	20d3      	movs	r0, #211	; 0xd3
 8003fd4:	f000 fc8a 	bl	80048ec <LCD_IO_ReadData>
}
 8003fd8:	b280      	uxth	r0, r0
 8003fda:	bd08      	pop	{r3, pc}

08003fdc <L3GD20_Init>:
  * @param  L3GD20_InitStruct: pointer to a L3GD20_InitTypeDef structure 
  *         that contains the configuration setting for the L3GD20.
  * @retval None
  */
void L3GD20_Init(uint16_t InitStruct)
{  
 8003fdc:	b537      	push	{r0, r1, r2, r4, r5, lr}
  
  /* Configure the low level interface ---------------------------------------*/
  GYRO_IO_Init();

  /* Write value to MEMS CTRL_REG1 regsister */
  ctrl = (uint8_t) InitStruct;
 8003fde:	ac02      	add	r4, sp, #8
  uint8_t ctrl = 0x00;
 8003fe0:	2300      	movs	r3, #0
{  
 8003fe2:	4605      	mov	r5, r0
  uint8_t ctrl = 0x00;
 8003fe4:	f88d 3007 	strb.w	r3, [sp, #7]
  GYRO_IO_Init();
 8003fe8:	f000 fd2c 	bl	8004a44 <GYRO_IO_Init>
  ctrl = (uint8_t) InitStruct;
 8003fec:	f804 5d01 	strb.w	r5, [r4, #-1]!
  GYRO_IO_Write(&ctrl, L3GD20_CTRL_REG1_ADDR, 1);
 8003ff0:	2201      	movs	r2, #1
 8003ff2:	4620      	mov	r0, r4
 8003ff4:	2120      	movs	r1, #32
 8003ff6:	f000 fd57 	bl	8004aa8 <GYRO_IO_Write>
  
  /* Write value to MEMS CTRL_REG4 regsister */  
  ctrl = (uint8_t) (InitStruct >> 8);
 8003ffa:	0a2d      	lsrs	r5, r5, #8
  GYRO_IO_Write(&ctrl, L3GD20_CTRL_REG4_ADDR, 1);
 8003ffc:	2201      	movs	r2, #1
 8003ffe:	2123      	movs	r1, #35	; 0x23
 8004000:	4620      	mov	r0, r4
  ctrl = (uint8_t) (InitStruct >> 8);
 8004002:	f88d 5007 	strb.w	r5, [sp, #7]
  GYRO_IO_Write(&ctrl, L3GD20_CTRL_REG4_ADDR, 1);
 8004006:	f000 fd4f 	bl	8004aa8 <GYRO_IO_Write>
}
 800400a:	b003      	add	sp, #12
 800400c:	bd30      	pop	{r4, r5, pc}

0800400e <L3GD20_ReadID>:
  * @brief  Read ID address of L3GD20
  * @param  Device ID address
  * @retval ID name
  */
uint8_t L3GD20_ReadID(void)
{
 800400e:	b507      	push	{r0, r1, r2, lr}
  uint8_t tmp;

  /* Configure the low level interface ---------------------------------------*/
  GYRO_IO_Init();
 8004010:	f000 fd18 	bl	8004a44 <GYRO_IO_Init>
  
  /* Read WHO I AM register */
  GYRO_IO_Read(&tmp, L3GD20_WHO_AM_I_ADDR, 1);
 8004014:	f10d 0007 	add.w	r0, sp, #7
 8004018:	2201      	movs	r2, #1
 800401a:	210f      	movs	r1, #15
 800401c:	f000 fd66 	bl	8004aec <GYRO_IO_Read>

  /* Return the ID */
  return (uint8_t)tmp;
}
 8004020:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8004024:	b003      	add	sp, #12
 8004026:	f85d fb04 	ldr.w	pc, [sp], #4

0800402a <L3GD20_RebootCmd>:
  * @brief  Reboot memory content of L3GD20
  * @param  None
  * @retval None
  */
void L3GD20_RebootCmd(void)
{
 800402a:	b507      	push	{r0, r1, r2, lr}
  uint8_t tmpreg;
  
  /* Read CTRL_REG5 register */
  GYRO_IO_Read(&tmpreg, L3GD20_CTRL_REG5_ADDR, 1);
 800402c:	2201      	movs	r2, #1
 800402e:	f10d 0007 	add.w	r0, sp, #7
 8004032:	2124      	movs	r1, #36	; 0x24
 8004034:	f000 fd5a 	bl	8004aec <GYRO_IO_Read>
  
  /* Enable or Disable the reboot memory */
  tmpreg |= L3GD20_BOOT_REBOOTMEMORY;
 8004038:	f89d 3007 	ldrb.w	r3, [sp, #7]
  
  /* Write value to MEMS CTRL_REG5 regsister */
  GYRO_IO_Write(&tmpreg, L3GD20_CTRL_REG5_ADDR, 1);
 800403c:	2201      	movs	r2, #1
  tmpreg |= L3GD20_BOOT_REBOOTMEMORY;
 800403e:	f063 037f 	orn	r3, r3, #127	; 0x7f
  GYRO_IO_Write(&tmpreg, L3GD20_CTRL_REG5_ADDR, 1);
 8004042:	2124      	movs	r1, #36	; 0x24
 8004044:	f10d 0007 	add.w	r0, sp, #7
  tmpreg |= L3GD20_BOOT_REBOOTMEMORY;
 8004048:	f88d 3007 	strb.w	r3, [sp, #7]
  GYRO_IO_Write(&tmpreg, L3GD20_CTRL_REG5_ADDR, 1);
 800404c:	f000 fd2c 	bl	8004aa8 <GYRO_IO_Write>
}
 8004050:	b003      	add	sp, #12
 8004052:	f85d fb04 	ldr.w	pc, [sp], #4

08004056 <L3GD20_INT1InterruptConfig>:
  * @param  L3GD20_InterruptConfig_TypeDef: pointer to a L3GD20_InterruptConfig_TypeDef 
  *         structure that contains the configuration setting for the L3GD20 Interrupt.
  * @retval None
  */
void L3GD20_INT1InterruptConfig(uint16_t Int1Config)
{
 8004056:	b513      	push	{r0, r1, r4, lr}
  uint8_t ctrl_cfr = 0x00, ctrl3 = 0x00;
 8004058:	2300      	movs	r3, #0
{
 800405a:	4604      	mov	r4, r0
  
  /* Read INT1_CFG register */
  GYRO_IO_Read(&ctrl_cfr, L3GD20_INT1_CFG_ADDR, 1);
 800405c:	2201      	movs	r2, #1
 800405e:	f10d 0006 	add.w	r0, sp, #6
 8004062:	2130      	movs	r1, #48	; 0x30
  uint8_t ctrl_cfr = 0x00, ctrl3 = 0x00;
 8004064:	f88d 3006 	strb.w	r3, [sp, #6]
 8004068:	f88d 3007 	strb.w	r3, [sp, #7]
  GYRO_IO_Read(&ctrl_cfr, L3GD20_INT1_CFG_ADDR, 1);
 800406c:	f000 fd3e 	bl	8004aec <GYRO_IO_Read>
  
  /* Read CTRL_REG3 register */
  GYRO_IO_Read(&ctrl3, L3GD20_CTRL_REG3_ADDR, 1);
 8004070:	f10d 0007 	add.w	r0, sp, #7
 8004074:	2201      	movs	r2, #1
 8004076:	2122      	movs	r1, #34	; 0x22
 8004078:	f000 fd38 	bl	8004aec <GYRO_IO_Read>
  
  ctrl_cfr &= 0x80;
  ctrl_cfr |= ((uint8_t) Int1Config >> 8);
  
  ctrl3 &= 0xDF;
 800407c:	f89d 0007 	ldrb.w	r0, [sp, #7]
  ctrl_cfr &= 0x80;
 8004080:	f89d 3006 	ldrb.w	r3, [sp, #6]
  ctrl3 &= 0xDF;
 8004084:	f020 0020 	bic.w	r0, r0, #32
  ctrl3 |= ((uint8_t) Int1Config);
 8004088:	4320      	orrs	r0, r4
  ctrl_cfr &= 0x80;
 800408a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  ctrl3 |= ((uint8_t) Int1Config);
 800408e:	f88d 0007 	strb.w	r0, [sp, #7]
                   L3GD20_IntConfigStruct->Interrupt_Axes);
                   
  ctrl3 |= (uint8_t)(L3GD20_IntConfigStruct->Interrupt_ActiveEdge);
*/  
  /* Write value to MEMS INT1_CFG register */
  GYRO_IO_Write(&ctrl_cfr, L3GD20_INT1_CFG_ADDR, 1);
 8004092:	2201      	movs	r2, #1
 8004094:	f10d 0006 	add.w	r0, sp, #6
 8004098:	2130      	movs	r1, #48	; 0x30
  ctrl_cfr &= 0x80;
 800409a:	f88d 3006 	strb.w	r3, [sp, #6]
  GYRO_IO_Write(&ctrl_cfr, L3GD20_INT1_CFG_ADDR, 1);
 800409e:	f000 fd03 	bl	8004aa8 <GYRO_IO_Write>
  
  /* Write value to MEMS CTRL_REG3 register */
  GYRO_IO_Write(&ctrl3, L3GD20_CTRL_REG3_ADDR, 1);
 80040a2:	2201      	movs	r2, #1
 80040a4:	2122      	movs	r1, #34	; 0x22
 80040a6:	f10d 0007 	add.w	r0, sp, #7
 80040aa:	f000 fcfd 	bl	8004aa8 <GYRO_IO_Write>
}
 80040ae:	b002      	add	sp, #8
 80040b0:	bd10      	pop	{r4, pc}

080040b2 <L3GD20_EnableIT>:
  *        @arg L3GD20_INT1
  *        @arg L3GD20_INT2   
  * @retval None
  */
void L3GD20_EnableIT(uint8_t IntSel)
{  
 80040b2:	b513      	push	{r0, r1, r4, lr}
  uint8_t tmpreg;
  
  /* Read CTRL_REG3 register */
  GYRO_IO_Read(&tmpreg, L3GD20_CTRL_REG3_ADDR, 1);
 80040b4:	2201      	movs	r2, #1
{  
 80040b6:	4604      	mov	r4, r0
  GYRO_IO_Read(&tmpreg, L3GD20_CTRL_REG3_ADDR, 1);
 80040b8:	2122      	movs	r1, #34	; 0x22
 80040ba:	f10d 0007 	add.w	r0, sp, #7
 80040be:	f000 fd15 	bl	8004aec <GYRO_IO_Read>
  
  if(IntSel == L3GD20_INT1)
 80040c2:	b96c      	cbnz	r4, 80040e0 <L3GD20_EnableIT+0x2e>
  {
    tmpreg &= 0x7F;	
 80040c4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    tmpreg |= L3GD20_INT1INTERRUPT_ENABLE;
 80040c8:	f063 037f 	orn	r3, r3, #127	; 0x7f
  }
  else if(IntSel == L3GD20_INT2)
  {
    tmpreg &= 0xF7;
    tmpreg |= L3GD20_INT2INTERRUPT_ENABLE;
 80040cc:	f88d 3007 	strb.w	r3, [sp, #7]
  }
  
  /* Write value to MEMS CTRL_REG3 regsister */
  GYRO_IO_Write(&tmpreg, L3GD20_CTRL_REG3_ADDR, 1);
 80040d0:	2201      	movs	r2, #1
 80040d2:	2122      	movs	r1, #34	; 0x22
 80040d4:	f10d 0007 	add.w	r0, sp, #7
 80040d8:	f000 fce6 	bl	8004aa8 <GYRO_IO_Write>
}
 80040dc:	b002      	add	sp, #8
 80040de:	bd10      	pop	{r4, pc}
  else if(IntSel == L3GD20_INT2)
 80040e0:	2c01      	cmp	r4, #1
 80040e2:	d1f5      	bne.n	80040d0 <L3GD20_EnableIT+0x1e>
    tmpreg &= 0xF7;
 80040e4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80040e8:	f023 0308 	bic.w	r3, r3, #8
    tmpreg |= L3GD20_INT2INTERRUPT_ENABLE;
 80040ec:	f043 0308 	orr.w	r3, r3, #8
 80040f0:	e7ec      	b.n	80040cc <L3GD20_EnableIT+0x1a>

080040f2 <L3GD20_DisableIT>:
  *        @arg L3GD20_INT1
  *        @arg L3GD20_INT2   
  * @retval None
  */
void L3GD20_DisableIT(uint8_t IntSel)
{  
 80040f2:	b513      	push	{r0, r1, r4, lr}
  uint8_t tmpreg;
  
  /* Read CTRL_REG3 register */
  GYRO_IO_Read(&tmpreg, L3GD20_CTRL_REG3_ADDR, 1);
 80040f4:	2201      	movs	r2, #1
{  
 80040f6:	4604      	mov	r4, r0
  GYRO_IO_Read(&tmpreg, L3GD20_CTRL_REG3_ADDR, 1);
 80040f8:	2122      	movs	r1, #34	; 0x22
 80040fa:	f10d 0007 	add.w	r0, sp, #7
 80040fe:	f000 fcf5 	bl	8004aec <GYRO_IO_Read>
  
  if(IntSel == L3GD20_INT1)
 8004102:	b96c      	cbnz	r4, 8004120 <L3GD20_DisableIT+0x2e>
  {
    tmpreg &= 0x7F;	
 8004104:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004108:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    tmpreg |= L3GD20_INT1INTERRUPT_DISABLE;
  }
  else if(IntSel == L3GD20_INT2)
  {
    tmpreg &= 0xF7;
 800410c:	f88d 3007 	strb.w	r3, [sp, #7]
    tmpreg |= L3GD20_INT2INTERRUPT_DISABLE;
  }
  
  /* Write value to MEMS CTRL_REG3 regsister */
  GYRO_IO_Write(&tmpreg, L3GD20_CTRL_REG3_ADDR, 1);
 8004110:	2201      	movs	r2, #1
 8004112:	2122      	movs	r1, #34	; 0x22
 8004114:	f10d 0007 	add.w	r0, sp, #7
 8004118:	f000 fcc6 	bl	8004aa8 <GYRO_IO_Write>
}
 800411c:	b002      	add	sp, #8
 800411e:	bd10      	pop	{r4, pc}
  else if(IntSel == L3GD20_INT2)
 8004120:	2c01      	cmp	r4, #1
 8004122:	d1f5      	bne.n	8004110 <L3GD20_DisableIT+0x1e>
    tmpreg &= 0xF7;
 8004124:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004128:	f023 0308 	bic.w	r3, r3, #8
 800412c:	e7ee      	b.n	800410c <L3GD20_DisableIT+0x1a>

0800412e <L3GD20_FilterConfig>:
  * @brief  Set High Pass Filter Modality
  * @param  FilterStruct: contains the configuration setting for the L3GD20.        
  * @retval None
  */
void L3GD20_FilterConfig(uint8_t FilterStruct) 
{
 800412e:	b513      	push	{r0, r1, r4, lr}
  uint8_t tmpreg;
  
  /* Read CTRL_REG2 register */
  GYRO_IO_Read(&tmpreg, L3GD20_CTRL_REG2_ADDR, 1);
 8004130:	2201      	movs	r2, #1
{
 8004132:	4604      	mov	r4, r0
  GYRO_IO_Read(&tmpreg, L3GD20_CTRL_REG2_ADDR, 1);
 8004134:	2121      	movs	r1, #33	; 0x21
 8004136:	f10d 0007 	add.w	r0, sp, #7
 800413a:	f000 fcd7 	bl	8004aec <GYRO_IO_Read>
  
  tmpreg &= 0xC0;
 800413e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004142:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
  
  /* Configure MEMS: mode and cutoff frquency */
  tmpreg |= FilterStruct;
 8004146:	431c      	orrs	r4, r3

  /* Write value to MEMS CTRL_REG2 regsister */
  GYRO_IO_Write(&tmpreg, L3GD20_CTRL_REG2_ADDR, 1);
 8004148:	2201      	movs	r2, #1
 800414a:	2121      	movs	r1, #33	; 0x21
 800414c:	f10d 0007 	add.w	r0, sp, #7
  tmpreg |= FilterStruct;
 8004150:	f88d 4007 	strb.w	r4, [sp, #7]
  GYRO_IO_Write(&tmpreg, L3GD20_CTRL_REG2_ADDR, 1);
 8004154:	f000 fca8 	bl	8004aa8 <GYRO_IO_Write>
}
 8004158:	b002      	add	sp, #8
 800415a:	bd10      	pop	{r4, pc}

0800415c <L3GD20_FilterCmd>:
  *         @arg: L3GD20_HIGHPASSFILTER_DISABLE 
  *         @arg: L3GD20_HIGHPASSFILTER_ENABLE          
  * @retval None
  */
void L3GD20_FilterCmd(uint8_t HighPassFilterState)
{
 800415c:	b513      	push	{r0, r1, r4, lr}
  uint8_t tmpreg;
  
  /* Read CTRL_REG5 register */
  GYRO_IO_Read(&tmpreg, L3GD20_CTRL_REG5_ADDR, 1);
 800415e:	2201      	movs	r2, #1
{
 8004160:	4604      	mov	r4, r0
  GYRO_IO_Read(&tmpreg, L3GD20_CTRL_REG5_ADDR, 1);
 8004162:	2124      	movs	r1, #36	; 0x24
 8004164:	f10d 0007 	add.w	r0, sp, #7
 8004168:	f000 fcc0 	bl	8004aec <GYRO_IO_Read>
  
  tmpreg &= 0xEF;
 800416c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004170:	f023 0310 	bic.w	r3, r3, #16
  
  tmpreg |= HighPassFilterState;
 8004174:	431c      	orrs	r4, r3
  
  /* Write value to MEMS CTRL_REG5 regsister */
  GYRO_IO_Write(&tmpreg, L3GD20_CTRL_REG5_ADDR, 1);
 8004176:	2201      	movs	r2, #1
 8004178:	2124      	movs	r1, #36	; 0x24
 800417a:	f10d 0007 	add.w	r0, sp, #7
  tmpreg |= HighPassFilterState;
 800417e:	f88d 4007 	strb.w	r4, [sp, #7]
  GYRO_IO_Write(&tmpreg, L3GD20_CTRL_REG5_ADDR, 1);
 8004182:	f000 fc91 	bl	8004aa8 <GYRO_IO_Write>
}
 8004186:	b002      	add	sp, #8
 8004188:	bd10      	pop	{r4, pc}
	...

0800418c <L3GD20_ReadXYZAngRate>:
* @brief  Calculate the L3GD20 angular data.
* @param  pfData : Data out pointer
* @retval None
*/
void L3GD20_ReadXYZAngRate(float* pfData)
{
 800418c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800418e:	b087      	sub	sp, #28
 8004190:	4604      	mov	r4, r0
  uint8_t tmpbuffer[6] ={0};
  int16_t RawData[3] = {0};
  uint8_t tmpreg = 0;
 8004192:	a806      	add	r0, sp, #24
  uint8_t tmpbuffer[6] ={0};
 8004194:	2300      	movs	r3, #0
  int16_t RawData[3] = {0};
 8004196:	ad04      	add	r5, sp, #16
  uint8_t tmpreg = 0;
 8004198:	f800 3d11 	strb.w	r3, [r0, #-17]!
  float sensitivity = 0;
  int i =0;
  
  GYRO_IO_Read(&tmpreg,L3GD20_CTRL_REG4_ADDR,1);
 800419c:	2201      	movs	r2, #1
 800419e:	2123      	movs	r1, #35	; 0x23
  uint8_t tmpbuffer[6] ={0};
 80041a0:	9302      	str	r3, [sp, #8]
 80041a2:	f8ad 300c 	strh.w	r3, [sp, #12]
  int16_t RawData[3] = {0};
 80041a6:	9304      	str	r3, [sp, #16]
 80041a8:	80ab      	strh	r3, [r5, #4]
  GYRO_IO_Read(&tmpreg,L3GD20_CTRL_REG4_ADDR,1);
 80041aa:	f000 fc9f 	bl	8004aec <GYRO_IO_Read>
  
  GYRO_IO_Read(tmpbuffer,L3GD20_OUT_X_L_ADDR,6);
 80041ae:	2206      	movs	r2, #6
 80041b0:	2128      	movs	r1, #40	; 0x28
 80041b2:	a802      	add	r0, sp, #8
 80041b4:	f000 fc9a 	bl	8004aec <GYRO_IO_Read>
  
  /* check in the control register 4 the data alignment (Big Endian or Little Endian)*/
  if(!(tmpreg & L3GD20_BLE_MSB))
 80041b8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80041bc:	f89d 7009 	ldrb.w	r7, [sp, #9]
 80041c0:	f89d e008 	ldrb.w	lr, [sp, #8]
 80041c4:	f89d 000b 	ldrb.w	r0, [sp, #11]
 80041c8:	f89d 600a 	ldrb.w	r6, [sp, #10]
 80041cc:	f89d 200d 	ldrb.w	r2, [sp, #13]
 80041d0:	f89d 100c 	ldrb.w	r1, [sp, #12]
 80041d4:	f013 0f40 	tst.w	r3, #64	; 0x40
 80041d8:	d12a      	bne.n	8004230 <L3GD20_ReadXYZAngRate+0xa4>
  {
    for(i=0; i<3; i++)
    {
      RawData[i]=(int16_t)(((uint16_t)tmpbuffer[2*i+1] << 8) + tmpbuffer[2*i]);
 80041da:	eb0e 2707 	add.w	r7, lr, r7, lsl #8
 80041de:	eb06 2000 	add.w	r0, r6, r0, lsl #8
 80041e2:	f8ad 7010 	strh.w	r7, [sp, #16]
 80041e6:	f8ad 0012 	strh.w	r0, [sp, #18]
 80041ea:	eb01 2202 	add.w	r2, r1, r2, lsl #8
      RawData[i]=(int16_t)(((uint16_t)tmpbuffer[2*i] << 8) + tmpbuffer[2*i+1]);
    }
  }
  
  /* Switch the sensitivity value set in the CRTL4 */
  switch(tmpreg & L3GD20_FULLSCALE_SELECTION)
 80041ee:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80041f2:	2b10      	cmp	r3, #16
      RawData[i]=(int16_t)(((uint16_t)tmpbuffer[2*i+1] << 8) + tmpbuffer[2*i]);
 80041f4:	f8ad 2014 	strh.w	r2, [sp, #20]
  switch(tmpreg & L3GD20_FULLSCALE_SELECTION)
 80041f8:	d025      	beq.n	8004246 <L3GD20_ReadXYZAngRate+0xba>
 80041fa:	2b20      	cmp	r3, #32
 80041fc:	d026      	beq.n	800424c <L3GD20_ReadXYZAngRate+0xc0>
  float sensitivity = 0;
 80041fe:	eddf 7a15 	vldr	s15, [pc, #84]	; 8004254 <L3GD20_ReadXYZAngRate+0xc8>
 8004202:	ed9f 7a15 	vldr	s14, [pc, #84]	; 8004258 <L3GD20_ReadXYZAngRate+0xcc>
 8004206:	2b00      	cmp	r3, #0
 8004208:	bf18      	it	ne
 800420a:	eeb0 7a67 	vmovne.f32	s14, s15
 800420e:	4620      	mov	r0, r4
  case L3GD20_FULLSCALE_2000:
    sensitivity=L3GD20_SENSITIVITY_2000DPS;
    break;
  }
  /* divide by sensitivity */
  for(i=0; i<3; i++)
 8004210:	2300      	movs	r3, #0
  {
    pfData[i]=(float)(RawData[i] * sensitivity);
 8004212:	f935 2013 	ldrsh.w	r2, [r5, r3, lsl #1]
 8004216:	ee07 2a90 	vmov	s15, r2
 800421a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  for(i=0; i<3; i++)
 800421e:	3301      	adds	r3, #1
    pfData[i]=(float)(RawData[i] * sensitivity);
 8004220:	ee67 7a87 	vmul.f32	s15, s15, s14
  for(i=0; i<3; i++)
 8004224:	2b03      	cmp	r3, #3
    pfData[i]=(float)(RawData[i] * sensitivity);
 8004226:	ece0 7a01 	vstmia	r0!, {s15}
  for(i=0; i<3; i++)
 800422a:	d1f2      	bne.n	8004212 <L3GD20_ReadXYZAngRate+0x86>
  }
}
 800422c:	b007      	add	sp, #28
 800422e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      RawData[i]=(int16_t)(((uint16_t)tmpbuffer[2*i] << 8) + tmpbuffer[2*i+1]);
 8004230:	eb07 270e 	add.w	r7, r7, lr, lsl #8
 8004234:	eb00 2006 	add.w	r0, r0, r6, lsl #8
 8004238:	f8ad 7010 	strh.w	r7, [sp, #16]
 800423c:	f8ad 0012 	strh.w	r0, [sp, #18]
 8004240:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 8004244:	e7d3      	b.n	80041ee <L3GD20_ReadXYZAngRate+0x62>
    sensitivity=L3GD20_SENSITIVITY_500DPS;
 8004246:	ed9f 7a05 	vldr	s14, [pc, #20]	; 800425c <L3GD20_ReadXYZAngRate+0xd0>
    break;
 800424a:	e7e0      	b.n	800420e <L3GD20_ReadXYZAngRate+0x82>
    sensitivity=L3GD20_SENSITIVITY_2000DPS;
 800424c:	ed9f 7a04 	vldr	s14, [pc, #16]	; 8004260 <L3GD20_ReadXYZAngRate+0xd4>
    break;
 8004250:	e7dd      	b.n	800420e <L3GD20_ReadXYZAngRate+0x82>
 8004252:	bf00      	nop
 8004254:	00000000 	.word	0x00000000
 8004258:	410c0000 	.word	0x410c0000
 800425c:	418c0000 	.word	0x418c0000
 8004260:	428c0000 	.word	0x428c0000

08004264 <lcd_handleMouseNotify>:


/* Function to getting notify from 'mouse driver' ( touchscreen ) */
void lcd_handleMouseNotify( TS_mouseInputTypeDef _state_, const Point * const _inData_ ) {
	
	lcd_draw_action.X = _inData_->X ;
 8004264:	4b05      	ldr	r3, [pc, #20]	; (800427c <lcd_handleMouseNotify+0x18>)
 8004266:	880a      	ldrh	r2, [r1, #0]
 8004268:	805a      	strh	r2, [r3, #2]
	lcd_draw_action.Y = _inData_->Y ;
 800426a:	884a      	ldrh	r2, [r1, #2]
 800426c:	809a      	strh	r2, [r3, #4]
	
	lcd_draw_action.prev_action = lcd_draw_action.curr_action ;
 800426e:	781a      	ldrb	r2, [r3, #0]
 8004270:	705a      	strb	r2, [r3, #1]
	lcd_draw_action.curr_action = _state_ ;
	lcd_draw_action.penNotify = 1 ;
 8004272:	2201      	movs	r2, #1
	lcd_draw_action.curr_action = _state_ ;
 8004274:	7018      	strb	r0, [r3, #0]
	lcd_draw_action.penNotify = 1 ;
 8004276:	719a      	strb	r2, [r3, #6]
 8004278:	4770      	bx	lr
 800427a:	bf00      	nop
 800427c:	20000256 	.word	0x20000256

08004280 <Xmirror_points>:
	lcd_drawSlider() ;
	
}


void Xmirror_points( const Point *in, Point *out, const uint8_t size ) {
 8004280:	b530      	push	{r4, r5, lr}
	uint8_t i ;
	for( i = 0 ; i < size ; ++i ) {
 8004282:	2300      	movs	r3, #0
 8004284:	2402      	movs	r4, #2
 8004286:	b2dd      	uxtb	r5, r3
 8004288:	42aa      	cmp	r2, r5
 800428a:	d800      	bhi.n	800428e <Xmirror_points+0xe>
		out[i].X  = 240 - in[i].X ;
		out[i].Y  = in[i].Y ;
	}
}
 800428c:	bd30      	pop	{r4, r5, pc}
		out[i].X  = 240 - in[i].X ;
 800428e:	f830 5023 	ldrh.w	r5, [r0, r3, lsl #2]
 8004292:	f1c5 05f0 	rsb	r5, r5, #240	; 0xf0
 8004296:	f821 5023 	strh.w	r5, [r1, r3, lsl #2]
		out[i].Y  = in[i].Y ;
 800429a:	5f05      	ldrsh	r5, [r0, r4]
 800429c:	530d      	strh	r5, [r1, r4]
 800429e:	3301      	adds	r3, #1
 80042a0:	3404      	adds	r4, #4
 80042a2:	e7f0      	b.n	8004286 <Xmirror_points+0x6>

080042a4 <lcd_drawSliderRect>:
void lcd_drawSlider(void) {
	lcd_drawSliderRect( 40 , LCD_COLOR_ANDROID_BLUE, LCD_COLOR_WHITE ) ;
	lcd_drawSliderRect( 100 , LCD_COLOR_ANDROID_BLUE, LCD_COLOR_WHITE ) ;
	lcd_drawSliderRect( 160 , LCD_COLOR_ANDROID_BLUE, LCD_COLOR_WHITE ) ;
}
void lcd_drawSliderRect( uint16_t dist_top, uint32_t fill_color, uint32_t edge_color ) {
 80042a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80042a6:	460f      	mov	r7, r1
 80042a8:	4616      	mov	r6, r2
	
	uint32_t cback ;
	
	if ( dist_top >= (uint16_t)LCD_SIZE_Y )
		dist_top = 0 ;
 80042aa:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
 80042ae:	bf34      	ite	cc
 80042b0:	4604      	movcc	r4, r0
 80042b2:	2400      	movcs	r4, #0

	cback = BSP_LCD_GetTextColor() ;
 80042b4:	f000 fdd8 	bl	8004e68 <BSP_LCD_GetTextColor>
 80042b8:	4605      	mov	r5, r0
	BSP_LCD_SetTextColor(fill_color) ;
 80042ba:	4638      	mov	r0, r7
 80042bc:	f000 fde0 	bl	8004e80 <BSP_LCD_SetTextColor>
	BSP_LCD_FillRect( RECT_X_POS, ((uint16_t)LCD_SIZE_Y - dist_top) , RECT_X_LEN, RECT_Y_LEN ) ;
 80042c0:	f5c4 71a0 	rsb	r1, r4, #320	; 0x140
 80042c4:	2307      	movs	r3, #7
 80042c6:	2210      	movs	r2, #16
 80042c8:	b289      	uxth	r1, r1
 80042ca:	2071      	movs	r0, #113	; 0x71
 80042cc:	f000 fe70 	bl	8004fb0 <BSP_LCD_FillRect>
	
	// Draw edge
	BSP_LCD_SetTextColor(edge_color) ;
 80042d0:	4630      	mov	r0, r6
 80042d2:	f000 fdd5 	bl	8004e80 <BSP_LCD_SetTextColor>
	BSP_LCD_DrawRect( RECT_X_POS-2, ((uint16_t)LCD_SIZE_Y - dist_top -2) , RECT_X_LEN+3, RECT_Y_LEN+3 ) ;
 80042d6:	f5c4 719f 	rsb	r1, r4, #318	; 0x13e
 80042da:	230a      	movs	r3, #10
 80042dc:	206f      	movs	r0, #111	; 0x6f
 80042de:	2213      	movs	r2, #19
 80042e0:	b289      	uxth	r1, r1
 80042e2:	f000 fe4b 	bl	8004f7c <BSP_LCD_DrawRect>
	
	BSP_LCD_SetTextColor(cback) ;
 80042e6:	4628      	mov	r0, r5
}
 80042e8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	BSP_LCD_SetTextColor(cback) ;
 80042ec:	f000 bdc8 	b.w	8004e80 <BSP_LCD_SetTextColor>

080042f0 <lcd_drawSlider>:
void lcd_drawSlider(void) {
 80042f0:	b510      	push	{r4, lr}
	lcd_drawSliderRect( 40 , LCD_COLOR_ANDROID_BLUE, LCD_COLOR_WHITE ) ;
 80042f2:	4c0a      	ldr	r4, [pc, #40]	; (800431c <lcd_drawSlider+0x2c>)
 80042f4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80042f8:	4621      	mov	r1, r4
 80042fa:	2028      	movs	r0, #40	; 0x28
 80042fc:	f7ff ffd2 	bl	80042a4 <lcd_drawSliderRect>
	lcd_drawSliderRect( 100 , LCD_COLOR_ANDROID_BLUE, LCD_COLOR_WHITE ) ;
 8004300:	4621      	mov	r1, r4
 8004302:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004306:	2064      	movs	r0, #100	; 0x64
 8004308:	f7ff ffcc 	bl	80042a4 <lcd_drawSliderRect>
	lcd_drawSliderRect( 160 , LCD_COLOR_ANDROID_BLUE, LCD_COLOR_WHITE ) ;
 800430c:	4621      	mov	r1, r4
 800430e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004312:	20a0      	movs	r0, #160	; 0xa0
}
 8004314:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lcd_drawSliderRect( 160 , LCD_COLOR_ANDROID_BLUE, LCD_COLOR_WHITE ) ;
 8004318:	f7ff bfc4 	b.w	80042a4 <lcd_drawSliderRect>
 800431c:	ff42a5f5 	.word	0xff42a5f5

08004320 <lcd_drawRightButton>:



void lcd_drawRightButton( Point * const right, uint32_t no, uint32_t color ) {
 8004320:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004322:	4617      	mov	r7, r2
 8004324:	460e      	mov	r6, r1
 8004326:	4605      	mov	r5, r0
	
	uint32_t cback ;
	cback = BSP_LCD_GetTextColor() ;
 8004328:	f000 fd9e 	bl	8004e68 <BSP_LCD_GetTextColor>
 800432c:	4604      	mov	r4, r0
	
	BSP_LCD_SetTextColor( color ) ;
 800432e:	4638      	mov	r0, r7
 8004330:	f000 fda6 	bl	8004e80 <BSP_LCD_SetTextColor>
	BSP_LCD_FillPolygon( &right[0], no ) ;
 8004334:	4628      	mov	r0, r5
 8004336:	b2b1      	uxth	r1, r6
 8004338:	f000 ff4c 	bl	80051d4 <BSP_LCD_FillPolygon>
	
	
	
	BSP_LCD_SetTextColor( cback ) ;
 800433c:	4620      	mov	r0, r4
}
 800433e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	BSP_LCD_SetTextColor( cback ) ;
 8004342:	f000 bd9d 	b.w	8004e80 <BSP_LCD_SetTextColor>

08004346 <lcd_drawLeftButton>:


void lcd_drawLeftButton( Point * const right, Point *storage, uint32_t no, uint32_t color ) {
 8004346:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800434a:	461f      	mov	r7, r3
 800434c:	460c      	mov	r4, r1
 800434e:	4615      	mov	r5, r2
 8004350:	4680      	mov	r8, r0
	
	uint32_t cback ;
	cback = BSP_LCD_GetTextColor() ;
 8004352:	f000 fd89 	bl	8004e68 <BSP_LCD_GetTextColor>
	
	Xmirror_points( &right[0], &storage[0], no ) ;
 8004356:	b2ea      	uxtb	r2, r5
 8004358:	4621      	mov	r1, r4
	cback = BSP_LCD_GetTextColor() ;
 800435a:	4606      	mov	r6, r0
	Xmirror_points( &right[0], &storage[0], no ) ;
 800435c:	4640      	mov	r0, r8
 800435e:	f7ff ff8f 	bl	8004280 <Xmirror_points>
	BSP_LCD_SetTextColor( color ) ;
 8004362:	4638      	mov	r0, r7
 8004364:	f000 fd8c 	bl	8004e80 <BSP_LCD_SetTextColor>
	BSP_LCD_FillPolygon( &storage[0], no ) ;
 8004368:	4620      	mov	r0, r4
 800436a:	b2a9      	uxth	r1, r5
 800436c:	f000 ff32 	bl	80051d4 <BSP_LCD_FillPolygon>
	
	BSP_LCD_SetTextColor( cback ) ;
 8004370:	4630      	mov	r0, r6
}
 8004372:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	BSP_LCD_SetTextColor( cback ) ;
 8004376:	f000 bd83 	b.w	8004e80 <BSP_LCD_SetTextColor>
	...

0800437c <lcd_drawAction>:
void lcd_drawAction(void) {
 800437c:	b510      	push	{r4, lr}
	if ( lcd_draw_action.penNotify != 0 ) {
 800437e:	4c1d      	ldr	r4, [pc, #116]	; (80043f4 <lcd_drawAction+0x78>)
 8004380:	79a3      	ldrb	r3, [r4, #6]
 8004382:	b1f3      	cbz	r3, 80043c2 <lcd_drawAction+0x46>
		BSP_LCD_SetTransparency(LCD_BACKGROUND_LAYER,0xFF) ;
 8004384:	21ff      	movs	r1, #255	; 0xff
 8004386:	2000      	movs	r0, #0
 8004388:	f000 fd68 	bl	8004e5c <BSP_LCD_SetTransparency>
		BSP_LCD_SetTransparency(LCD_FOREGROUND_LAYER,0x00) ;
 800438c:	2100      	movs	r1, #0
 800438e:	2001      	movs	r0, #1
 8004390:	f000 fd64 	bl	8004e5c <BSP_LCD_SetTransparency>
		BSP_LCD_SelectLayer(LCD_FOREGROUND_LAYER);
 8004394:	2001      	movs	r0, #1
 8004396:	f000 fd47 	bl	8004e28 <BSP_LCD_SelectLayer>
		if ( lcd_draw_action.curr_action == TS_MOUSE_NONE ) {
 800439a:	7823      	ldrb	r3, [r4, #0]
 800439c:	b9fb      	cbnz	r3, 80043de <lcd_drawAction+0x62>
			switch ( lcd_draw_action.prev_action ) {
 800439e:	7863      	ldrb	r3, [r4, #1]
 80043a0:	2b01      	cmp	r3, #1
 80043a2:	d00f      	beq.n	80043c4 <lcd_drawAction+0x48>
 80043a4:	d303      	bcc.n	80043ae <lcd_drawAction+0x32>
 80043a6:	2b02      	cmp	r3, #2
 80043a8:	d013      	beq.n	80043d2 <lcd_drawAction+0x56>
						lcd_drawSlider() ;
 80043aa:	f7ff ffa1 	bl	80042f0 <lcd_drawSlider>
		BSP_LCD_SetTransparency(LCD_FOREGROUND_LAYER, 0xFF );
 80043ae:	21ff      	movs	r1, #255	; 0xff
 80043b0:	2001      	movs	r0, #1
 80043b2:	f000 fd53 	bl	8004e5c <BSP_LCD_SetTransparency>
		BSP_LCD_SetTransparency(LCD_BACKGROUND_LAYER, 0x00 );
 80043b6:	2100      	movs	r1, #0
 80043b8:	4608      	mov	r0, r1
 80043ba:	f000 fd4f 	bl	8004e5c <BSP_LCD_SetTransparency>
		lcd_draw_action.penNotify = 0 ;
 80043be:	2300      	movs	r3, #0
 80043c0:	71a3      	strb	r3, [r4, #6]
 80043c2:	bd10      	pop	{r4, pc}
						lcd_drawLeftButton( &button_poly[0],  &mirr_poly[0], 6, LCD_COLOR_ANDROID_BLUE ) ;
 80043c4:	4b0c      	ldr	r3, [pc, #48]	; (80043f8 <lcd_drawAction+0x7c>)
			lcd_drawLeftButton( &button_poly[0],  &mirr_poly[0], 6, LCD_COLOR_MY_ORANGE ) ;
 80043c6:	490d      	ldr	r1, [pc, #52]	; (80043fc <lcd_drawAction+0x80>)
 80043c8:	480d      	ldr	r0, [pc, #52]	; (8004400 <lcd_drawAction+0x84>)
 80043ca:	2206      	movs	r2, #6
 80043cc:	f7ff ffbb 	bl	8004346 <lcd_drawLeftButton>
 80043d0:	e7ed      	b.n	80043ae <lcd_drawAction+0x32>
						lcd_drawRightButton( &button_poly[0], 6, LCD_COLOR_ANDROID_BLUE ) ;
 80043d2:	4a09      	ldr	r2, [pc, #36]	; (80043f8 <lcd_drawAction+0x7c>)
			lcd_drawRightButton( &button_poly[0], 6, LCD_COLOR_MY_ORANGE ) ;
 80043d4:	480a      	ldr	r0, [pc, #40]	; (8004400 <lcd_drawAction+0x84>)
 80043d6:	2106      	movs	r1, #6
 80043d8:	f7ff ffa2 	bl	8004320 <lcd_drawRightButton>
 80043dc:	e7e7      	b.n	80043ae <lcd_drawAction+0x32>
		else if ( lcd_draw_action.curr_action == TS_MOUSE_LEFT ) {
 80043de:	2b01      	cmp	r3, #1
 80043e0:	d102      	bne.n	80043e8 <lcd_drawAction+0x6c>
			lcd_drawLeftButton( &button_poly[0],  &mirr_poly[0], 6, LCD_COLOR_MY_ORANGE ) ;
 80043e2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80043e6:	e7ee      	b.n	80043c6 <lcd_drawAction+0x4a>
		else if ( lcd_draw_action.curr_action == TS_MOUSE_RIGHT ) {
 80043e8:	2b02      	cmp	r3, #2
 80043ea:	d1e0      	bne.n	80043ae <lcd_drawAction+0x32>
			lcd_drawRightButton( &button_poly[0], 6, LCD_COLOR_MY_ORANGE ) ;
 80043ec:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80043f0:	e7f0      	b.n	80043d4 <lcd_drawAction+0x58>
 80043f2:	bf00      	nop
 80043f4:	20000256 	.word	0x20000256
 80043f8:	ff42a5f5 	.word	0xff42a5f5
 80043fc:	2000025e 	.word	0x2000025e
 8004400:	20000128 	.word	0x20000128

08004404 <lcd_prepLayers>:
void lcd_prepLayers( void ) {
 8004404:	b570      	push	{r4, r5, r6, lr}
	BSP_LCD_LayerDefaultInit(LCD_BACKGROUND_LAYER, LCD_FRAME_BUFFER);
 8004406:	f04f 4150 	mov.w	r1, #3489660928	; 0xd0000000
 800440a:	2000      	movs	r0, #0
 800440c:	f000 fccc 	bl	8004da8 <BSP_LCD_LayerDefaultInit>
	BSP_LCD_LayerDefaultInit(LCD_FOREGROUND_LAYER, LCD_FRAME_BUFFER+BUFFER_OFFSET);
 8004410:	491c      	ldr	r1, [pc, #112]	; (8004484 <lcd_prepLayers+0x80>)
	lcd_drawRightButton( &button_poly[0], 6, LCD_COLOR_ANDROID_BLUE ) ;
 8004412:	4d1d      	ldr	r5, [pc, #116]	; (8004488 <lcd_prepLayers+0x84>)
 8004414:	4c1d      	ldr	r4, [pc, #116]	; (800448c <lcd_prepLayers+0x88>)
	lcd_drawLeftButton( &button_poly[0], &mirr_poly[0], 6, LCD_COLOR_ANDROID_BLUE ) ;
 8004416:	4e1e      	ldr	r6, [pc, #120]	; (8004490 <lcd_prepLayers+0x8c>)
	BSP_LCD_LayerDefaultInit(LCD_FOREGROUND_LAYER, LCD_FRAME_BUFFER+BUFFER_OFFSET);
 8004418:	2001      	movs	r0, #1
 800441a:	f000 fcc5 	bl	8004da8 <BSP_LCD_LayerDefaultInit>
	BSP_LCD_SetLayerVisible(LCD_FOREGROUND_LAYER, ENABLE);
 800441e:	2101      	movs	r1, #1
 8004420:	4608      	mov	r0, r1
 8004422:	f000 fd07 	bl	8004e34 <BSP_LCD_SetLayerVisible>
	BSP_LCD_SetLayerVisible(LCD_BACKGROUND_LAYER, DISABLE);
 8004426:	2100      	movs	r1, #0
 8004428:	4608      	mov	r0, r1
 800442a:	f000 fd03 	bl	8004e34 <BSP_LCD_SetLayerVisible>
	BSP_LCD_SelectLayer(LCD_FOREGROUND_LAYER);
 800442e:	2001      	movs	r0, #1
 8004430:	f000 fcfa 	bl	8004e28 <BSP_LCD_SelectLayer>
	BSP_LCD_Clear(LCD_COLOR_BLACK);
 8004434:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8004438:	f000 fd2e 	bl	8004e98 <BSP_LCD_Clear>
	lcd_drawRightButton( &button_poly[0], 6, LCD_COLOR_ANDROID_BLUE ) ;
 800443c:	462a      	mov	r2, r5
 800443e:	4620      	mov	r0, r4
 8004440:	2106      	movs	r1, #6
 8004442:	f7ff ff6d 	bl	8004320 <lcd_drawRightButton>
	lcd_drawLeftButton( &button_poly[0], &mirr_poly[0], 6, LCD_COLOR_ANDROID_BLUE ) ;
 8004446:	462b      	mov	r3, r5
 8004448:	4631      	mov	r1, r6
 800444a:	2206      	movs	r2, #6
 800444c:	4620      	mov	r0, r4
 800444e:	f7ff ff7a 	bl	8004346 <lcd_drawLeftButton>
	lcd_drawSlider() ;
 8004452:	f7ff ff4d 	bl	80042f0 <lcd_drawSlider>
	BSP_LCD_SelectLayer(LCD_BACKGROUND_LAYER);
 8004456:	2000      	movs	r0, #0
 8004458:	f000 fce6 	bl	8004e28 <BSP_LCD_SelectLayer>
	BSP_LCD_Clear(LCD_COLOR_BLACK);
 800445c:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8004460:	f000 fd1a 	bl	8004e98 <BSP_LCD_Clear>
	lcd_drawRightButton( &button_poly[0], 6, LCD_COLOR_ANDROID_BLUE ) ;
 8004464:	462a      	mov	r2, r5
 8004466:	4620      	mov	r0, r4
 8004468:	2106      	movs	r1, #6
 800446a:	f7ff ff59 	bl	8004320 <lcd_drawRightButton>
	lcd_drawLeftButton( &button_poly[0], &mirr_poly[0], 6, LCD_COLOR_ANDROID_BLUE ) ;
 800446e:	462b      	mov	r3, r5
 8004470:	4631      	mov	r1, r6
 8004472:	4620      	mov	r0, r4
 8004474:	2206      	movs	r2, #6
 8004476:	f7ff ff66 	bl	8004346 <lcd_drawLeftButton>
}
 800447a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	lcd_drawSlider() ;
 800447e:	f7ff bf37 	b.w	80042f0 <lcd_drawSlider>
 8004482:	bf00      	nop
 8004484:	d0050000 	.word	0xd0050000
 8004488:	ff42a5f5 	.word	0xff42a5f5
 800448c:	20000128 	.word	0x20000128
 8004490:	2000025e 	.word	0x2000025e

08004494 <main>:
extern uint8_t GYRO_Buffer[4];
uint8_t gyro_interval = 0;
#define COMMENT 0

int main(void)
{
 8004494:	b570      	push	{r4, r5, r6, lr}
 8004496:	b09e      	sub	sp, #120	; 0x78
       - Configure the Flash prefetch, instruction and Data caches
       - Configure the Systick to generate an interrupt each 1 msec
       - Set NVIC Group Priority to 4
       - Global MSP (MCU Support Package) initialization
     */
  HAL_Init();
 8004498:	f7fb fee2 	bl	8000260 <HAL_Init>
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_PeriphCLKInitTypeDef  PeriphClkInitStruct;

  /* Enable Power Control clock */
  __PWR_CLK_ENABLE();
 800449c:	4a3f      	ldr	r2, [pc, #252]	; (800459c <main+0x108>)
 800449e:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80044a0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80044a4:	6413      	str	r3, [r2, #64]	; 0x40
  
  /* The voltage scaling allows optimizing the power consumption when the device is 
     clocked below the maximum system frequency, to update the voltage scaling value 
     regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80044a6:	f5a2 32e4 	sub.w	r2, r2, #116736	; 0x1c800

  /*##-1- System Clock Configuration #########################################*/  
  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80044aa:	2502      	movs	r5, #2
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80044ac:	6813      	ldr	r3, [r2, #0]
 80044ae:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80044b2:	6013      	str	r3, [r2, #0]
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80044b4:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80044b8:	930d      	str	r3, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 336;
 80044ba:	f44f 73a8 	mov.w	r3, #336	; 0x150
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80044be:	2401      	movs	r4, #1
  RCC_OscInitStruct.PLL.PLLM = 8;
 80044c0:	2608      	movs	r6, #8
  RCC_OscInitStruct.PLL.PLLN = 336;
 80044c2:	930f      	str	r3, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 80044c4:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.PLL.PLLQ = 7;
 80044c6:	2307      	movs	r3, #7
 80044c8:	9311      	str	r3, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80044ca:	950c      	str	r5, [sp, #48]	; 0x30
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 80044cc:	9510      	str	r5, [sp, #64]	; 0x40
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80044ce:	9406      	str	r4, [sp, #24]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80044d0:	9407      	str	r4, [sp, #28]
  RCC_OscInitStruct.PLL.PLLM = 8;
 80044d2:	960e      	str	r6, [sp, #56]	; 0x38
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 80044d4:	f7fd fc0e 	bl	8001cf4 <HAL_RCC_OscConfig>

  /* Activate the Over-Drive mode */
  HAL_PWREx_ActivateOverDrive();
 80044d8:	f7fd fbd8 	bl	8001c8c <HAL_PWREx_ActivateOverDrive>
  
  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 
     clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 80044dc:	230f      	movs	r3, #15
 80044de:	9301      	str	r3, [sp, #4]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;  
 80044e0:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;  
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 80044e4:	2105      	movs	r1, #5
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80044e6:	9502      	str	r5, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;  
 80044e8:	9304      	str	r3, [sp, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80044ea:	2500      	movs	r5, #0
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;  
 80044ec:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 80044f0:	a801      	add	r0, sp, #4
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80044f2:	9503      	str	r5, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;  
 80044f4:	9305      	str	r3, [sp, #20]
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 80044f6:	f7fd fd99 	bl	800202c <HAL_RCC_ClockConfig>
  /* PLLSAI_VCO Input = HSE_VALUE/PLL_M = 1 Mhz */
  /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN = 192 Mhz */
  /* PLLLCDCLK = PLLSAI_VCO Output/PLLSAIR = 192/4 = 48 Mhz */
  /* LTDC clock frequency = PLLLCDCLK / RCC_PLLSAIDIVR_8 = 48/8 = 6 Mhz */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
  PeriphClkInitStruct.PLLSAI.PLLSAIN = 192;
 80044fa:	23c0      	movs	r3, #192	; 0xc0
 80044fc:	9316      	str	r3, [sp, #88]	; 0x58
  PeriphClkInitStruct.PLLSAI.PLLSAIR = 4;
 80044fe:	2304      	movs	r3, #4
 8004500:	9318      	str	r3, [sp, #96]	; 0x60
  PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_8;
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct); 
 8004502:	a812      	add	r0, sp, #72	; 0x48
  PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_8;
 8004504:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8004508:	931b      	str	r3, [sp, #108]	; 0x6c
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
 800450a:	9612      	str	r6, [sp, #72]	; 0x48
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct); 
 800450c:	f7fd fee8 	bl	80022e0 <HAL_RCCEx_PeriphCLKConfig>
	BSP_GYRO_Init();
 8004510:	f000 fb10 	bl	8004b34 <BSP_GYRO_Init>
	BSP_GYRO_Reset();
 8004514:	f000 fb30 	bl	8004b78 <BSP_GYRO_Reset>
  USBD_Init(&USBD_Device, &HID_Desc, 0);
 8004518:	462a      	mov	r2, r5
 800451a:	4921      	ldr	r1, [pc, #132]	; (80045a0 <main+0x10c>)
 800451c:	4821      	ldr	r0, [pc, #132]	; (80045a4 <main+0x110>)
 800451e:	f7ff f8f9 	bl	8003714 <USBD_Init>
  USBD_RegisterClass(&USBD_Device, USBD_HID_CLASS);
 8004522:	4921      	ldr	r1, [pc, #132]	; (80045a8 <main+0x114>)
 8004524:	481f      	ldr	r0, [pc, #124]	; (80045a4 <main+0x110>)
 8004526:	f7ff f90a 	bl	800373e <USBD_RegisterClass>
	USBD_Start(&USBD_Device);
 800452a:	481e      	ldr	r0, [pc, #120]	; (80045a4 <main+0x110>)
 800452c:	f7ff f90e 	bl	800374c <USBD_Start>
  BSP_LED_Init(LED3);
 8004530:	4628      	mov	r0, r5
 8004532:	f000 f925 	bl	8004780 <BSP_LED_Init>
	BSP_LED_Init(LED4); 
 8004536:	4620      	mov	r0, r4
 8004538:	f000 f922 	bl	8004780 <BSP_LED_Init>
	BSP_LCD_Init();
 800453c:	f000 fb5e 	bl	8004bfc <BSP_LCD_Init>
	lcd_prepLayers() ;
 8004540:	f7ff ff60 	bl	8004404 <lcd_prepLayers>
  status = BSP_TS_Init(BSP_LCD_GetXSize(), BSP_LCD_GetYSize());
 8004544:	f000 fc20 	bl	8004d88 <BSP_LCD_GetXSize>
 8004548:	4605      	mov	r5, r0
 800454a:	f000 fc25 	bl	8004d98 <BSP_LCD_GetYSize>
 800454e:	b281      	uxth	r1, r0
 8004550:	b2a8      	uxth	r0, r5
 8004552:	f000 ffdd 	bl	8005510 <BSP_TS_Init>
	if ( status == TS_OK ) {
 8004556:	b980      	cbnz	r0, 800457a <main+0xe6>
		BSP_TS_Init_extends(TS_I2C_ADDRESS );
 8004558:	2082      	movs	r0, #130	; 0x82
 800455a:	f001 fa45 	bl	80059e8 <BSP_TS_Init_extends>
		if ( 0 == TS_registerNotifyFunc( &lcd_handleMouseNotify ) )
 800455e:	4813      	ldr	r0, [pc, #76]	; (80045ac <main+0x118>)
 8004560:	f001 fa9c 	bl	8005a9c <TS_registerNotifyFunc>
 8004564:	b910      	cbnz	r0, 800456c <main+0xd8>
			BSP_LED_On( LED4 ) ;
 8004566:	4620      	mov	r0, r4
 8004568:	f000 f930 	bl	80047cc <BSP_LED_On>
		if ( 0 == TS_registerNotifyFunc(&usb_handleMouseNotify) ) 
 800456c:	4810      	ldr	r0, [pc, #64]	; (80045b0 <main+0x11c>)
 800456e:	f001 fa95 	bl	8005a9c <TS_registerNotifyFunc>
 8004572:	b910      	cbnz	r0, 800457a <main+0xe6>
			BSP_LED_On( LED4 ) ;
 8004574:	2001      	movs	r0, #1
 8004576:	f000 f929 	bl	80047cc <BSP_LED_On>
		if (gyro_interval >= 1) {
 800457a:	4c0e      	ldr	r4, [pc, #56]	; (80045b4 <main+0x120>)
			gyro_interval = 0;
 800457c:	2500      	movs	r5, #0
		TS_checkEvent( TS_I2C_ADDRESS ) ;
 800457e:	2082      	movs	r0, #130	; 0x82
 8004580:	f001 fb84 	bl	8005c8c <TS_checkEvent>
		lcd_drawAction() ;
 8004584:	f7ff fefa 	bl	800437c <lcd_drawAction>
		GetGyroData();
 8004588:	f001 fc1a 	bl	8005dc0 <GetGyroData>
		if (gyro_interval >= 1) {
 800458c:	7823      	ldrb	r3, [r4, #0]
 800458e:	2b00      	cmp	r3, #0
 8004590:	d0f5      	beq.n	800457e <main+0xea>
			GetPointerData();
 8004592:	f001 fc55 	bl	8005e40 <GetPointerData>
			gyro_interval = 0;
 8004596:	7025      	strb	r5, [r4, #0]
 8004598:	e7f1      	b.n	800457e <main+0xea>
 800459a:	bf00      	nop
 800459c:	40023800 	.word	0x40023800
 80045a0:	20000180 	.word	0x20000180
 80045a4:	20000618 	.word	0x20000618
 80045a8:	20000050 	.word	0x20000050
 80045ac:	08004265 	.word	0x08004265
 80045b0:	08005d85 	.word	0x08005d85
 80045b4:	20000276 	.word	0x20000276

080045b8 <SPIx_Init>:
  * @brief  SPIx Bus initialization
  * @param  None
  * @retval None
  */
static void SPIx_Init(void)
{
 80045b8:	b510      	push	{r4, lr}
  if(HAL_SPI_GetState(&SpiHandle) == HAL_SPI_STATE_RESET)
 80045ba:	4c1b      	ldr	r4, [pc, #108]	; (8004628 <SPIx_Init+0x70>)
{
 80045bc:	b086      	sub	sp, #24
  if(HAL_SPI_GetState(&SpiHandle) == HAL_SPI_STATE_RESET)
 80045be:	4620      	mov	r0, r4
 80045c0:	f7fe fb8c 	bl	8002cdc <HAL_SPI_GetState>
 80045c4:	2800      	cmp	r0, #0
 80045c6:	d12c      	bne.n	8004622 <SPIx_Init+0x6a>
  {
    /* SPI configuration -----------------------------------------------------*/
    SpiHandle.Instance = DISCOVERY_SPIx;
 80045c8:	4b18      	ldr	r3, [pc, #96]	; (800462c <SPIx_Init+0x74>)
 80045ca:	6023      	str	r3, [r4, #0]
       to verify these constraints:
       - ILI9341 LCD SPI interface max baudrate is 10MHz for write and 6.66MHz for read
       - l3gd20 SPI interface max baudrate is 10MHz for write/read
       - PCLK2 frequency is set to 90 MHz 
    */  
    SpiHandle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
 80045cc:	2318      	movs	r3, #24
 80045ce:	61e3      	str	r3, [r4, #28]
    /* Note: To read a register a LCD, SPI_DIRECTION_1LINE should be set */
    SpiHandle.Init.Direction      = SPI_DIRECTION_2LINES;
    SpiHandle.Init.CLKPhase       = SPI_PHASE_1EDGE;
    SpiHandle.Init.CLKPolarity    = SPI_POLARITY_LOW;
    SpiHandle.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
    SpiHandle.Init.CRCPolynomial  = 7;
 80045d0:	2307      	movs	r3, #7
 80045d2:	62e3      	str	r3, [r4, #44]	; 0x2c
    SpiHandle.Init.DataSize       = SPI_DATASIZE_8BIT;
    SpiHandle.Init.FirstBit       = SPI_FIRSTBIT_MSB;
    SpiHandle.Init.NSS            = SPI_NSS_SOFT;
 80045d4:	f44f 7300 	mov.w	r3, #512	; 0x200
 80045d8:	61a3      	str	r3, [r4, #24]
    SpiHandle.Init.TIMode         = SPI_TIMODE_DISABLED;
    SpiHandle.Init.Mode           = SPI_MODE_MASTER;
 80045da:	f44f 7382 	mov.w	r3, #260	; 0x104
 80045de:	6063      	str	r3, [r4, #4]
static void SPIx_MspInit(SPI_HandleTypeDef *hspi)
{
  GPIO_InitTypeDef   GPIO_InitStructure;

  /* Enable SPIx clock */
  DISCOVERY_SPIx_CLK_ENABLE();
 80045e0:	4b13      	ldr	r3, [pc, #76]	; (8004630 <SPIx_Init+0x78>)
    SpiHandle.Init.Direction      = SPI_DIRECTION_2LINES;
 80045e2:	60a0      	str	r0, [r4, #8]
    SpiHandle.Init.CLKPhase       = SPI_PHASE_1EDGE;
 80045e4:	6160      	str	r0, [r4, #20]
    SpiHandle.Init.CLKPolarity    = SPI_POLARITY_LOW;
 80045e6:	6120      	str	r0, [r4, #16]
    SpiHandle.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
 80045e8:	62a0      	str	r0, [r4, #40]	; 0x28
    SpiHandle.Init.DataSize       = SPI_DATASIZE_8BIT;
 80045ea:	60e0      	str	r0, [r4, #12]
    SpiHandle.Init.FirstBit       = SPI_FIRSTBIT_MSB;
 80045ec:	6220      	str	r0, [r4, #32]
    SpiHandle.Init.TIMode         = SPI_TIMODE_DISABLED;
 80045ee:	6260      	str	r0, [r4, #36]	; 0x24
  DISCOVERY_SPIx_CLK_ENABLE();
 80045f0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  GPIO_InitStructure.Pin    = (DISCOVERY_SPIx_SCK_PIN | DISCOVERY_SPIx_MOSI_PIN | DISCOVERY_SPIx_MISO_PIN);
  GPIO_InitStructure.Mode   = GPIO_MODE_AF_PP;
  GPIO_InitStructure.Pull   = GPIO_PULLDOWN;
  GPIO_InitStructure.Speed  = GPIO_SPEED_MEDIUM;
  GPIO_InitStructure.Alternate = DISCOVERY_SPIx_AF;
  HAL_GPIO_Init(DISCOVERY_SPIx_GPIO_PORT, &GPIO_InitStructure);      
 80045f2:	4810      	ldr	r0, [pc, #64]	; (8004634 <SPIx_Init+0x7c>)
  DISCOVERY_SPIx_CLK_ENABLE();
 80045f4:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80045f8:	645a      	str	r2, [r3, #68]	; 0x44
  DISCOVERY_SPIx_GPIO_CLK_ENABLE();
 80045fa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80045fc:	f042 0220 	orr.w	r2, r2, #32
 8004600:	631a      	str	r2, [r3, #48]	; 0x30
  GPIO_InitStructure.Pin    = (DISCOVERY_SPIx_SCK_PIN | DISCOVERY_SPIx_MOSI_PIN | DISCOVERY_SPIx_MISO_PIN);
 8004602:	f44f 7360 	mov.w	r3, #896	; 0x380
 8004606:	9301      	str	r3, [sp, #4]
  GPIO_InitStructure.Mode   = GPIO_MODE_AF_PP;
 8004608:	2302      	movs	r3, #2
 800460a:	9302      	str	r3, [sp, #8]
  GPIO_InitStructure.Pull   = GPIO_PULLDOWN;
 800460c:	9303      	str	r3, [sp, #12]
  GPIO_InitStructure.Speed  = GPIO_SPEED_MEDIUM;
 800460e:	2301      	movs	r3, #1
 8004610:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init(DISCOVERY_SPIx_GPIO_PORT, &GPIO_InitStructure);      
 8004612:	a901      	add	r1, sp, #4
  GPIO_InitStructure.Alternate = DISCOVERY_SPIx_AF;
 8004614:	2305      	movs	r3, #5
 8004616:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(DISCOVERY_SPIx_GPIO_PORT, &GPIO_InitStructure);      
 8004618:	f7fc fa1c 	bl	8000a54 <HAL_GPIO_Init>
    HAL_SPI_Init(&SpiHandle);
 800461c:	4620      	mov	r0, r4
 800461e:	f7fe f82c 	bl	800267a <HAL_SPI_Init>
}
 8004622:	b006      	add	sp, #24
 8004624:	bd10      	pop	{r4, pc}
 8004626:	bf00      	nop
 8004628:	20000278 	.word	0x20000278
 800462c:	40015000 	.word	0x40015000
 8004630:	40023800 	.word	0x40023800
 8004634:	40021400 	.word	0x40021400

08004638 <SPIx_WriteRead>:
{
 8004638:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint8_t receivedbyte = 0;
 800463a:	aa06      	add	r2, sp, #24
 800463c:	2300      	movs	r3, #0
 800463e:	f802 3d01 	strb.w	r3, [r2, #-1]!
  if(HAL_SPI_TransmitReceive(&SpiHandle, (uint8_t*) &Byte, (uint8_t*) &receivedbyte, 1, SpixTimeout) != HAL_OK)
 8004642:	4b0b      	ldr	r3, [pc, #44]	; (8004670 <SPIx_WriteRead+0x38>)
{
 8004644:	f88d 000f 	strb.w	r0, [sp, #15]
  if(HAL_SPI_TransmitReceive(&SpiHandle, (uint8_t*) &Byte, (uint8_t*) &receivedbyte, 1, SpixTimeout) != HAL_OK)
 8004648:	681b      	ldr	r3, [r3, #0]
 800464a:	9300      	str	r3, [sp, #0]
 800464c:	f10d 010f 	add.w	r1, sp, #15
 8004650:	2301      	movs	r3, #1
 8004652:	4808      	ldr	r0, [pc, #32]	; (8004674 <SPIx_WriteRead+0x3c>)
 8004654:	f7fe f90d 	bl	8002872 <HAL_SPI_TransmitReceive>
 8004658:	b120      	cbz	r0, 8004664 <SPIx_WriteRead+0x2c>
  HAL_SPI_DeInit(&SpiHandle);
 800465a:	4806      	ldr	r0, [pc, #24]	; (8004674 <SPIx_WriteRead+0x3c>)
 800465c:	f7fe f848 	bl	80026f0 <HAL_SPI_DeInit>
  SPIx_Init();
 8004660:	f7ff ffaa 	bl	80045b8 <SPIx_Init>
}
 8004664:	f89d 0017 	ldrb.w	r0, [sp, #23]
 8004668:	b007      	add	sp, #28
 800466a:	f85d fb04 	ldr.w	pc, [sp], #4
 800466e:	bf00      	nop
 8004670:	2000014c 	.word	0x2000014c
 8004674:	20000278 	.word	0x20000278

08004678 <I2Cx_Init>:
{
 8004678:	b570      	push	{r4, r5, r6, lr}
  if(HAL_I2C_GetState(&I2cHandle) == HAL_I2C_STATE_RESET)
 800467a:	4c2a      	ldr	r4, [pc, #168]	; (8004724 <I2Cx_Init+0xac>)
{
 800467c:	b086      	sub	sp, #24
  if(HAL_I2C_GetState(&I2cHandle) == HAL_I2C_STATE_RESET)
 800467e:	4620      	mov	r0, r4
 8004680:	f7fc fdd6 	bl	8001230 <HAL_I2C_GetState>
 8004684:	4605      	mov	r5, r0
 8004686:	2800      	cmp	r0, #0
 8004688:	d14a      	bne.n	8004720 <I2Cx_Init+0xa8>
    I2cHandle.Init.ClockSpeed       = I2C_SPEED;
 800468a:	4a27      	ldr	r2, [pc, #156]	; (8004728 <I2Cx_Init+0xb0>)
 800468c:	4b27      	ldr	r3, [pc, #156]	; (800472c <I2Cx_Init+0xb4>)
    DISCOVERY_I2Cx_SDA_GPIO_CLK_ENABLE();
 800468e:	4e28      	ldr	r6, [pc, #160]	; (8004730 <I2Cx_Init+0xb8>)
    I2cHandle.Init.DutyCycle        = I2C_DUTYCYCLE_2;
 8004690:	60a0      	str	r0, [r4, #8]
    I2cHandle.Init.ClockSpeed       = I2C_SPEED;
 8004692:	e884 000c 	stmia.w	r4, {r2, r3}
    I2cHandle.Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
 8004696:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    I2cHandle.Init.OwnAddress1      = 0;
 800469a:	60e0      	str	r0, [r4, #12]
    I2cHandle.Init.DualAddressMode  = I2C_DUALADDRESS_DISABLED;
 800469c:	6160      	str	r0, [r4, #20]
    I2cHandle.Init.OwnAddress2      = 0;
 800469e:	61a0      	str	r0, [r4, #24]
    I2cHandle.Init.GeneralCallMode  = I2C_GENERALCALL_DISABLED;
 80046a0:	61e0      	str	r0, [r4, #28]
    I2cHandle.Init.NoStretchMode    = I2C_NOSTRETCH_DISABLED;  
 80046a2:	6220      	str	r0, [r4, #32]
    I2cHandle.Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
 80046a4:	6123      	str	r3, [r4, #16]
    DISCOVERY_I2Cx_SDA_GPIO_CLK_ENABLE();
 80046a6:	6b33      	ldr	r3, [r6, #48]	; 0x30
 80046a8:	f043 0304 	orr.w	r3, r3, #4
 80046ac:	6333      	str	r3, [r6, #48]	; 0x30
    DISCOVERY_I2Cx_SCL_GPIO_CLK_ENABLE();
 80046ae:	6b33      	ldr	r3, [r6, #48]	; 0x30
 80046b0:	f043 0301 	orr.w	r3, r3, #1
 80046b4:	6333      	str	r3, [r6, #48]	; 0x30
    GPIO_InitStruct.Pin       = DISCOVERY_I2Cx_SCL_PIN;
 80046b6:	f44f 7380 	mov.w	r3, #256	; 0x100
 80046ba:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode      = GPIO_MODE_AF_OD;
 80046bc:	2312      	movs	r3, #18
 80046be:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
 80046c0:	2302      	movs	r3, #2
 80046c2:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = DISCOVERY_I2Cx_SCL_SDA_AF;
 80046c4:	2304      	movs	r3, #4
    HAL_GPIO_Init(DISCOVERY_I2Cx_SCL_GPIO_PORT, &GPIO_InitStruct);
 80046c6:	eb0d 0103 	add.w	r1, sp, r3
    GPIO_InitStruct.Pull      = GPIO_NOPULL;
 80046ca:	9003      	str	r0, [sp, #12]
    HAL_GPIO_Init(DISCOVERY_I2Cx_SCL_GPIO_PORT, &GPIO_InitStruct);
 80046cc:	4819      	ldr	r0, [pc, #100]	; (8004734 <I2Cx_Init+0xbc>)
    GPIO_InitStruct.Alternate = DISCOVERY_I2Cx_SCL_SDA_AF;
 80046ce:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(DISCOVERY_I2Cx_SCL_GPIO_PORT, &GPIO_InitStruct);
 80046d0:	f7fc f9c0 	bl	8000a54 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = DISCOVERY_I2Cx_SDA_PIN;
 80046d4:	f44f 7300 	mov.w	r3, #512	; 0x200
    HAL_GPIO_Init(DISCOVERY_I2Cx_SDA_GPIO_PORT, &GPIO_InitStruct);
 80046d8:	a901      	add	r1, sp, #4
 80046da:	4817      	ldr	r0, [pc, #92]	; (8004738 <I2Cx_Init+0xc0>)
    GPIO_InitStruct.Pin = DISCOVERY_I2Cx_SDA_PIN;
 80046dc:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(DISCOVERY_I2Cx_SDA_GPIO_PORT, &GPIO_InitStruct);
 80046de:	f7fc f9b9 	bl	8000a54 <HAL_GPIO_Init>
    DISCOVERY_I2Cx_CLOCK_ENABLE();
 80046e2:	6c33      	ldr	r3, [r6, #64]	; 0x40
 80046e4:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80046e8:	6433      	str	r3, [r6, #64]	; 0x40
    DISCOVERY_I2Cx_FORCE_RESET();
 80046ea:	6a33      	ldr	r3, [r6, #32]
 80046ec:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80046f0:	6233      	str	r3, [r6, #32]
    DISCOVERY_I2Cx_RELEASE_RESET(); 
 80046f2:	6a33      	ldr	r3, [r6, #32]
 80046f4:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 80046f8:	6233      	str	r3, [r6, #32]
    HAL_NVIC_SetPriority(DISCOVERY_I2Cx_EV_IRQn, 0x00, 0);
 80046fa:	462a      	mov	r2, r5
 80046fc:	4629      	mov	r1, r5
 80046fe:	2048      	movs	r0, #72	; 0x48
 8004700:	f7fb fdf6 	bl	80002f0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DISCOVERY_I2Cx_EV_IRQn);
 8004704:	2048      	movs	r0, #72	; 0x48
 8004706:	f7fb fe27 	bl	8000358 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(DISCOVERY_I2Cx_ER_IRQn, 0x00, 0);
 800470a:	462a      	mov	r2, r5
 800470c:	4629      	mov	r1, r5
 800470e:	2049      	movs	r0, #73	; 0x49
 8004710:	f7fb fdee 	bl	80002f0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DISCOVERY_I2Cx_ER_IRQn);  
 8004714:	2049      	movs	r0, #73	; 0x49
 8004716:	f7fb fe1f 	bl	8000358 <HAL_NVIC_EnableIRQ>
    HAL_I2C_Init(&I2cHandle);
 800471a:	4620      	mov	r0, r4
 800471c:	f7fc fbba 	bl	8000e94 <HAL_I2C_Init>
}
 8004720:	b006      	add	sp, #24
 8004722:	bd70      	pop	{r4, r5, r6, pc}
 8004724:	2000083c 	.word	0x2000083c
 8004728:	40005c00 	.word	0x40005c00
 800472c:	000186a0 	.word	0x000186a0
 8004730:	40023800 	.word	0x40023800
 8004734:	40020000 	.word	0x40020000
 8004738:	40020800 	.word	0x40020800

0800473c <I2Cx_Error>:
{
 800473c:	b508      	push	{r3, lr}
  HAL_I2C_DeInit(&I2cHandle);
 800473e:	4803      	ldr	r0, [pc, #12]	; (800474c <I2Cx_Error+0x10>)
 8004740:	f7fc fc11 	bl	8000f66 <HAL_I2C_DeInit>
}
 8004744:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  I2Cx_Init();
 8004748:	f7ff bf96 	b.w	8004678 <I2Cx_Init>
 800474c:	2000083c 	.word	0x2000083c

08004750 <SPIx_Write>:
{
 8004750:	b507      	push	{r0, r1, r2, lr}
  status = HAL_SPI_Transmit(&SpiHandle, (uint8_t*) &Value, 1, SpixTimeout);
 8004752:	4b09      	ldr	r3, [pc, #36]	; (8004778 <SPIx_Write+0x28>)
{
 8004754:	a902      	add	r1, sp, #8
  status = HAL_SPI_Transmit(&SpiHandle, (uint8_t*) &Value, 1, SpixTimeout);
 8004756:	681b      	ldr	r3, [r3, #0]
{
 8004758:	f821 0d02 	strh.w	r0, [r1, #-2]!
  status = HAL_SPI_Transmit(&SpiHandle, (uint8_t*) &Value, 1, SpixTimeout);
 800475c:	2201      	movs	r2, #1
 800475e:	4807      	ldr	r0, [pc, #28]	; (800477c <SPIx_Write+0x2c>)
 8004760:	f7fd ffda 	bl	8002718 <HAL_SPI_Transmit>
  if(status != HAL_OK)
 8004764:	b120      	cbz	r0, 8004770 <SPIx_Write+0x20>
  HAL_SPI_DeInit(&SpiHandle);
 8004766:	4805      	ldr	r0, [pc, #20]	; (800477c <SPIx_Write+0x2c>)
 8004768:	f7fd ffc2 	bl	80026f0 <HAL_SPI_DeInit>
  SPIx_Init();
 800476c:	f7ff ff24 	bl	80045b8 <SPIx_Init>
}
 8004770:	b003      	add	sp, #12
 8004772:	f85d fb04 	ldr.w	pc, [sp], #4
 8004776:	bf00      	nop
 8004778:	2000014c 	.word	0x2000014c
 800477c:	20000278 	.word	0x20000278

08004780 <BSP_LED_Init>:
{
 8004780:	4b0f      	ldr	r3, [pc, #60]	; (80047c0 <BSP_LED_Init+0x40>)
 8004782:	b570      	push	{r4, r5, r6, lr}
  LEDx_GPIO_CLK_ENABLE(Led);
 8004784:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 8004786:	4d0f      	ldr	r5, [pc, #60]	; (80047c4 <BSP_LED_Init+0x44>)
  LEDx_GPIO_CLK_ENABLE(Led);
 8004788:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800478c:	631a      	str	r2, [r3, #48]	; 0x30
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 800478e:	4b0e      	ldr	r3, [pc, #56]	; (80047c8 <BSP_LED_Init+0x48>)
{
 8004790:	b086      	sub	sp, #24
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 8004792:	f833 6010 	ldrh.w	r6, [r3, r0, lsl #1]
 8004796:	9601      	str	r6, [sp, #4]
  LEDx_GPIO_CLK_ENABLE(Led);
 8004798:	4604      	mov	r4, r0
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800479a:	2301      	movs	r3, #1
 800479c:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 800479e:	9303      	str	r3, [sp, #12]
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 80047a0:	a901      	add	r1, sp, #4
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
 80047a2:	2302      	movs	r3, #2
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 80047a4:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
 80047a8:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 80047aa:	f7fc f953 	bl	8000a54 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET); 
 80047ae:	2200      	movs	r2, #0
 80047b0:	4631      	mov	r1, r6
 80047b2:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 80047b6:	f7fc fa2f 	bl	8000c18 <HAL_GPIO_WritePin>
}
 80047ba:	b006      	add	sp, #24
 80047bc:	bd70      	pop	{r4, r5, r6, pc}
 80047be:	bf00      	nop
 80047c0:	40023800 	.word	0x40023800
 80047c4:	20000140 	.word	0x20000140
 80047c8:	08006488 	.word	0x08006488

080047cc <BSP_LED_On>:
  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_SET); 
 80047cc:	4b04      	ldr	r3, [pc, #16]	; (80047e0 <BSP_LED_On+0x14>)
 80047ce:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 80047d2:	4b04      	ldr	r3, [pc, #16]	; (80047e4 <BSP_LED_On+0x18>)
 80047d4:	2201      	movs	r2, #1
 80047d6:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 80047da:	f7fc ba1d 	b.w	8000c18 <HAL_GPIO_WritePin>
 80047de:	bf00      	nop
 80047e0:	08006488 	.word	0x08006488
 80047e4:	20000140 	.word	0x20000140

080047e8 <LCD_IO_Init>:
  * @brief  Configures the LCD_SPI interface.
  * @param  None
  * @retval None
  */
void LCD_IO_Init(void)
{
 80047e8:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStructure;
  
  if(Is_LCD_IO_Initialized == 0)
 80047ea:	4b20      	ldr	r3, [pc, #128]	; (800486c <LCD_IO_Init+0x84>)
 80047ec:	781e      	ldrb	r6, [r3, #0]
{
 80047ee:	b087      	sub	sp, #28
  if(Is_LCD_IO_Initialized == 0)
 80047f0:	2e00      	cmp	r6, #0
 80047f2:	d139      	bne.n	8004868 <LCD_IO_Init+0x80>
  {
    Is_LCD_IO_Initialized = 1; 
    
    /* Configure NCS in Output Push-Pull mode */
    LCD_WRX_GPIO_CLK_ENABLE();
 80047f4:	4c1e      	ldr	r4, [pc, #120]	; (8004870 <LCD_IO_Init+0x88>)
    GPIO_InitStructure.Pin     = LCD_WRX_PIN;
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_WRX_GPIO_PORT, &GPIO_InitStructure);
 80047f6:	481f      	ldr	r0, [pc, #124]	; (8004874 <LCD_IO_Init+0x8c>)
    Is_LCD_IO_Initialized = 1; 
 80047f8:	2501      	movs	r5, #1
 80047fa:	701d      	strb	r5, [r3, #0]
    LCD_WRX_GPIO_CLK_ENABLE();
 80047fc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80047fe:	f043 0308 	orr.w	r3, r3, #8
 8004802:	6323      	str	r3, [r4, #48]	; 0x30
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
 8004804:	2702      	movs	r7, #2
    GPIO_InitStructure.Pin     = LCD_WRX_PIN;
 8004806:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    HAL_GPIO_Init(LCD_WRX_GPIO_PORT, &GPIO_InitStructure);
 800480a:	a901      	add	r1, sp, #4
    GPIO_InitStructure.Pin     = LCD_WRX_PIN;
 800480c:	9301      	str	r3, [sp, #4]
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
 800480e:	9502      	str	r5, [sp, #8]
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
 8004810:	9603      	str	r6, [sp, #12]
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
 8004812:	9704      	str	r7, [sp, #16]
    HAL_GPIO_Init(LCD_WRX_GPIO_PORT, &GPIO_InitStructure);
 8004814:	f7fc f91e 	bl	8000a54 <HAL_GPIO_Init>
    
    LCD_RDX_GPIO_CLK_ENABLE();
 8004818:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStructure.Pin     = LCD_RDX_PIN;
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_RDX_GPIO_PORT, &GPIO_InitStructure);
 800481a:	4816      	ldr	r0, [pc, #88]	; (8004874 <LCD_IO_Init+0x8c>)
    LCD_RDX_GPIO_CLK_ENABLE();
 800481c:	f043 0308 	orr.w	r3, r3, #8
 8004820:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_GPIO_Init(LCD_RDX_GPIO_PORT, &GPIO_InitStructure);
 8004822:	a901      	add	r1, sp, #4
    GPIO_InitStructure.Pin     = LCD_RDX_PIN;
 8004824:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8004828:	9301      	str	r3, [sp, #4]
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
 800482a:	9502      	str	r5, [sp, #8]
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
 800482c:	9603      	str	r6, [sp, #12]
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
 800482e:	9704      	str	r7, [sp, #16]
    HAL_GPIO_Init(LCD_RDX_GPIO_PORT, &GPIO_InitStructure);
 8004830:	f7fc f910 	bl	8000a54 <HAL_GPIO_Init>
    
    /* Configure the LCD Control pins ----------------------------------------*/
    LCD_NCS_GPIO_CLK_ENABLE();
 8004834:	6b23      	ldr	r3, [r4, #48]	; 0x30
    /* Configure NCS in Output Push-Pull mode */
    GPIO_InitStructure.Pin     = LCD_NCS_PIN;
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_NCS_GPIO_PORT, &GPIO_InitStructure);
 8004836:	4810      	ldr	r0, [pc, #64]	; (8004878 <LCD_IO_Init+0x90>)
    LCD_NCS_GPIO_CLK_ENABLE();
 8004838:	f043 0304 	orr.w	r3, r3, #4
 800483c:	6323      	str	r3, [r4, #48]	; 0x30
    GPIO_InitStructure.Pin     = LCD_NCS_PIN;
 800483e:	2404      	movs	r4, #4
    HAL_GPIO_Init(LCD_NCS_GPIO_PORT, &GPIO_InitStructure);
 8004840:	eb0d 0104 	add.w	r1, sp, r4
    GPIO_InitStructure.Pin     = LCD_NCS_PIN;
 8004844:	9401      	str	r4, [sp, #4]
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
 8004846:	9502      	str	r5, [sp, #8]
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
 8004848:	9603      	str	r6, [sp, #12]
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
 800484a:	9704      	str	r7, [sp, #16]
    HAL_GPIO_Init(LCD_NCS_GPIO_PORT, &GPIO_InitStructure);
 800484c:	f7fc f902 	bl	8000a54 <HAL_GPIO_Init>
    
    /* Set or Reset the control line */
    LCD_CS_LOW();
 8004850:	4632      	mov	r2, r6
 8004852:	4621      	mov	r1, r4
 8004854:	4808      	ldr	r0, [pc, #32]	; (8004878 <LCD_IO_Init+0x90>)
 8004856:	f7fc f9df 	bl	8000c18 <HAL_GPIO_WritePin>
    LCD_CS_HIGH();
 800485a:	462a      	mov	r2, r5
 800485c:	4621      	mov	r1, r4
 800485e:	4806      	ldr	r0, [pc, #24]	; (8004878 <LCD_IO_Init+0x90>)
 8004860:	f7fc f9da 	bl	8000c18 <HAL_GPIO_WritePin>
    
    SPIx_Init();
 8004864:	f7ff fea8 	bl	80045b8 <SPIx_Init>
  }
}
 8004868:	b007      	add	sp, #28
 800486a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800486c:	20000277 	.word	0x20000277
 8004870:	40023800 	.word	0x40023800
 8004874:	40020c00 	.word	0x40020c00
 8004878:	40020800 	.word	0x40020800

0800487c <LCD_IO_WriteData>:
  * @brief  Writes register value.
  * @param  None
  * @retval None
  */
void LCD_IO_WriteData(uint16_t RegValue) 
{
 800487c:	b538      	push	{r3, r4, r5, lr}
  /* Set WRX to send data */
  LCD_WRX_HIGH();
  
  /* Reset LCD control line(/CS) and Send data */  
  LCD_CS_LOW();
 800487e:	4c0b      	ldr	r4, [pc, #44]	; (80048ac <LCD_IO_WriteData+0x30>)
{
 8004880:	4605      	mov	r5, r0
  LCD_WRX_HIGH();
 8004882:	2201      	movs	r2, #1
 8004884:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8004888:	4809      	ldr	r0, [pc, #36]	; (80048b0 <LCD_IO_WriteData+0x34>)
 800488a:	f7fc f9c5 	bl	8000c18 <HAL_GPIO_WritePin>
  LCD_CS_LOW();
 800488e:	2200      	movs	r2, #0
 8004890:	2104      	movs	r1, #4
 8004892:	4620      	mov	r0, r4
 8004894:	f7fc f9c0 	bl	8000c18 <HAL_GPIO_WritePin>
  SPIx_Write(RegValue);
 8004898:	4628      	mov	r0, r5
 800489a:	f7ff ff59 	bl	8004750 <SPIx_Write>
  
  /* Deselect: Chip Select high */
  LCD_CS_HIGH();
 800489e:	4620      	mov	r0, r4
 80048a0:	2201      	movs	r2, #1
 80048a2:	2104      	movs	r1, #4
}
 80048a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  LCD_CS_HIGH();
 80048a8:	f7fc b9b6 	b.w	8000c18 <HAL_GPIO_WritePin>
 80048ac:	40020800 	.word	0x40020800
 80048b0:	40020c00 	.word	0x40020c00

080048b4 <LCD_IO_WriteReg>:
  * @brief  Writes register address.
  * @param  None
  * @retval None
  */
void LCD_IO_WriteReg(uint8_t Reg) 
{
 80048b4:	b538      	push	{r3, r4, r5, lr}
  /* Reset WRX to send command */
  LCD_WRX_LOW();
  
  /* Reset LCD control line(/CS) and Send command */
  LCD_CS_LOW();
 80048b6:	4c0b      	ldr	r4, [pc, #44]	; (80048e4 <LCD_IO_WriteReg+0x30>)
{
 80048b8:	4605      	mov	r5, r0
  LCD_WRX_LOW();
 80048ba:	2200      	movs	r2, #0
 80048bc:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80048c0:	4809      	ldr	r0, [pc, #36]	; (80048e8 <LCD_IO_WriteReg+0x34>)
 80048c2:	f7fc f9a9 	bl	8000c18 <HAL_GPIO_WritePin>
  LCD_CS_LOW();
 80048c6:	2200      	movs	r2, #0
 80048c8:	2104      	movs	r1, #4
 80048ca:	4620      	mov	r0, r4
 80048cc:	f7fc f9a4 	bl	8000c18 <HAL_GPIO_WritePin>
  SPIx_Write(Reg);
 80048d0:	4628      	mov	r0, r5
 80048d2:	f7ff ff3d 	bl	8004750 <SPIx_Write>
  
  /* Deselect: Chip Select high */
  LCD_CS_HIGH();
 80048d6:	4620      	mov	r0, r4
 80048d8:	2201      	movs	r2, #1
 80048da:	2104      	movs	r1, #4
}
 80048dc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  LCD_CS_HIGH();
 80048e0:	f7fc b99a 	b.w	8000c18 <HAL_GPIO_WritePin>
 80048e4:	40020800 	.word	0x40020800
 80048e8:	40020c00 	.word	0x40020c00

080048ec <LCD_IO_ReadData>:
  * @param  RegValue Address of the register to read
  * @param  ReadSize Number of bytes to read
  * @retval Content of the register value
  */
uint32_t LCD_IO_ReadData(uint16_t RegValue, uint8_t ReadSize) 
{
 80048ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80048ee:	4605      	mov	r5, r0
 80048f0:	460c      	mov	r4, r1
  uint32_t readvalue = 0;

  /* Select: Chip Select low */
  LCD_CS_LOW();
 80048f2:	2200      	movs	r2, #0
 80048f4:	2104      	movs	r1, #4
 80048f6:	4814      	ldr	r0, [pc, #80]	; (8004948 <LCD_IO_ReadData+0x5c>)
 80048f8:	f7fc f98e 	bl	8000c18 <HAL_GPIO_WritePin>

  /* Reset WRX to send command */
  LCD_WRX_LOW();
 80048fc:	2200      	movs	r2, #0
 80048fe:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8004902:	4812      	ldr	r0, [pc, #72]	; (800494c <LCD_IO_ReadData+0x60>)
 8004904:	f7fc f988 	bl	8000c18 <HAL_GPIO_WritePin>
  
  SPIx_Write(RegValue);
 8004908:	4628      	mov	r0, r5
 800490a:	f7ff ff21 	bl	8004750 <SPIx_Write>
  status = HAL_SPI_Receive(&SpiHandle, (uint8_t*) &readvalue, ReadSize, SpixTimeout);
 800490e:	4b10      	ldr	r3, [pc, #64]	; (8004950 <LCD_IO_ReadData+0x64>)
 8004910:	4810      	ldr	r0, [pc, #64]	; (8004954 <LCD_IO_ReadData+0x68>)
 8004912:	681b      	ldr	r3, [r3, #0]
 8004914:	4622      	mov	r2, r4
 8004916:	a901      	add	r1, sp, #4
 8004918:	f7fe f8f9 	bl	8002b0e <HAL_SPI_Receive>
  if(status != HAL_OK)
 800491c:	b120      	cbz	r0, 8004928 <LCD_IO_ReadData+0x3c>
  HAL_SPI_DeInit(&SpiHandle);
 800491e:	480d      	ldr	r0, [pc, #52]	; (8004954 <LCD_IO_ReadData+0x68>)
 8004920:	f7fd fee6 	bl	80026f0 <HAL_SPI_DeInit>
  SPIx_Init();
 8004924:	f7ff fe48 	bl	80045b8 <SPIx_Init>
  
  readvalue = SPIx_Read(ReadSize);

  /* Set WRX to send data */
  LCD_WRX_HIGH();
 8004928:	2201      	movs	r2, #1
 800492a:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 800492e:	4807      	ldr	r0, [pc, #28]	; (800494c <LCD_IO_ReadData+0x60>)
  return readvalue;
 8004930:	9c01      	ldr	r4, [sp, #4]
  LCD_WRX_HIGH();
 8004932:	f7fc f971 	bl	8000c18 <HAL_GPIO_WritePin>

  /* Deselect: Chip Select high */
  LCD_CS_HIGH();
 8004936:	2201      	movs	r2, #1
 8004938:	2104      	movs	r1, #4
 800493a:	4803      	ldr	r0, [pc, #12]	; (8004948 <LCD_IO_ReadData+0x5c>)
 800493c:	f7fc f96c 	bl	8000c18 <HAL_GPIO_WritePin>
  
  return readvalue;
}
 8004940:	4620      	mov	r0, r4
 8004942:	b003      	add	sp, #12
 8004944:	bd30      	pop	{r4, r5, pc}
 8004946:	bf00      	nop
 8004948:	40020800 	.word	0x40020800
 800494c:	40020c00 	.word	0x40020c00
 8004950:	2000014c 	.word	0x2000014c
 8004954:	20000278 	.word	0x20000278

08004958 <LCD_Delay>:
 8004958:	f7fb bcaa 	b.w	80002b0 <HAL_Delay>

0800495c <IOE_Init>:
  * @param  None
  * @retval None
  */
void IOE_Init(void) 
{
  I2Cx_Init();
 800495c:	f7ff be8c 	b.w	8004678 <I2Cx_Init>

08004960 <IOE_ITConfig>:
  * @brief  IOE Low Level Interrupt configuration.
  * @param  None
  * @retval None
  */
void IOE_ITConfig(void)
{
 8004960:	b510      	push	{r4, lr}
  STMPE811_INT_CLK_ENABLE();
 8004962:	4a0e      	ldr	r2, [pc, #56]	; (800499c <IOE_ITConfig+0x3c>)
  HAL_GPIO_Init(STMPE811_INT_GPIO_PORT, &GPIO_InitStruct);
 8004964:	480e      	ldr	r0, [pc, #56]	; (80049a0 <IOE_ITConfig+0x40>)
  STMPE811_INT_CLK_ENABLE();
 8004966:	6b13      	ldr	r3, [r2, #48]	; 0x30
{
 8004968:	b086      	sub	sp, #24
  STMPE811_INT_CLK_ENABLE();
 800496a:	f043 0301 	orr.w	r3, r3, #1
 800496e:	6313      	str	r3, [r2, #48]	; 0x30
  GPIO_InitStruct.Pin   = STMPE811_INT_PIN;
 8004970:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8004974:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull  = GPIO_PULLUP;
 8004976:	2301      	movs	r3, #1
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 8004978:	2400      	movs	r4, #0
  GPIO_InitStruct.Pull  = GPIO_PULLUP;
 800497a:	9303      	str	r3, [sp, #12]
  HAL_GPIO_Init(STMPE811_INT_GPIO_PORT, &GPIO_InitStruct);
 800497c:	a901      	add	r1, sp, #4
  GPIO_InitStruct.Mode  = GPIO_MODE_IT_FALLING;
 800497e:	4b09      	ldr	r3, [pc, #36]	; (80049a4 <IOE_ITConfig+0x44>)
 8004980:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 8004982:	9404      	str	r4, [sp, #16]
  HAL_GPIO_Init(STMPE811_INT_GPIO_PORT, &GPIO_InitStruct);
 8004984:	f7fc f866 	bl	8000a54 <HAL_GPIO_Init>
  HAL_NVIC_SetPriority((IRQn_Type)(STMPE811_INT_EXTI), 0x00, 0x00);
 8004988:	4622      	mov	r2, r4
 800498a:	4621      	mov	r1, r4
 800498c:	2028      	movs	r0, #40	; 0x28
 800498e:	f7fb fcaf 	bl	80002f0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ((IRQn_Type)(STMPE811_INT_EXTI));
 8004992:	2028      	movs	r0, #40	; 0x28
 8004994:	f7fb fce0 	bl	8000358 <HAL_NVIC_EnableIRQ>
  I2Cx_ITConfig();
}
 8004998:	b006      	add	sp, #24
 800499a:	bd10      	pop	{r4, pc}
 800499c:	40023800 	.word	0x40023800
 80049a0:	40020000 	.word	0x40020000
 80049a4:	10210000 	.word	0x10210000

080049a8 <IOE_Write>:
  * @param  Reg: Reg Address 
  * @param  Value: Data to be written
  * @retval None
  */
void IOE_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
{
 80049a8:	b510      	push	{r4, lr}
 80049aa:	b086      	sub	sp, #24
 80049ac:	ac06      	add	r4, sp, #24
  status = HAL_I2C_Mem_Write(&I2cHandle, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, &Value, 1, I2cxTimeout); 
 80049ae:	4b09      	ldr	r3, [pc, #36]	; (80049d4 <IOE_Write+0x2c>)
 80049b0:	f804 2d01 	strb.w	r2, [r4, #-1]!
 80049b4:	681b      	ldr	r3, [r3, #0]
 80049b6:	9302      	str	r3, [sp, #8]
 80049b8:	2301      	movs	r3, #1
 80049ba:	460a      	mov	r2, r1
 80049bc:	9301      	str	r3, [sp, #4]
 80049be:	4601      	mov	r1, r0
 80049c0:	9400      	str	r4, [sp, #0]
 80049c2:	4805      	ldr	r0, [pc, #20]	; (80049d8 <IOE_Write+0x30>)
 80049c4:	f7fc fae6 	bl	8000f94 <HAL_I2C_Mem_Write>
  if(status != HAL_OK)
 80049c8:	b108      	cbz	r0, 80049ce <IOE_Write+0x26>
    I2Cx_Error();
 80049ca:	f7ff feb7 	bl	800473c <I2Cx_Error>
  I2Cx_WriteData(Addr, Reg, Value);
}
 80049ce:	b006      	add	sp, #24
 80049d0:	bd10      	pop	{r4, pc}
 80049d2:	bf00      	nop
 80049d4:	20000148 	.word	0x20000148
 80049d8:	2000083c 	.word	0x2000083c

080049dc <IOE_Read>:
  * @param  Addr: I2C Address
  * @param  Reg: Reg Address 
  * @retval The read data
  */
uint8_t IOE_Read(uint8_t Addr, uint8_t Reg)
{
 80049dc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint8_t value = 0;
 80049de:	aa06      	add	r2, sp, #24
 80049e0:	2300      	movs	r3, #0
 80049e2:	f802 3d01 	strb.w	r3, [r2, #-1]!
  status = HAL_I2C_Mem_Read(&I2cHandle, Addr, Reg, I2C_MEMADD_SIZE_8BIT, &value, 1, I2cxTimeout);
 80049e6:	4b09      	ldr	r3, [pc, #36]	; (8004a0c <IOE_Read+0x30>)
 80049e8:	681b      	ldr	r3, [r3, #0]
 80049ea:	9302      	str	r3, [sp, #8]
 80049ec:	2301      	movs	r3, #1
 80049ee:	e88d 000c 	stmia.w	sp, {r2, r3}
 80049f2:	460a      	mov	r2, r1
 80049f4:	4601      	mov	r1, r0
 80049f6:	4806      	ldr	r0, [pc, #24]	; (8004a10 <IOE_Read+0x34>)
 80049f8:	f7fc fb42 	bl	8001080 <HAL_I2C_Mem_Read>
  if(status != HAL_OK)
 80049fc:	b108      	cbz	r0, 8004a02 <IOE_Read+0x26>
    I2Cx_Error();
 80049fe:	f7ff fe9d 	bl	800473c <I2Cx_Error>
  return I2Cx_ReadData(Addr, Reg);
}
 8004a02:	f89d 0017 	ldrb.w	r0, [sp, #23]
 8004a06:	b007      	add	sp, #28
 8004a08:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a0c:	20000148 	.word	0x20000148
 8004a10:	2000083c 	.word	0x2000083c

08004a14 <IOE_ReadMultiple>:
  * @param  pBuffer: pointer to data buffer
  * @param  Length: length of the data
  * @retval 0 if no problems to read multiple data
  */
uint16_t IOE_ReadMultiple(uint8_t Addr, uint8_t Reg, uint8_t *pBuffer, uint16_t Length)
{
 8004a14:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  status = HAL_I2C_Mem_Read(&I2cHandle, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Length, I2cxTimeout);
 8004a16:	4c08      	ldr	r4, [pc, #32]	; (8004a38 <IOE_ReadMultiple+0x24>)
 8004a18:	6824      	ldr	r4, [r4, #0]
 8004a1a:	e88d 001c 	stmia.w	sp, {r2, r3, r4}
 8004a1e:	460a      	mov	r2, r1
 8004a20:	2301      	movs	r3, #1
 8004a22:	4601      	mov	r1, r0
 8004a24:	4805      	ldr	r0, [pc, #20]	; (8004a3c <IOE_ReadMultiple+0x28>)
 8004a26:	f7fc fb2b 	bl	8001080 <HAL_I2C_Mem_Read>
  if(status == HAL_OK)
 8004a2a:	b110      	cbz	r0, 8004a32 <IOE_ReadMultiple+0x1e>
    I2Cx_Error();
 8004a2c:	f7ff fe86 	bl	800473c <I2Cx_Error>
    return 1;
 8004a30:	2001      	movs	r0, #1
 return I2Cx_ReadBuffer(Addr, Reg, pBuffer, Length);
}
 8004a32:	b004      	add	sp, #16
 8004a34:	bd10      	pop	{r4, pc}
 8004a36:	bf00      	nop
 8004a38:	20000148 	.word	0x20000148
 8004a3c:	2000083c 	.word	0x2000083c

08004a40 <IOE_Delay>:
  * @param  Delay in ms
  * @retval None
  */
void IOE_Delay(uint32_t Delay)
{
  HAL_Delay(Delay);
 8004a40:	f7fb bc36 	b.w	80002b0 <HAL_Delay>

08004a44 <GYRO_IO_Init>:
  * @brief  Configures the Gyroscope SPI interface.
  * @param  None
  * @retval None
  */
void GYRO_IO_Init(void)
{
 8004a44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  GPIO_InitTypeDef GPIO_InitStructure;
  
  /* Configure the Gyroscope Control pins ------------------------------------*/
  /* Enable CS GPIO clock and Configure GPIO PIN for Gyroscope Chip select */  
  GYRO_CS_GPIO_CLK_ENABLE();  
 8004a48:	4c14      	ldr	r4, [pc, #80]	; (8004a9c <GYRO_IO_Init+0x58>)
  GPIO_InitStructure.Pin = GYRO_CS_PIN;
  GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStructure.Pull  = GPIO_NOPULL;
  GPIO_InitStructure.Speed = GPIO_SPEED_MEDIUM;
  HAL_GPIO_Init(GYRO_CS_GPIO_PORT, &GPIO_InitStructure);
 8004a4a:	f8df 8058 	ldr.w	r8, [pc, #88]	; 8004aa4 <GYRO_IO_Init+0x60>
  GYRO_CS_GPIO_CLK_ENABLE();  
 8004a4e:	6b23      	ldr	r3, [r4, #48]	; 0x30
{
 8004a50:	b086      	sub	sp, #24
  GYRO_CS_GPIO_CLK_ENABLE();  
 8004a52:	f043 0304 	orr.w	r3, r3, #4
 8004a56:	6323      	str	r3, [r4, #48]	; 0x30
  GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
 8004a58:	2701      	movs	r7, #1
  GPIO_InitStructure.Pin = GYRO_CS_PIN;
 8004a5a:	2602      	movs	r6, #2
  GPIO_InitStructure.Pull  = GPIO_NOPULL;
 8004a5c:	2500      	movs	r5, #0
  HAL_GPIO_Init(GYRO_CS_GPIO_PORT, &GPIO_InitStructure);
 8004a5e:	a901      	add	r1, sp, #4
 8004a60:	4640      	mov	r0, r8
  GPIO_InitStructure.Pin = GYRO_CS_PIN;
 8004a62:	9601      	str	r6, [sp, #4]
  GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
 8004a64:	9702      	str	r7, [sp, #8]
  GPIO_InitStructure.Pull  = GPIO_NOPULL;
 8004a66:	9503      	str	r5, [sp, #12]
  GPIO_InitStructure.Speed = GPIO_SPEED_MEDIUM;
 8004a68:	9704      	str	r7, [sp, #16]
  HAL_GPIO_Init(GYRO_CS_GPIO_PORT, &GPIO_InitStructure);
 8004a6a:	f7fb fff3 	bl	8000a54 <HAL_GPIO_Init>
  
  /* Deselect: Chip Select high */
  GYRO_CS_HIGH();
 8004a6e:	463a      	mov	r2, r7
 8004a70:	4631      	mov	r1, r6
 8004a72:	4640      	mov	r0, r8
 8004a74:	f7fc f8d0 	bl	8000c18 <HAL_GPIO_WritePin>
  
  /* Enable INT1, INT2 GPIO clock and Configure GPIO PINs to detect Interrupts */
  GYRO_INT_GPIO_CLK_ENABLE();
 8004a78:	6b23      	ldr	r3, [r4, #48]	; 0x30
  GPIO_InitStructure.Pin = GYRO_INT1_PIN | GYRO_INT2_PIN;
  GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
  GPIO_InitStructure.Speed = GPIO_SPEED_FAST;
  GPIO_InitStructure.Pull= GPIO_NOPULL;
  HAL_GPIO_Init(GYRO_INT_GPIO_PORT, &GPIO_InitStructure);
 8004a7a:	4809      	ldr	r0, [pc, #36]	; (8004aa0 <GYRO_IO_Init+0x5c>)
  GYRO_INT_GPIO_CLK_ENABLE();
 8004a7c:	433b      	orrs	r3, r7
 8004a7e:	6323      	str	r3, [r4, #48]	; 0x30
  HAL_GPIO_Init(GYRO_INT_GPIO_PORT, &GPIO_InitStructure);
 8004a80:	a901      	add	r1, sp, #4
  GPIO_InitStructure.Pin = GYRO_INT1_PIN | GYRO_INT2_PIN;
 8004a82:	2306      	movs	r3, #6
 8004a84:	9301      	str	r3, [sp, #4]
  GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
 8004a86:	9502      	str	r5, [sp, #8]
  GPIO_InitStructure.Speed = GPIO_SPEED_FAST;
 8004a88:	9604      	str	r6, [sp, #16]
  GPIO_InitStructure.Pull= GPIO_NOPULL;
 8004a8a:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GYRO_INT_GPIO_PORT, &GPIO_InitStructure);
 8004a8c:	f7fb ffe2 	bl	8000a54 <HAL_GPIO_Init>

  SPIx_Init();
 8004a90:	f7ff fd92 	bl	80045b8 <SPIx_Init>
}
 8004a94:	b006      	add	sp, #24
 8004a96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004a9a:	bf00      	nop
 8004a9c:	40023800 	.word	0x40023800
 8004aa0:	40020000 	.word	0x40020000
 8004aa4:	40020800 	.word	0x40020800

08004aa8 <GYRO_IO_Write>:
{
  /* Configure the MS bit: 
       - When 0, the address will remain unchanged in multiple read/write commands.
       - When 1, the address will be auto incremented in multiple read/write commands.
  */
  if(NumByteToWrite > 0x01)
 8004aa8:	2a01      	cmp	r2, #1
{
 8004aaa:	b570      	push	{r4, r5, r6, lr}
 8004aac:	460d      	mov	r5, r1
 8004aae:	4606      	mov	r6, r0
  {
    WriteAddr |= (uint8_t)MULTIPLEBYTE_CMD;
 8004ab0:	bf88      	it	hi
 8004ab2:	f041 0540 	orrhi.w	r5, r1, #64	; 0x40
  }
  /* Set chip select Low at the start of the transmission */
  GYRO_CS_LOW();
 8004ab6:	480c      	ldr	r0, [pc, #48]	; (8004ae8 <GYRO_IO_Write+0x40>)
{
 8004ab8:	4614      	mov	r4, r2
  GYRO_CS_LOW();
 8004aba:	2102      	movs	r1, #2
 8004abc:	2200      	movs	r2, #0
 8004abe:	f7fc f8ab 	bl	8000c18 <HAL_GPIO_WritePin>
  
  /* Send the Address of the indexed register */
  SPIx_WriteRead(WriteAddr);
 8004ac2:	4628      	mov	r0, r5
 8004ac4:	f7ff fdb8 	bl	8004638 <SPIx_WriteRead>
  
  /* Send the data that will be written into the device (MSB First) */
  while(NumByteToWrite >= 0x01)
 8004ac8:	b934      	cbnz	r4, 8004ad8 <GYRO_IO_Write+0x30>
    NumByteToWrite--;
    pBuffer++;
  }
  
  /* Set chip select High at the end of the transmission */ 
  GYRO_CS_HIGH();
 8004aca:	2201      	movs	r2, #1
 8004acc:	2102      	movs	r1, #2
 8004ace:	4806      	ldr	r0, [pc, #24]	; (8004ae8 <GYRO_IO_Write+0x40>)
}
 8004ad0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  GYRO_CS_HIGH();
 8004ad4:	f7fc b8a0 	b.w	8000c18 <HAL_GPIO_WritePin>
    SPIx_WriteRead(*pBuffer);
 8004ad8:	f816 0b01 	ldrb.w	r0, [r6], #1
    NumByteToWrite--;
 8004adc:	3c01      	subs	r4, #1
    SPIx_WriteRead(*pBuffer);
 8004ade:	f7ff fdab 	bl	8004638 <SPIx_WriteRead>
    NumByteToWrite--;
 8004ae2:	b2a4      	uxth	r4, r4
 8004ae4:	e7f0      	b.n	8004ac8 <GYRO_IO_Write+0x20>
 8004ae6:	bf00      	nop
 8004ae8:	40020800 	.word	0x40020800

08004aec <GYRO_IO_Read>:
  * @param  NumByteToRead: Number of bytes to read from the Gyroscope.
  * @retval None
  */
void GYRO_IO_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{  
  if(NumByteToRead > 0x01)
 8004aec:	2a01      	cmp	r2, #1
{  
 8004aee:	b570      	push	{r4, r5, r6, lr}
  {
    ReadAddr |= (uint8_t)(READWRITE_CMD | MULTIPLEBYTE_CMD);
 8004af0:	bf8c      	ite	hi
 8004af2:	f041 05c0 	orrhi.w	r5, r1, #192	; 0xc0
  }
  else
  {
    ReadAddr |= (uint8_t)READWRITE_CMD;
 8004af6:	f041 0580 	orrls.w	r5, r1, #128	; 0x80
{  
 8004afa:	4606      	mov	r6, r0
 8004afc:	4614      	mov	r4, r2
  }
  /* Set chip select Low at the start of the transmission */
  GYRO_CS_LOW();
 8004afe:	480c      	ldr	r0, [pc, #48]	; (8004b30 <GYRO_IO_Read+0x44>)
 8004b00:	2200      	movs	r2, #0
 8004b02:	2102      	movs	r1, #2
 8004b04:	f7fc f888 	bl	8000c18 <HAL_GPIO_WritePin>
  
  /* Send the Address of the indexed register */
  SPIx_WriteRead(ReadAddr);
 8004b08:	4628      	mov	r0, r5
 8004b0a:	f7ff fd95 	bl	8004638 <SPIx_WriteRead>
  
  /* Receive the data that will be read from the device (MSB First) */
  while(NumByteToRead > 0x00)
 8004b0e:	b934      	cbnz	r4, 8004b1e <GYRO_IO_Read+0x32>
    NumByteToRead--;
    pBuffer++;
  }
  
  /* Set chip select High at the end of the transmission */ 
  GYRO_CS_HIGH();
 8004b10:	2201      	movs	r2, #1
 8004b12:	2102      	movs	r1, #2
 8004b14:	4806      	ldr	r0, [pc, #24]	; (8004b30 <GYRO_IO_Read+0x44>)
}  
 8004b16:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  GYRO_CS_HIGH();
 8004b1a:	f7fc b87d 	b.w	8000c18 <HAL_GPIO_WritePin>
    *pBuffer = SPIx_WriteRead(DUMMY_BYTE);
 8004b1e:	2000      	movs	r0, #0
 8004b20:	f7ff fd8a 	bl	8004638 <SPIx_WriteRead>
    NumByteToRead--;
 8004b24:	3c01      	subs	r4, #1
    *pBuffer = SPIx_WriteRead(DUMMY_BYTE);
 8004b26:	f806 0b01 	strb.w	r0, [r6], #1
    NumByteToRead--;
 8004b2a:	b2a4      	uxth	r4, r4
 8004b2c:	e7ef      	b.n	8004b0e <GYRO_IO_Read+0x22>
 8004b2e:	bf00      	nop
 8004b30:	40020800 	.word	0x40020800

08004b34 <BSP_GYRO_Init>:
  * @brief  Set Gyroscope Initialization.
  * @param  None
  * @retval GYRO_OK if no problem during initialization
  */
uint8_t BSP_GYRO_Init(void)
{  
 8004b34:	b538      	push	{r3, r4, r5, lr}
  uint8_t ret = GYRO_ERROR;
  uint16_t ctrl = 0x0000;
  GYRO_InitTypeDef L3GD20_InitStructure;
  GYRO_FilterConfigTypeDef L3GD20_FilterStructure={0,0};

  if((L3gd20Drv.ReadID() == I_AM_L3GD20) || (L3gd20Drv.ReadID() == I_AM_L3GD20_TR))
 8004b36:	4c0e      	ldr	r4, [pc, #56]	; (8004b70 <BSP_GYRO_Init+0x3c>)
 8004b38:	6863      	ldr	r3, [r4, #4]
 8004b3a:	4798      	blx	r3
 8004b3c:	28d4      	cmp	r0, #212	; 0xd4
 8004b3e:	4625      	mov	r5, r4
 8004b40:	d10f      	bne.n	8004b62 <BSP_GYRO_Init+0x2e>
  {	
    /* Initialize the Gyroscope driver structure */
    GyroscopeDrv = &L3gd20Drv;
 8004b42:	4c0c      	ldr	r4, [pc, #48]	; (8004b74 <BSP_GYRO_Init+0x40>)

    ctrl |= (uint16_t) ((L3GD20_InitStructure.BlockData_Update | L3GD20_InitStructure.Endianness | \
                         L3GD20_InitStructure.Full_Scale) << 8);
    
    /* Configure the Gyroscope main parameters */	 
    GyroscopeDrv->Init(ctrl);
 8004b44:	682b      	ldr	r3, [r5, #0]
    GyroscopeDrv = &L3gd20Drv;
 8004b46:	6025      	str	r5, [r4, #0]
    GyroscopeDrv->Init(ctrl);
 8004b48:	f242 003f 	movw	r0, #8255	; 0x203f
 8004b4c:	4798      	blx	r3

    ctrl = (uint8_t) ((L3GD20_FilterStructure.HighPassFilter_Mode_Selection |\
                       L3GD20_FilterStructure.HighPassFilter_CutOff_Frequency));

    /* Configure the Gyroscope main parameters */
    GyroscopeDrv->FilterConfig(ctrl) ;
 8004b4e:	6823      	ldr	r3, [r4, #0]
 8004b50:	2000      	movs	r0, #0
 8004b52:	6a1b      	ldr	r3, [r3, #32]
 8004b54:	4798      	blx	r3

    GyroscopeDrv->FilterCmd(L3GD20_HIGHPASSFILTER_ENABLE);
 8004b56:	6823      	ldr	r3, [r4, #0]
 8004b58:	2010      	movs	r0, #16
 8004b5a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004b5c:	4798      	blx	r3

    ret = GYRO_OK;
 8004b5e:	2000      	movs	r0, #0
 8004b60:	bd38      	pop	{r3, r4, r5, pc}
  if((L3gd20Drv.ReadID() == I_AM_L3GD20) || (L3gd20Drv.ReadID() == I_AM_L3GD20_TR))
 8004b62:	6863      	ldr	r3, [r4, #4]
 8004b64:	4798      	blx	r3
 8004b66:	28d5      	cmp	r0, #213	; 0xd5
 8004b68:	d0eb      	beq.n	8004b42 <BSP_GYRO_Init+0xe>
  }
  else
  {
    ret = GYRO_ERROR;
 8004b6a:	2001      	movs	r0, #1
  }
  return ret;
}
 8004b6c:	bd38      	pop	{r3, r4, r5, pc}
 8004b6e:	bf00      	nop
 8004b70:	200000fc 	.word	0x200000fc
 8004b74:	200002cc 	.word	0x200002cc

08004b78 <BSP_GYRO_Reset>:
  * @param  None
  * @retval None
  */
void BSP_GYRO_Reset(void)
{
  if(GyroscopeDrv->Reset != NULL)
 8004b78:	4b02      	ldr	r3, [pc, #8]	; (8004b84 <BSP_GYRO_Reset+0xc>)
 8004b7a:	681b      	ldr	r3, [r3, #0]
 8004b7c:	689b      	ldr	r3, [r3, #8]
 8004b7e:	b103      	cbz	r3, 8004b82 <BSP_GYRO_Reset+0xa>
  {
    GyroscopeDrv->Reset();
 8004b80:	4718      	bx	r3
 8004b82:	4770      	bx	lr
 8004b84:	200002cc 	.word	0x200002cc

08004b88 <BSP_GYRO_GetXYZ>:
  * @param  pfData: pointer on floating array         
  * @retval None
  */
void BSP_GYRO_GetXYZ(float *pfData)
{
  if(GyroscopeDrv->GetXYZ!= NULL)
 8004b88:	4b02      	ldr	r3, [pc, #8]	; (8004b94 <BSP_GYRO_GetXYZ+0xc>)
 8004b8a:	681b      	ldr	r3, [r3, #0]
 8004b8c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004b8e:	b103      	cbz	r3, 8004b92 <BSP_GYRO_GetXYZ+0xa>
  {
    GyroscopeDrv->GetXYZ(pfData);
 8004b90:	4718      	bx	r3
 8004b92:	4770      	bx	lr
 8004b94:	200002cc 	.word	0x200002cc

08004b98 <FillBuffer>:
  * @param  OffLine: offset
  * @param  ColorIndex: color Index  
  * @retval None
  */
static void FillBuffer(uint32_t LayerIndex, void * pDst, uint32_t xSize, uint32_t ySize, uint32_t OffLine, uint32_t ColorIndex) 
{
 8004b98:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  
  /* Register to memory mode with ARGB8888 as color Mode */ 
  Dma2dHandler.Init.Mode         = DMA2D_R2M;
 8004b9c:	4c15      	ldr	r4, [pc, #84]	; (8004bf4 <FillBuffer+0x5c>)
{
 8004b9e:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8004ba0:	4698      	mov	r8, r3
  Dma2dHandler.Init.Mode         = DMA2D_R2M;
 8004ba2:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8004ba6:	6063      	str	r3, [r4, #4]
  Dma2dHandler.Init.ColorMode    = DMA2D_ARGB8888;
 8004ba8:	2300      	movs	r3, #0
 8004baa:	60a3      	str	r3, [r4, #8]
  Dma2dHandler.Init.OutputOffset = OffLine;      
 8004bac:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8004bae:	60e3      	str	r3, [r4, #12]
{
 8004bb0:	4681      	mov	r9, r0
  
  Dma2dHandler.Instance = DMA2D; 
 8004bb2:	4b11      	ldr	r3, [pc, #68]	; (8004bf8 <FillBuffer+0x60>)
 8004bb4:	6023      	str	r3, [r4, #0]
  
  /* DMA2D Initialization */
  if(HAL_DMA2D_Init(&Dma2dHandler) == HAL_OK) 
 8004bb6:	4620      	mov	r0, r4
{
 8004bb8:	460e      	mov	r6, r1
 8004bba:	4617      	mov	r7, r2
  if(HAL_DMA2D_Init(&Dma2dHandler) == HAL_OK) 
 8004bbc:	f7fb fe31 	bl	8000822 <HAL_DMA2D_Init>
 8004bc0:	b9a0      	cbnz	r0, 8004bec <FillBuffer+0x54>
  {
    if(HAL_DMA2D_ConfigLayer(&Dma2dHandler, LayerIndex) == HAL_OK) 
 8004bc2:	4649      	mov	r1, r9
 8004bc4:	4620      	mov	r0, r4
 8004bc6:	f7fb fed5 	bl	8000974 <HAL_DMA2D_ConfigLayer>
 8004bca:	b978      	cbnz	r0, 8004bec <FillBuffer+0x54>
    {
      if (HAL_DMA2D_Start(&Dma2dHandler, ColorIndex, (uint32_t)pDst, xSize, ySize) == HAL_OK)
 8004bcc:	f8cd 8000 	str.w	r8, [sp]
 8004bd0:	463b      	mov	r3, r7
 8004bd2:	4632      	mov	r2, r6
 8004bd4:	4629      	mov	r1, r5
 8004bd6:	4620      	mov	r0, r4
 8004bd8:	f7fb fe4b 	bl	8000872 <HAL_DMA2D_Start>
 8004bdc:	b930      	cbnz	r0, 8004bec <FillBuffer+0x54>
      {
        /* Polling For DMA transfer */  
        HAL_DMA2D_PollForTransfer(&Dma2dHandler, 10);
 8004bde:	210a      	movs	r1, #10
 8004be0:	4620      	mov	r0, r4
      }
    }
  } 
}
 8004be2:	b003      	add	sp, #12
 8004be4:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        HAL_DMA2D_PollForTransfer(&Dma2dHandler, 10);
 8004be8:	f7fb be63 	b.w	80008b2 <HAL_DMA2D_PollForTransfer>
}
 8004bec:	b003      	add	sp, #12
 8004bee:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8004bf2:	bf00      	nop
 8004bf4:	200002d4 	.word	0x200002d4
 8004bf8:	4002b000 	.word	0x4002b000

08004bfc <BSP_LCD_Init>:
{ 
 8004bfc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    LtdcHandler.Instance = LTDC;
 8004c00:	4c52      	ldr	r4, [pc, #328]	; (8004d4c <BSP_LCD_Init+0x150>)
 8004c02:	4b53      	ldr	r3, [pc, #332]	; (8004d50 <BSP_LCD_Init+0x154>)
 8004c04:	6023      	str	r3, [r4, #0]
    LtdcHandler.Init.VerticalSync = ILI9341_VSYNC;
 8004c06:	2301      	movs	r3, #1
 8004c08:	61a3      	str	r3, [r4, #24]
    LtdcHandler.Init.AccumulatedHBP = ILI9341_HBP;
 8004c0a:	231d      	movs	r3, #29
 8004c0c:	61e3      	str	r3, [r4, #28]
    LtdcHandler.Init.AccumulatedActiveW = 269;
 8004c0e:	f240 130d 	movw	r3, #269	; 0x10d
 8004c12:	6263      	str	r3, [r4, #36]	; 0x24
    LtdcHandler.Init.AccumulatedActiveH = 323;
 8004c14:	f240 1343 	movw	r3, #323	; 0x143
 8004c18:	62a3      	str	r3, [r4, #40]	; 0x28
    LtdcHandler.Init.TotalWidth = 279;
 8004c1a:	f240 1317 	movw	r3, #279	; 0x117
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
 8004c1e:	484d      	ldr	r0, [pc, #308]	; (8004d54 <BSP_LCD_Init+0x158>)
    LtdcHandler.Init.TotalWidth = 279;
 8004c20:	62e3      	str	r3, [r4, #44]	; 0x2c
    LtdcHandler.Init.TotalHeigh = 327;
 8004c22:	f240 1347 	movw	r3, #327	; 0x147
 8004c26:	6323      	str	r3, [r4, #48]	; 0x30
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
 8004c28:	2308      	movs	r3, #8
 8004c2a:	6003      	str	r3, [r0, #0]
    PeriphClkInitStruct.PLLSAI.PLLSAIN = 192;
 8004c2c:	23c0      	movs	r3, #192	; 0xc0
 8004c2e:	6103      	str	r3, [r0, #16]
    PeriphClkInitStruct.PLLSAI.PLLSAIR = 4;
 8004c30:	2304      	movs	r3, #4
{ 
 8004c32:	b087      	sub	sp, #28
    LtdcHandler.Init.Backcolor.Red= 0;
 8004c34:	2500      	movs	r5, #0
    LtdcHandler.Init.HorizontalSync = ILI9341_HSYNC;
 8004c36:	2609      	movs	r6, #9
    LtdcHandler.Init.AccumulatedVBP = ILI9341_VBP;
 8004c38:	2703      	movs	r7, #3
    PeriphClkInitStruct.PLLSAI.PLLSAIR = 4;
 8004c3a:	6183      	str	r3, [r0, #24]
    PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_8;
 8004c3c:	f44f 3300 	mov.w	r3, #131072	; 0x20000
    LtdcHandler.Init.HorizontalSync = ILI9341_HSYNC;
 8004c40:	6166      	str	r6, [r4, #20]
    LtdcHandler.Init.AccumulatedVBP = ILI9341_VBP;
 8004c42:	6227      	str	r7, [r4, #32]
    LtdcHandler.Init.Backcolor.Red= 0;
 8004c44:	f884 5036 	strb.w	r5, [r4, #54]	; 0x36
    LtdcHandler.Init.Backcolor.Blue= 0;
 8004c48:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
    LtdcHandler.Init.Backcolor.Green= 0;
 8004c4c:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
    PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_8;
 8004c50:	6243      	str	r3, [r0, #36]	; 0x24
    HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct); 
 8004c52:	f7fd fb45 	bl	80022e0 <HAL_RCCEx_PeriphCLKConfig>
  __LTDC_CLK_ENABLE();
 8004c56:	4b40      	ldr	r3, [pc, #256]	; (8004d58 <BSP_LCD_Init+0x15c>)
    LtdcHandler.Init.HSPolarity = LTDC_HSPOLARITY_AL;
 8004c58:	6065      	str	r5, [r4, #4]
    LtdcHandler.Init.VSPolarity = LTDC_VSPOLARITY_AL;
 8004c5a:	60a5      	str	r5, [r4, #8]
    LtdcHandler.Init.DEPolarity = LTDC_DEPOLARITY_AL;
 8004c5c:	60e5      	str	r5, [r4, #12]
    LtdcHandler.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
 8004c5e:	6125      	str	r5, [r4, #16]
  __LTDC_CLK_ENABLE();
 8004c60:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
 8004c62:	f8df 911c 	ldr.w	r9, [pc, #284]	; 8004d80 <BSP_LCD_Init+0x184>
  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004c66:	483d      	ldr	r0, [pc, #244]	; (8004d5c <BSP_LCD_Init+0x160>)
  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
 8004c68:	f8df 8118 	ldr.w	r8, [pc, #280]	; 8004d84 <BSP_LCD_Init+0x188>
  __LTDC_CLK_ENABLE();
 8004c6c:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8004c70:	645a      	str	r2, [r3, #68]	; 0x44
  __DMA2D_CLK_ENABLE(); 
 8004c72:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004c74:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8004c78:	631a      	str	r2, [r3, #48]	; 0x30
  __GPIOA_CLK_ENABLE();
 8004c7a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004c7c:	f042 0201 	orr.w	r2, r2, #1
 8004c80:	631a      	str	r2, [r3, #48]	; 0x30
  __GPIOB_CLK_ENABLE();
 8004c82:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004c84:	f042 0202 	orr.w	r2, r2, #2
 8004c88:	631a      	str	r2, [r3, #48]	; 0x30
  __GPIOC_CLK_ENABLE();
 8004c8a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004c8c:	f042 0204 	orr.w	r2, r2, #4
 8004c90:	631a      	str	r2, [r3, #48]	; 0x30
  __GPIOD_CLK_ENABLE();
 8004c92:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004c94:	f042 0208 	orr.w	r2, r2, #8
 8004c98:	631a      	str	r2, [r3, #48]	; 0x30
  __GPIOF_CLK_ENABLE();
 8004c9a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004c9c:	f042 0220 	orr.w	r2, r2, #32
 8004ca0:	631a      	str	r2, [r3, #48]	; 0x30
  __GPIOG_CLK_ENABLE();
 8004ca2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004ca4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8004ca8:	631a      	str	r2, [r3, #48]	; 0x30
  GPIO_InitStructure.Pin = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6 |
 8004caa:	f641 0358 	movw	r3, #6232	; 0x1858
 8004cae:	9301      	str	r3, [sp, #4]
  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
 8004cb0:	2302      	movs	r3, #2
 8004cb2:	9302      	str	r3, [sp, #8]
  GPIO_InitStructure.Speed = GPIO_SPEED_FAST;
 8004cb4:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004cb6:	a901      	add	r1, sp, #4
  GPIO_InitStructure.Alternate= GPIO_AF14_LTDC;
 8004cb8:	230e      	movs	r3, #14
 8004cba:	9305      	str	r3, [sp, #20]
  GPIO_InitStructure.Pull = GPIO_NOPULL;
 8004cbc:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004cbe:	f7fb fec9 	bl	8000a54 <HAL_GPIO_Init>
  GPIO_InitStructure.Pin = GPIO_PIN_8 | \
 8004cc2:	f44f 6370 	mov.w	r3, #3840	; 0xf00
  HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
 8004cc6:	a901      	add	r1, sp, #4
 8004cc8:	4648      	mov	r0, r9
  GPIO_InitStructure.Pin = GPIO_PIN_8 | \
 8004cca:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
 8004ccc:	f7fb fec2 	bl	8000a54 <HAL_GPIO_Init>
  GPIO_InitStructure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_10;
 8004cd0:	f44f 6398 	mov.w	r3, #1216	; 0x4c0
  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 8004cd4:	a901      	add	r1, sp, #4
 8004cd6:	4822      	ldr	r0, [pc, #136]	; (8004d60 <BSP_LCD_Init+0x164>)
  GPIO_InitStructure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_10;
 8004cd8:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 8004cda:	f7fb febb 	bl	8000a54 <HAL_GPIO_Init>
  GPIO_InitStructure.Pin = GPIO_PIN_3 | GPIO_PIN_6;
 8004cde:	2348      	movs	r3, #72	; 0x48
  HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);
 8004ce0:	a901      	add	r1, sp, #4
 8004ce2:	4820      	ldr	r0, [pc, #128]	; (8004d64 <BSP_LCD_Init+0x168>)
  GPIO_InitStructure.Pin = GPIO_PIN_3 | GPIO_PIN_6;
 8004ce4:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);
 8004ce6:	f7fb feb5 	bl	8000a54 <HAL_GPIO_Init>
  GPIO_InitStructure.Pin = GPIO_PIN_10;
 8004cea:	f44f 6380 	mov.w	r3, #1024	; 0x400
  HAL_GPIO_Init(GPIOF, &GPIO_InitStructure);     
 8004cee:	a901      	add	r1, sp, #4
 8004cf0:	481d      	ldr	r0, [pc, #116]	; (8004d68 <BSP_LCD_Init+0x16c>)
  GPIO_InitStructure.Pin = GPIO_PIN_10;
 8004cf2:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOF, &GPIO_InitStructure);     
 8004cf4:	f7fb feae 	bl	8000a54 <HAL_GPIO_Init>
  GPIO_InitStructure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | \
 8004cf8:	f44f 630c 	mov.w	r3, #2240	; 0x8c0
  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
 8004cfc:	a901      	add	r1, sp, #4
 8004cfe:	4640      	mov	r0, r8
  GPIO_InitStructure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | \
 8004d00:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
 8004d02:	f7fb fea7 	bl	8000a54 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
 8004d06:	a901      	add	r1, sp, #4
 8004d08:	4648      	mov	r0, r9
  GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1;
 8004d0a:	9701      	str	r7, [sp, #4]
  GPIO_InitStructure.Alternate= GPIO_AF9_LTDC;
 8004d0c:	9605      	str	r6, [sp, #20]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
 8004d0e:	f7fb fea1 	bl	8000a54 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
 8004d12:	a901      	add	r1, sp, #4
  GPIO_InitStructure.Pin = GPIO_PIN_10 | GPIO_PIN_12;
 8004d14:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
 8004d18:	4640      	mov	r0, r8
  GPIO_InitStructure.Pin = GPIO_PIN_10 | GPIO_PIN_12;
 8004d1a:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
 8004d1c:	f7fb fe9a 	bl	8000a54 <HAL_GPIO_Init>
    HAL_LTDC_Init(&LtdcHandler); 
 8004d20:	4620      	mov	r0, r4
 8004d22:	f7fc fb05 	bl	8001330 <HAL_LTDC_Init>
    LcdDrv = &ili9341_drv;
 8004d26:	4a11      	ldr	r2, [pc, #68]	; (8004d6c <BSP_LCD_Init+0x170>)
 8004d28:	4b11      	ldr	r3, [pc, #68]	; (8004d70 <BSP_LCD_Init+0x174>)
 8004d2a:	6013      	str	r3, [r2, #0]
    LcdDrv->Init();
 8004d2c:	681b      	ldr	r3, [r3, #0]
 8004d2e:	4798      	blx	r3
    BSP_SDRAM_Init();
 8004d30:	f000 fb2a 	bl	8005388 <BSP_SDRAM_Init>
  DrawProp[ActiveLayer].pFont = pFonts;
 8004d34:	4b0f      	ldr	r3, [pc, #60]	; (8004d74 <BSP_LCD_Init+0x178>)
 8004d36:	4a10      	ldr	r2, [pc, #64]	; (8004d78 <BSP_LCD_Init+0x17c>)
 8004d38:	681b      	ldr	r3, [r3, #0]
 8004d3a:	210c      	movs	r1, #12
 8004d3c:	fb01 2303 	mla	r3, r1, r3, r2
 8004d40:	4a0e      	ldr	r2, [pc, #56]	; (8004d7c <BSP_LCD_Init+0x180>)
 8004d42:	609a      	str	r2, [r3, #8]
}  
 8004d44:	4628      	mov	r0, r5
 8004d46:	b007      	add	sp, #28
 8004d48:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8004d4c:	2000032c 	.word	0x2000032c
 8004d50:	40016800 	.word	0x40016800
 8004d54:	200003d4 	.word	0x200003d4
 8004d58:	40023800 	.word	0x40023800
 8004d5c:	40020000 	.word	0x40020000
 8004d60:	40020800 	.word	0x40020800
 8004d64:	40020c00 	.word	0x40020c00
 8004d68:	40021400 	.word	0x40021400
 8004d6c:	20000874 	.word	0x20000874
 8004d70:	200000c4 	.word	0x200000c4
 8004d74:	200002d0 	.word	0x200002d0
 8004d78:	20000314 	.word	0x20000314
 8004d7c:	20000150 	.word	0x20000150
 8004d80:	40020400 	.word	0x40020400
 8004d84:	40021800 	.word	0x40021800

08004d88 <BSP_LCD_GetXSize>:
{
 8004d88:	b508      	push	{r3, lr}
  return LcdDrv->GetLcdPixelWidth();
 8004d8a:	4b02      	ldr	r3, [pc, #8]	; (8004d94 <BSP_LCD_GetXSize+0xc>)
 8004d8c:	681b      	ldr	r3, [r3, #0]
 8004d8e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004d90:	4798      	blx	r3
}
 8004d92:	bd08      	pop	{r3, pc}
 8004d94:	20000874 	.word	0x20000874

08004d98 <BSP_LCD_GetYSize>:
{
 8004d98:	b508      	push	{r3, lr}
  return LcdDrv->GetLcdPixelHeight();
 8004d9a:	4b02      	ldr	r3, [pc, #8]	; (8004da4 <BSP_LCD_GetYSize+0xc>)
 8004d9c:	681b      	ldr	r3, [r3, #0]
 8004d9e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004da0:	4798      	blx	r3
}
 8004da2:	bd08      	pop	{r3, pc}
 8004da4:	20000874 	.word	0x20000874

08004da8 <BSP_LCD_LayerDefaultInit>:
{     
 8004da8:	b570      	push	{r4, r5, r6, lr}
 8004daa:	b08e      	sub	sp, #56	; 0x38
  Layercfg.WindowX0 = 0;
 8004dac:	2400      	movs	r4, #0
{     
 8004dae:	460e      	mov	r6, r1
 8004db0:	4605      	mov	r5, r0
  Layercfg.WindowX0 = 0;
 8004db2:	9401      	str	r4, [sp, #4]
  Layercfg.WindowX1 = BSP_LCD_GetXSize();
 8004db4:	f7ff ffe8 	bl	8004d88 <BSP_LCD_GetXSize>
  Layercfg.WindowY0 = 0;
 8004db8:	9403      	str	r4, [sp, #12]
  Layercfg.WindowX1 = BSP_LCD_GetXSize();
 8004dba:	9002      	str	r0, [sp, #8]
  Layercfg.WindowY1 = BSP_LCD_GetYSize(); 
 8004dbc:	f7ff ffec 	bl	8004d98 <BSP_LCD_GetYSize>
  Layercfg.Alpha = 255;
 8004dc0:	23ff      	movs	r3, #255	; 0xff
 8004dc2:	9306      	str	r3, [sp, #24]
  Layercfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
 8004dc4:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8004dc8:	9308      	str	r3, [sp, #32]
  Layercfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
 8004dca:	2307      	movs	r3, #7
 8004dcc:	9309      	str	r3, [sp, #36]	; 0x24
  Layercfg.PixelFormat = LTDC_PIXEL_FORMAT_ARGB8888;
 8004dce:	9405      	str	r4, [sp, #20]
  Layercfg.Alpha0 = 0;
 8004dd0:	9407      	str	r4, [sp, #28]
  Layercfg.Backcolor.Blue = 0;
 8004dd2:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
  Layercfg.Backcolor.Green = 0;
 8004dd6:	f88d 4035 	strb.w	r4, [sp, #53]	; 0x35
  Layercfg.Backcolor.Red = 0;
 8004dda:	f88d 4036 	strb.w	r4, [sp, #54]	; 0x36
  Layercfg.WindowY1 = BSP_LCD_GetYSize(); 
 8004dde:	9004      	str	r0, [sp, #16]
  Layercfg.FBStartAdress = FB_Address;
 8004de0:	960a      	str	r6, [sp, #40]	; 0x28
  Layercfg.ImageWidth = BSP_LCD_GetXSize();
 8004de2:	f7ff ffd1 	bl	8004d88 <BSP_LCD_GetXSize>
 8004de6:	900b      	str	r0, [sp, #44]	; 0x2c
  Layercfg.ImageHeight = BSP_LCD_GetYSize();
 8004de8:	f7ff ffd6 	bl	8004d98 <BSP_LCD_GetYSize>
  HAL_LTDC_ConfigLayer(&LtdcHandler, &Layercfg, LayerIndex); 
 8004dec:	4c0b      	ldr	r4, [pc, #44]	; (8004e1c <BSP_LCD_LayerDefaultInit+0x74>)
  Layercfg.ImageHeight = BSP_LCD_GetYSize();
 8004dee:	900c      	str	r0, [sp, #48]	; 0x30
  HAL_LTDC_ConfigLayer(&LtdcHandler, &Layercfg, LayerIndex); 
 8004df0:	462a      	mov	r2, r5
 8004df2:	a901      	add	r1, sp, #4
 8004df4:	4620      	mov	r0, r4
 8004df6:	f7fc fb07 	bl	8001408 <HAL_LTDC_ConfigLayer>
  DrawProp[LayerIndex].BackColor = LCD_COLOR_WHITE;
 8004dfa:	4b09      	ldr	r3, [pc, #36]	; (8004e20 <BSP_LCD_LayerDefaultInit+0x78>)
 8004dfc:	200c      	movs	r0, #12
 8004dfe:	4368      	muls	r0, r5
 8004e00:	181a      	adds	r2, r3, r0
 8004e02:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8004e06:	6051      	str	r1, [r2, #4]
  DrawProp[LayerIndex].pFont     = &Font24;
 8004e08:	4906      	ldr	r1, [pc, #24]	; (8004e24 <BSP_LCD_LayerDefaultInit+0x7c>)
 8004e0a:	6091      	str	r1, [r2, #8]
  DrawProp[LayerIndex].TextColor = LCD_COLOR_BLACK; 
 8004e0c:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000
 8004e10:	501a      	str	r2, [r3, r0]
  HAL_LTDC_EnableDither(&LtdcHandler);
 8004e12:	4620      	mov	r0, r4
 8004e14:	f7fc fb22 	bl	800145c <HAL_LTDC_EnableDither>
}
 8004e18:	b00e      	add	sp, #56	; 0x38
 8004e1a:	bd70      	pop	{r4, r5, r6, pc}
 8004e1c:	2000032c 	.word	0x2000032c
 8004e20:	20000314 	.word	0x20000314
 8004e24:	20000150 	.word	0x20000150

08004e28 <BSP_LCD_SelectLayer>:
  ActiveLayer = LayerIndex;
 8004e28:	4b01      	ldr	r3, [pc, #4]	; (8004e30 <BSP_LCD_SelectLayer+0x8>)
 8004e2a:	6018      	str	r0, [r3, #0]
 8004e2c:	4770      	bx	lr
 8004e2e:	bf00      	nop
 8004e30:	200002d0 	.word	0x200002d0

08004e34 <BSP_LCD_SetLayerVisible>:
{
 8004e34:	4a08      	ldr	r2, [pc, #32]	; (8004e58 <BSP_LCD_SetLayerVisible+0x24>)
    __HAL_LTDC_LAYER_ENABLE(&LtdcHandler, LayerIndex);
 8004e36:	6813      	ldr	r3, [r2, #0]
  __HAL_LTDC_RELOAD_CONFIG(&LtdcHandler);
 8004e38:	6812      	ldr	r2, [r2, #0]
    __HAL_LTDC_LAYER_ENABLE(&LtdcHandler, LayerIndex);
 8004e3a:	3384      	adds	r3, #132	; 0x84
 8004e3c:	01c0      	lsls	r0, r0, #7
  if(state == ENABLE)
 8004e3e:	2901      	cmp	r1, #1
    __HAL_LTDC_LAYER_ENABLE(&LtdcHandler, LayerIndex);
 8004e40:	5819      	ldr	r1, [r3, r0]
 8004e42:	bf0c      	ite	eq
 8004e44:	f041 0101 	orreq.w	r1, r1, #1
    __HAL_LTDC_LAYER_DISABLE(&LtdcHandler, LayerIndex);
 8004e48:	f021 0101 	bicne.w	r1, r1, #1
 8004e4c:	5019      	str	r1, [r3, r0]
  __HAL_LTDC_RELOAD_CONFIG(&LtdcHandler);
 8004e4e:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8004e50:	f043 0301 	orr.w	r3, r3, #1
 8004e54:	6253      	str	r3, [r2, #36]	; 0x24
 8004e56:	4770      	bx	lr
 8004e58:	2000032c 	.word	0x2000032c

08004e5c <BSP_LCD_SetTransparency>:
  HAL_LTDC_SetAlpha(&LtdcHandler, Transparency, LayerIndex);
 8004e5c:	4602      	mov	r2, r0
 8004e5e:	4801      	ldr	r0, [pc, #4]	; (8004e64 <BSP_LCD_SetTransparency+0x8>)
 8004e60:	f7fc bb14 	b.w	800148c <HAL_LTDC_SetAlpha>
 8004e64:	2000032c 	.word	0x2000032c

08004e68 <BSP_LCD_GetTextColor>:
  return DrawProp[ActiveLayer].TextColor;
 8004e68:	4b03      	ldr	r3, [pc, #12]	; (8004e78 <BSP_LCD_GetTextColor+0x10>)
 8004e6a:	681a      	ldr	r2, [r3, #0]
 8004e6c:	230c      	movs	r3, #12
 8004e6e:	4353      	muls	r3, r2
}
 8004e70:	4a02      	ldr	r2, [pc, #8]	; (8004e7c <BSP_LCD_GetTextColor+0x14>)
 8004e72:	58d0      	ldr	r0, [r2, r3]
 8004e74:	4770      	bx	lr
 8004e76:	bf00      	nop
 8004e78:	200002d0 	.word	0x200002d0
 8004e7c:	20000314 	.word	0x20000314

08004e80 <BSP_LCD_SetTextColor>:
  DrawProp[ActiveLayer].TextColor = Color;
 8004e80:	4b03      	ldr	r3, [pc, #12]	; (8004e90 <BSP_LCD_SetTextColor+0x10>)
 8004e82:	681a      	ldr	r2, [r3, #0]
 8004e84:	230c      	movs	r3, #12
 8004e86:	4353      	muls	r3, r2
 8004e88:	4a02      	ldr	r2, [pc, #8]	; (8004e94 <BSP_LCD_SetTextColor+0x14>)
 8004e8a:	50d0      	str	r0, [r2, r3]
 8004e8c:	4770      	bx	lr
 8004e8e:	bf00      	nop
 8004e90:	200002d0 	.word	0x200002d0
 8004e94:	20000314 	.word	0x20000314

08004e98 <BSP_LCD_Clear>:
  FillBuffer(ActiveLayer, (uint32_t *)(LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress), BSP_LCD_GetXSize(), BSP_LCD_GetYSize(), 0, Color);
 8004e98:	4b0c      	ldr	r3, [pc, #48]	; (8004ecc <BSP_LCD_Clear+0x34>)
{ 
 8004e9a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  FillBuffer(ActiveLayer, (uint32_t *)(LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress), BSP_LCD_GetXSize(), BSP_LCD_GetYSize(), 0, Color);
 8004e9c:	681c      	ldr	r4, [r3, #0]
 8004e9e:	4a0c      	ldr	r2, [pc, #48]	; (8004ed0 <BSP_LCD_Clear+0x38>)
 8004ea0:	2334      	movs	r3, #52	; 0x34
 8004ea2:	fb03 2304 	mla	r3, r3, r4, r2
{ 
 8004ea6:	4607      	mov	r7, r0
  FillBuffer(ActiveLayer, (uint32_t *)(LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress), BSP_LCD_GetXSize(), BSP_LCD_GetYSize(), 0, Color);
 8004ea8:	6ddd      	ldr	r5, [r3, #92]	; 0x5c
 8004eaa:	f7ff ff6d 	bl	8004d88 <BSP_LCD_GetXSize>
 8004eae:	4606      	mov	r6, r0
 8004eb0:	f7ff ff72 	bl	8004d98 <BSP_LCD_GetYSize>
 8004eb4:	2300      	movs	r3, #0
 8004eb6:	9300      	str	r3, [sp, #0]
 8004eb8:	9701      	str	r7, [sp, #4]
 8004eba:	4603      	mov	r3, r0
 8004ebc:	4632      	mov	r2, r6
 8004ebe:	4629      	mov	r1, r5
 8004ec0:	4620      	mov	r0, r4
 8004ec2:	f7ff fe69 	bl	8004b98 <FillBuffer>
}
 8004ec6:	b003      	add	sp, #12
 8004ec8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004eca:	bf00      	nop
 8004ecc:	200002d0 	.word	0x200002d0
 8004ed0:	2000032c 	.word	0x2000032c

08004ed4 <BSP_LCD_DrawHLine>:
{
 8004ed4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  xaddress = (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4*(BSP_LCD_GetXSize()*Ypos + Xpos);
 8004ed8:	4d0f      	ldr	r5, [pc, #60]	; (8004f18 <BSP_LCD_DrawHLine+0x44>)
{
 8004eda:	4617      	mov	r7, r2
  xaddress = (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4*(BSP_LCD_GetXSize()*Ypos + Xpos);
 8004edc:	682b      	ldr	r3, [r5, #0]
 8004ede:	4a0f      	ldr	r2, [pc, #60]	; (8004f1c <BSP_LCD_DrawHLine+0x48>)
{
 8004ee0:	460c      	mov	r4, r1
  xaddress = (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4*(BSP_LCD_GetXSize()*Ypos + Xpos);
 8004ee2:	2134      	movs	r1, #52	; 0x34
 8004ee4:	fb01 2303 	mla	r3, r1, r3, r2
{
 8004ee8:	4680      	mov	r8, r0
  xaddress = (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4*(BSP_LCD_GetXSize()*Ypos + Xpos);
 8004eea:	6dde      	ldr	r6, [r3, #92]	; 0x5c
 8004eec:	f7ff ff4c 	bl	8004d88 <BSP_LCD_GetXSize>
  FillBuffer(ActiveLayer, (uint32_t *)xaddress, Length, 1, 0, DrawProp[ActiveLayer].TextColor);
 8004ef0:	682d      	ldr	r5, [r5, #0]
 8004ef2:	4a0b      	ldr	r2, [pc, #44]	; (8004f20 <BSP_LCD_DrawHLine+0x4c>)
 8004ef4:	230c      	movs	r3, #12
 8004ef6:	436b      	muls	r3, r5
  xaddress = (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4*(BSP_LCD_GetXSize()*Ypos + Xpos);
 8004ef8:	fb00 8004 	mla	r0, r0, r4, r8
  FillBuffer(ActiveLayer, (uint32_t *)xaddress, Length, 1, 0, DrawProp[ActiveLayer].TextColor);
 8004efc:	58d3      	ldr	r3, [r2, r3]
 8004efe:	9301      	str	r3, [sp, #4]
 8004f00:	2300      	movs	r3, #0
 8004f02:	9300      	str	r3, [sp, #0]
 8004f04:	eb06 0180 	add.w	r1, r6, r0, lsl #2
 8004f08:	2301      	movs	r3, #1
 8004f0a:	463a      	mov	r2, r7
 8004f0c:	4628      	mov	r0, r5
 8004f0e:	f7ff fe43 	bl	8004b98 <FillBuffer>
}
 8004f12:	b002      	add	sp, #8
 8004f14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004f18:	200002d0 	.word	0x200002d0
 8004f1c:	2000032c 	.word	0x2000032c
 8004f20:	20000314 	.word	0x20000314

08004f24 <BSP_LCD_DrawVLine>:
{
 8004f24:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  xaddress = (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4*(BSP_LCD_GetXSize()*Ypos + Xpos);
 8004f28:	4d11      	ldr	r5, [pc, #68]	; (8004f70 <BSP_LCD_DrawVLine+0x4c>)
 8004f2a:	4b12      	ldr	r3, [pc, #72]	; (8004f74 <BSP_LCD_DrawVLine+0x50>)
{
 8004f2c:	460c      	mov	r4, r1
  xaddress = (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4*(BSP_LCD_GetXSize()*Ypos + Xpos);
 8004f2e:	6829      	ldr	r1, [r5, #0]
{
 8004f30:	4690      	mov	r8, r2
  xaddress = (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4*(BSP_LCD_GetXSize()*Ypos + Xpos);
 8004f32:	2234      	movs	r2, #52	; 0x34
 8004f34:	fb02 3101 	mla	r1, r2, r1, r3
{
 8004f38:	4681      	mov	r9, r0
  xaddress = (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4*(BSP_LCD_GetXSize()*Ypos + Xpos);
 8004f3a:	6dcf      	ldr	r7, [r1, #92]	; 0x5c
 8004f3c:	f7ff ff24 	bl	8004d88 <BSP_LCD_GetXSize>
 8004f40:	4682      	mov	sl, r0
  FillBuffer(ActiveLayer, (uint32_t *)xaddress, 1, Length, (BSP_LCD_GetXSize() - 1), DrawProp[ActiveLayer].TextColor);
 8004f42:	f7ff ff21 	bl	8004d88 <BSP_LCD_GetXSize>
 8004f46:	682e      	ldr	r6, [r5, #0]
 8004f48:	4b0b      	ldr	r3, [pc, #44]	; (8004f78 <BSP_LCD_DrawVLine+0x54>)
 8004f4a:	250c      	movs	r5, #12
 8004f4c:	4375      	muls	r5, r6
  xaddress = (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4*(BSP_LCD_GetXSize()*Ypos + Xpos);
 8004f4e:	fb0a 9404 	mla	r4, sl, r4, r9
  FillBuffer(ActiveLayer, (uint32_t *)xaddress, 1, Length, (BSP_LCD_GetXSize() - 1), DrawProp[ActiveLayer].TextColor);
 8004f52:	595b      	ldr	r3, [r3, r5]
 8004f54:	9301      	str	r3, [sp, #4]
 8004f56:	3801      	subs	r0, #1
 8004f58:	9000      	str	r0, [sp, #0]
 8004f5a:	4643      	mov	r3, r8
 8004f5c:	2201      	movs	r2, #1
 8004f5e:	eb07 0184 	add.w	r1, r7, r4, lsl #2
 8004f62:	4630      	mov	r0, r6
 8004f64:	f7ff fe18 	bl	8004b98 <FillBuffer>
}
 8004f68:	b002      	add	sp, #8
 8004f6a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004f6e:	bf00      	nop
 8004f70:	200002d0 	.word	0x200002d0
 8004f74:	2000032c 	.word	0x2000032c
 8004f78:	20000314 	.word	0x20000314

08004f7c <BSP_LCD_DrawRect>:
{
 8004f7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004f7e:	461e      	mov	r6, r3
 8004f80:	460d      	mov	r5, r1
 8004f82:	4604      	mov	r4, r0
 8004f84:	4617      	mov	r7, r2
  BSP_LCD_DrawHLine(Xpos, Ypos, Width);
 8004f86:	f7ff ffa5 	bl	8004ed4 <BSP_LCD_DrawHLine>
  BSP_LCD_DrawHLine(Xpos, (Ypos+ Height), Width);
 8004f8a:	19a9      	adds	r1, r5, r6
 8004f8c:	463a      	mov	r2, r7
 8004f8e:	4620      	mov	r0, r4
 8004f90:	b289      	uxth	r1, r1
 8004f92:	f7ff ff9f 	bl	8004ed4 <BSP_LCD_DrawHLine>
  BSP_LCD_DrawVLine(Xpos, Ypos, Height);
 8004f96:	4632      	mov	r2, r6
 8004f98:	4629      	mov	r1, r5
 8004f9a:	4620      	mov	r0, r4
 8004f9c:	f7ff ffc2 	bl	8004f24 <BSP_LCD_DrawVLine>
  BSP_LCD_DrawVLine((Xpos + Width), Ypos, Height);
 8004fa0:	19e0      	adds	r0, r4, r7
 8004fa2:	4632      	mov	r2, r6
 8004fa4:	4629      	mov	r1, r5
 8004fa6:	b280      	uxth	r0, r0
}
 8004fa8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  BSP_LCD_DrawVLine((Xpos + Width), Ypos, Height);
 8004fac:	f7ff bfba 	b.w	8004f24 <BSP_LCD_DrawVLine>

08004fb0 <BSP_LCD_FillRect>:
{
 8004fb0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  BSP_LCD_SetTextColor(DrawProp[ActiveLayer].TextColor);
 8004fb4:	4e12      	ldr	r6, [pc, #72]	; (8005000 <BSP_LCD_FillRect+0x50>)
{
 8004fb6:	4699      	mov	r9, r3
 8004fb8:	460c      	mov	r4, r1
  xaddress = (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4*(BSP_LCD_GetXSize()*Ypos + Xpos);
 8004fba:	4b12      	ldr	r3, [pc, #72]	; (8005004 <BSP_LCD_FillRect+0x54>)
 8004fbc:	6831      	ldr	r1, [r6, #0]
{
 8004fbe:	4617      	mov	r7, r2
  xaddress = (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4*(BSP_LCD_GetXSize()*Ypos + Xpos);
 8004fc0:	2234      	movs	r2, #52	; 0x34
 8004fc2:	fb02 3101 	mla	r1, r2, r1, r3
{
 8004fc6:	4605      	mov	r5, r0
  xaddress = (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4*(BSP_LCD_GetXSize()*Ypos + Xpos);
 8004fc8:	f8d1 805c 	ldr.w	r8, [r1, #92]	; 0x5c
 8004fcc:	f7ff fedc 	bl	8004d88 <BSP_LCD_GetXSize>
 8004fd0:	4682      	mov	sl, r0
  FillBuffer(ActiveLayer, (uint32_t *)xaddress, Width, Height, (BSP_LCD_GetXSize() - Width), DrawProp[ActiveLayer].TextColor);
 8004fd2:	f7ff fed9 	bl	8004d88 <BSP_LCD_GetXSize>
 8004fd6:	6836      	ldr	r6, [r6, #0]
 8004fd8:	4b0b      	ldr	r3, [pc, #44]	; (8005008 <BSP_LCD_FillRect+0x58>)
  xaddress = (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress) + 4*(BSP_LCD_GetXSize()*Ypos + Xpos);
 8004fda:	fb0a 5404 	mla	r4, sl, r4, r5
  FillBuffer(ActiveLayer, (uint32_t *)xaddress, Width, Height, (BSP_LCD_GetXSize() - Width), DrawProp[ActiveLayer].TextColor);
 8004fde:	250c      	movs	r5, #12
 8004fe0:	4375      	muls	r5, r6
 8004fe2:	1bc0      	subs	r0, r0, r7
 8004fe4:	595b      	ldr	r3, [r3, r5]
 8004fe6:	9301      	str	r3, [sp, #4]
 8004fe8:	9000      	str	r0, [sp, #0]
 8004fea:	464b      	mov	r3, r9
 8004fec:	463a      	mov	r2, r7
 8004fee:	eb08 0184 	add.w	r1, r8, r4, lsl #2
 8004ff2:	4630      	mov	r0, r6
 8004ff4:	f7ff fdd0 	bl	8004b98 <FillBuffer>
}
 8004ff8:	b002      	add	sp, #8
 8004ffa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004ffe:	bf00      	nop
 8005000:	200002d0 	.word	0x200002d0
 8005004:	2000032c 	.word	0x2000032c
 8005008:	20000314 	.word	0x20000314

0800500c <BSP_LCD_DrawPixel>:
{
 800500c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *(__IO uint32_t*) (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress + (4*(Ypos*BSP_LCD_GetXSize() + Xpos))) = RGB_Code;
 800500e:	4b08      	ldr	r3, [pc, #32]	; (8005030 <BSP_LCD_DrawPixel+0x24>)
{
 8005010:	4616      	mov	r6, r2
  *(__IO uint32_t*) (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress + (4*(Ypos*BSP_LCD_GetXSize() + Xpos))) = RGB_Code;
 8005012:	681b      	ldr	r3, [r3, #0]
 8005014:	4a07      	ldr	r2, [pc, #28]	; (8005034 <BSP_LCD_DrawPixel+0x28>)
{
 8005016:	460c      	mov	r4, r1
  *(__IO uint32_t*) (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress + (4*(Ypos*BSP_LCD_GetXSize() + Xpos))) = RGB_Code;
 8005018:	2134      	movs	r1, #52	; 0x34
 800501a:	fb01 2303 	mla	r3, r1, r3, r2
{
 800501e:	4607      	mov	r7, r0
  *(__IO uint32_t*) (LtdcHandler.LayerCfg[ActiveLayer].FBStartAdress + (4*(Ypos*BSP_LCD_GetXSize() + Xpos))) = RGB_Code;
 8005020:	6ddd      	ldr	r5, [r3, #92]	; 0x5c
 8005022:	f7ff feb1 	bl	8004d88 <BSP_LCD_GetXSize>
 8005026:	fb00 7004 	mla	r0, r0, r4, r7
 800502a:	f845 6020 	str.w	r6, [r5, r0, lsl #2]
 800502e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005030:	200002d0 	.word	0x200002d0
 8005034:	2000032c 	.word	0x2000032c

08005038 <BSP_LCD_DrawLine>:
{
 8005038:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  deltax = ABS(X2 - X1);        /* The difference between the x's */
 800503c:	1a14      	subs	r4, r2, r0
 800503e:	2c00      	cmp	r4, #0
  deltay = ABS(Y2 - Y1);        /* The difference between the y's */
 8005040:	eba3 0601 	sub.w	r6, r3, r1
  deltax = ABS(X2 - X1);        /* The difference between the x's */
 8005044:	bfb8      	it	lt
 8005046:	4264      	neglt	r4, r4
  deltay = ABS(Y2 - Y1);        /* The difference between the y's */
 8005048:	2e00      	cmp	r6, #0
 800504a:	bfb8      	it	lt
 800504c:	4276      	neglt	r6, r6
  deltax = ABS(X2 - X1);        /* The difference between the x's */
 800504e:	b224      	sxth	r4, r4
  deltay = ABS(Y2 - Y1);        /* The difference between the y's */
 8005050:	b236      	sxth	r6, r6
    xinc1 = -1;
 8005052:	4282      	cmp	r2, r0
 8005054:	bf2c      	ite	cs
 8005056:	2701      	movcs	r7, #1
 8005058:	f04f 37ff 	movcc.w	r7, #4294967295	; 0xffffffff
    yinc1 = -1;
 800505c:	428b      	cmp	r3, r1
 800505e:	bf2c      	ite	cs
 8005060:	f04f 0801 	movcs.w	r8, #1
 8005064:	f04f 38ff 	movcc.w	r8, #4294967295	; 0xffffffff
  if (deltax >= deltay)         /* There is at least one x-value for every y-value */
 8005068:	42b4      	cmp	r4, r6
{
 800506a:	b085      	sub	sp, #20
  x = X1;                       /* Start x off at the first pixel */
 800506c:	fa0f f980 	sxth.w	r9, r0
  y = Y1;                       /* Start y off at the first pixel */
 8005070:	fa0f fa81 	sxth.w	sl, r1
 8005074:	f04f 0502 	mov.w	r5, #2
  if (deltax >= deltay)         /* There is at least one x-value for every y-value */
 8005078:	db0b      	blt.n	8005092 <BSP_LCD_DrawLine+0x5a>
    num = deltax / 2;
 800507a:	fb94 f5f5 	sdiv	r5, r4, r5
 800507e:	9700      	str	r7, [sp, #0]
    yinc2 = 0;                  /* Don't change the y for every iteration */
 8005080:	2700      	movs	r7, #0
    xinc1 = 0;                  /* Don't change the x when numerator >= denominator */
 8005082:	9701      	str	r7, [sp, #4]
  for (curpixel = 0; curpixel <= numpixels; curpixel++)
 8005084:	2300      	movs	r3, #0
 8005086:	b21a      	sxth	r2, r3
 8005088:	4294      	cmp	r4, r2
 800508a:	da0f      	bge.n	80050ac <BSP_LCD_DrawLine+0x74>
}
 800508c:	b005      	add	sp, #20
 800508e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    num = deltay / 2;
 8005092:	4623      	mov	r3, r4
 8005094:	f8cd 8004 	str.w	r8, [sp, #4]
    yinc1 = 0;                  /* Don't change the y when numerator >= denominator */
 8005098:	f04f 0800 	mov.w	r8, #0
    num = deltay / 2;
 800509c:	fb96 f5f5 	sdiv	r5, r6, r5
 80050a0:	4634      	mov	r4, r6
 80050a2:	b22d      	sxth	r5, r5
 80050a4:	461e      	mov	r6, r3
    xinc2 = 0;                  /* Don't change the x for every iteration */
 80050a6:	f8cd 8000 	str.w	r8, [sp]
 80050aa:	e7eb      	b.n	8005084 <BSP_LCD_DrawLine+0x4c>
 80050ac:	9303      	str	r3, [sp, #12]
    BSP_LCD_DrawPixel(x, y, DrawProp[ActiveLayer].TextColor);   /* Draw the current pixel */
 80050ae:	fa1f f38a 	uxth.w	r3, sl
 80050b2:	9302      	str	r3, [sp, #8]
 80050b4:	4b12      	ldr	r3, [pc, #72]	; (8005100 <BSP_LCD_DrawLine+0xc8>)
 80050b6:	9902      	ldr	r1, [sp, #8]
 80050b8:	681a      	ldr	r2, [r3, #0]
 80050ba:	230c      	movs	r3, #12
 80050bc:	435a      	muls	r2, r3
 80050be:	4b11      	ldr	r3, [pc, #68]	; (8005104 <BSP_LCD_DrawLine+0xcc>)
 80050c0:	fa1f fb89 	uxth.w	fp, r9
 80050c4:	589a      	ldr	r2, [r3, r2]
    num += numadd;                            /* Increase the numerator by the top of the fraction */
 80050c6:	4435      	add	r5, r6
    BSP_LCD_DrawPixel(x, y, DrawProp[ActiveLayer].TextColor);   /* Draw the current pixel */
 80050c8:	4658      	mov	r0, fp
 80050ca:	f7ff ff9f 	bl	800500c <BSP_LCD_DrawPixel>
    num += numadd;                            /* Increase the numerator by the top of the fraction */
 80050ce:	b2aa      	uxth	r2, r5
 80050d0:	b215      	sxth	r5, r2
    if (num >= den)                           /* Check if numerator >= denominator */
 80050d2:	42ac      	cmp	r4, r5
 80050d4:	9b03      	ldr	r3, [sp, #12]
 80050d6:	dc09      	bgt.n	80050ec <BSP_LCD_DrawLine+0xb4>
      num -= den;                             /* Calculate the new numerator value */
 80050d8:	1b15      	subs	r5, r2, r4
      y += yinc1;                             /* Change the y as appropriate */
 80050da:	9a02      	ldr	r2, [sp, #8]
      x += xinc1;                             /* Change the x as appropriate */
 80050dc:	eb0b 0907 	add.w	r9, fp, r7
      y += yinc1;                             /* Change the y as appropriate */
 80050e0:	4442      	add	r2, r8
      num -= den;                             /* Calculate the new numerator value */
 80050e2:	b22d      	sxth	r5, r5
      x += xinc1;                             /* Change the x as appropriate */
 80050e4:	fa0f f989 	sxth.w	r9, r9
      y += yinc1;                             /* Change the y as appropriate */
 80050e8:	fa0f fa82 	sxth.w	sl, r2
    x += xinc2;                               /* Change the x as appropriate */
 80050ec:	9a00      	ldr	r2, [sp, #0]
 80050ee:	4491      	add	r9, r2
    y += yinc2;                               /* Change the y as appropriate */
 80050f0:	9a01      	ldr	r2, [sp, #4]
 80050f2:	4492      	add	sl, r2
    x += xinc2;                               /* Change the x as appropriate */
 80050f4:	fa0f f989 	sxth.w	r9, r9
    y += yinc2;                               /* Change the y as appropriate */
 80050f8:	fa0f fa8a 	sxth.w	sl, sl
 80050fc:	3301      	adds	r3, #1
 80050fe:	e7c2      	b.n	8005086 <BSP_LCD_DrawLine+0x4e>
 8005100:	200002d0 	.word	0x200002d0
 8005104:	20000314 	.word	0x20000314

08005108 <BSP_LCD_FillTriangle>:
{ 
 8005108:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800510c:	b087      	sub	sp, #28
  deltax = ABS(X2 - X1);        /* The difference between the x's */
 800510e:	1a0c      	subs	r4, r1, r0
{ 
 8005110:	f8bd 8040 	ldrh.w	r8, [sp, #64]	; 0x40
 8005114:	9204      	str	r2, [sp, #16]
  deltay = ABS(Y2 - Y1);        /* The difference between the y's */
 8005116:	eba8 0603 	sub.w	r6, r8, r3
  deltax = ABS(X2 - X1);        /* The difference between the x's */
 800511a:	2c00      	cmp	r4, #0
 800511c:	bfb8      	it	lt
 800511e:	4264      	neglt	r4, r4
  deltay = ABS(Y2 - Y1);        /* The difference between the y's */
 8005120:	2e00      	cmp	r6, #0
 8005122:	bfb8      	it	lt
 8005124:	4276      	neglt	r6, r6
  deltax = ABS(X2 - X1);        /* The difference between the x's */
 8005126:	b224      	sxth	r4, r4
  deltay = ABS(Y2 - Y1);        /* The difference between the y's */
 8005128:	b236      	sxth	r6, r6
{ 
 800512a:	f8bd 2044 	ldrh.w	r2, [sp, #68]	; 0x44
 800512e:	9205      	str	r2, [sp, #20]
    xinc1 = -1;
 8005130:	4281      	cmp	r1, r0
 8005132:	bf2c      	ite	cs
 8005134:	2701      	movcs	r7, #1
 8005136:	f04f 37ff 	movcc.w	r7, #4294967295	; 0xffffffff
    yinc1 = -1;
 800513a:	4598      	cmp	r8, r3
 800513c:	bf2c      	ite	cs
 800513e:	f04f 0801 	movcs.w	r8, #1
 8005142:	f04f 38ff 	movcc.w	r8, #4294967295	; 0xffffffff
  if (deltax >= deltay)         /* There is at least one x-value for every y-value */
 8005146:	42b4      	cmp	r4, r6
  x = X1;                       /* Start x off at the first pixel */
 8005148:	fa0f f980 	sxth.w	r9, r0
  y = Y1;                       /* Start y off at the first pixel */
 800514c:	fa0f fa83 	sxth.w	sl, r3
 8005150:	f04f 0502 	mov.w	r5, #2
  if (deltax >= deltay)         /* There is at least one x-value for every y-value */
 8005154:	db0d      	blt.n	8005172 <BSP_LCD_FillTriangle+0x6a>
    num = deltax / 2;
 8005156:	fb94 f5f5 	sdiv	r5, r4, r5
 800515a:	9700      	str	r7, [sp, #0]
    yinc2 = 0;                  /* Don't change the y for every iteration */
 800515c:	2700      	movs	r7, #0
    xinc1 = 0;                  /* Don't change the x when numerator >= denominator */
 800515e:	9701      	str	r7, [sp, #4]
  for (curpixel = 0; curpixel <= numpixels; curpixel++)
 8005160:	f04f 0b00 	mov.w	fp, #0
 8005164:	fa0f f38b 	sxth.w	r3, fp
 8005168:	429c      	cmp	r4, r3
 800516a:	da0f      	bge.n	800518c <BSP_LCD_FillTriangle+0x84>
}
 800516c:	b007      	add	sp, #28
 800516e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    num = deltay / 2;
 8005172:	4623      	mov	r3, r4
 8005174:	f8cd 8004 	str.w	r8, [sp, #4]
    yinc1 = 0;                  /* Don't change the y when numerator >= denominator */
 8005178:	f04f 0800 	mov.w	r8, #0
    num = deltay / 2;
 800517c:	fb96 f5f5 	sdiv	r5, r6, r5
 8005180:	4634      	mov	r4, r6
 8005182:	b22d      	sxth	r5, r5
 8005184:	461e      	mov	r6, r3
    xinc2 = 0;                  /* Don't change the x for every iteration */
 8005186:	f8cd 8000 	str.w	r8, [sp]
 800518a:	e7e9      	b.n	8005160 <BSP_LCD_FillTriangle+0x58>
    BSP_LCD_DrawLine(x, y, X3, Y3);
 800518c:	fa1f f389 	uxth.w	r3, r9
 8005190:	9302      	str	r3, [sp, #8]
 8005192:	fa1f f38a 	uxth.w	r3, sl
 8005196:	9303      	str	r3, [sp, #12]
 8005198:	a802      	add	r0, sp, #8
 800519a:	c80f      	ldmia	r0, {r0, r1, r2, r3}
    num += numadd;              /* Increase the numerator by the top of the fraction */
 800519c:	4435      	add	r5, r6
    BSP_LCD_DrawLine(x, y, X3, Y3);
 800519e:	f7ff ff4b 	bl	8005038 <BSP_LCD_DrawLine>
    num += numadd;              /* Increase the numerator by the top of the fraction */
 80051a2:	b2ab      	uxth	r3, r5
 80051a4:	b21d      	sxth	r5, r3
    if (num >= den)             /* Check if numerator >= denominator */
 80051a6:	42ac      	cmp	r4, r5
 80051a8:	dc09      	bgt.n	80051be <BSP_LCD_FillTriangle+0xb6>
      num -= den;               /* Calculate the new numerator value */
 80051aa:	1b1d      	subs	r5, r3, r4
      x += xinc1;               /* Change the x as appropriate */
 80051ac:	9b02      	ldr	r3, [sp, #8]
 80051ae:	443b      	add	r3, r7
 80051b0:	fa0f f983 	sxth.w	r9, r3
      y += yinc1;               /* Change the y as appropriate */
 80051b4:	9b03      	ldr	r3, [sp, #12]
 80051b6:	4443      	add	r3, r8
      num -= den;               /* Calculate the new numerator value */
 80051b8:	b22d      	sxth	r5, r5
      y += yinc1;               /* Change the y as appropriate */
 80051ba:	fa0f fa83 	sxth.w	sl, r3
    x += xinc2;                 /* Change the x as appropriate */
 80051be:	9b00      	ldr	r3, [sp, #0]
 80051c0:	4499      	add	r9, r3
    y += yinc2;                 /* Change the y as appropriate */
 80051c2:	9b01      	ldr	r3, [sp, #4]
 80051c4:	449a      	add	sl, r3
    x += xinc2;                 /* Change the x as appropriate */
 80051c6:	fa0f f989 	sxth.w	r9, r9
    y += yinc2;                 /* Change the y as appropriate */
 80051ca:	fa0f fa8a 	sxth.w	sl, sl
 80051ce:	f10b 0b01 	add.w	fp, fp, #1
 80051d2:	e7c7      	b.n	8005164 <BSP_LCD_FillTriangle+0x5c>

080051d4 <BSP_LCD_FillPolygon>:
{
 80051d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  imageleft = imageright = Points->X;
 80051d8:	8806      	ldrh	r6, [r0, #0]
  imagetop= imagebottom = Points->Y;
 80051da:	8847      	ldrh	r7, [r0, #2]
{
 80051dc:	460d      	mov	r5, r1
 80051de:	b089      	sub	sp, #36	; 0x24
  imagetop= imagebottom = Points->Y;
 80051e0:	463a      	mov	r2, r7
 80051e2:	46be      	mov	lr, r7
  imageleft = imageright = Points->X;
 80051e4:	46b4      	mov	ip, r6
 80051e6:	4631      	mov	r1, r6
  for(counter = 1; counter < PointCount; counter++)
 80051e8:	2301      	movs	r3, #1
 80051ea:	42ab      	cmp	r3, r5
 80051ec:	db39      	blt.n	8005262 <BSP_LCD_FillPolygon+0x8e>
  if(PointCount < 2)
 80051ee:	2d01      	cmp	r5, #1
 80051f0:	d934      	bls.n	800525c <BSP_LCD_FillPolygon+0x88>
  xcenter = (imageleft + imageright)/2;
 80051f2:	4461      	add	r1, ip
 80051f4:	104b      	asrs	r3, r1, #1
  ycenter = (imagebottom + imagetop)/2;
 80051f6:	4472      	add	r2, lr
  xcenter = (imageleft + imageright)/2;
 80051f8:	9306      	str	r3, [sp, #24]
  ycenter = (imagebottom + imagetop)/2;
 80051fa:	1053      	asrs	r3, r2, #1
 80051fc:	9307      	str	r3, [sp, #28]
    BSP_LCD_FillTriangle(x, x2, xcenter, y, y2, ycenter);
 80051fe:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 8005202:	9304      	str	r3, [sp, #16]
  int16_t x = 0, y = 0, x2 = 0, y2 = 0, xcenter = 0, ycenter = 0, xfirst = 0, yfirst = 0, pixelx = 0, pixely = 0, counter = 0;
 8005204:	f04f 0a00 	mov.w	sl, #0
    BSP_LCD_FillTriangle(x, x2, xcenter, y, y2, ycenter);
 8005208:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 800520c:	9305      	str	r3, [sp, #20]
 800520e:	4604      	mov	r4, r0
  int16_t x = 0, y = 0, x2 = 0, y2 = 0, xcenter = 0, ycenter = 0, xfirst = 0, yfirst = 0, pixelx = 0, pixely = 0, counter = 0;
 8005210:	46d3      	mov	fp, sl
  while(--PointCount)
 8005212:	3d01      	subs	r5, #1
 8005214:	b2ad      	uxth	r5, r5
 8005216:	3404      	adds	r4, #4
 8005218:	bbd5      	cbnz	r5, 8005290 <BSP_LCD_FillPolygon+0xbc>
  BSP_LCD_FillTriangle(xfirst, x2, xcenter, yfirst, y2, ycenter);
 800521a:	f8bd 5018 	ldrh.w	r5, [sp, #24]
 800521e:	f8bd 901c 	ldrh.w	r9, [sp, #28]
 8005222:	fa1f f88b 	uxth.w	r8, fp
 8005226:	fa1f f48a 	uxth.w	r4, sl
 800522a:	463b      	mov	r3, r7
 800522c:	462a      	mov	r2, r5
 800522e:	4641      	mov	r1, r8
 8005230:	4630      	mov	r0, r6
 8005232:	e88d 0210 	stmia.w	sp, {r4, r9}
 8005236:	f7ff ff67 	bl	8005108 <BSP_LCD_FillTriangle>
  BSP_LCD_FillTriangle(xfirst, xcenter, x2, yfirst, ycenter, y2);
 800523a:	463b      	mov	r3, r7
 800523c:	4642      	mov	r2, r8
 800523e:	4629      	mov	r1, r5
 8005240:	4630      	mov	r0, r6
 8005242:	9401      	str	r4, [sp, #4]
 8005244:	f8cd 9000 	str.w	r9, [sp]
 8005248:	f7ff ff5e 	bl	8005108 <BSP_LCD_FillTriangle>
  BSP_LCD_FillTriangle(xcenter, x2, xfirst, ycenter, y2, yfirst);   
 800524c:	e88d 0090 	stmia.w	sp, {r4, r7}
 8005250:	464b      	mov	r3, r9
 8005252:	4632      	mov	r2, r6
 8005254:	4641      	mov	r1, r8
 8005256:	4628      	mov	r0, r5
 8005258:	f7ff ff56 	bl	8005108 <BSP_LCD_FillTriangle>
}
 800525c:	b009      	add	sp, #36	; 0x24
 800525e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    pixelx = POLY_X(counter);
 8005262:	f930 4023 	ldrsh.w	r4, [r0, r3, lsl #2]
 8005266:	eb00 0883 	add.w	r8, r0, r3, lsl #2
    if(pixelx < imageleft)
 800526a:	428c      	cmp	r4, r1
      imageleft = pixelx;
 800526c:	bfb8      	it	lt
 800526e:	b2a1      	uxthlt	r1, r4
    if(pixelx > imageright)
 8005270:	4564      	cmp	r4, ip
      imageright = pixelx;
 8005272:	bfc8      	it	gt
 8005274:	fa1f fc84 	uxthgt.w	ip, r4
    pixely = POLY_Y(counter);
 8005278:	f9b8 4002 	ldrsh.w	r4, [r8, #2]
    if(pixely < imagetop)
 800527c:	4574      	cmp	r4, lr
      imagetop = pixely;
 800527e:	bfb8      	it	lt
 8005280:	fa1f fe84 	uxthlt.w	lr, r4
 8005284:	3301      	adds	r3, #1
    if(pixely > imagebottom)
 8005286:	4294      	cmp	r4, r2
      imagebottom = pixely;
 8005288:	bfc8      	it	gt
 800528a:	b2a2      	uxthgt	r2, r4
 800528c:	b21b      	sxth	r3, r3
 800528e:	e7ac      	b.n	80051ea <BSP_LCD_FillPolygon+0x16>
    y2 = Points->Y;    
 8005290:	f9b4 a002 	ldrsh.w	sl, [r4, #2]
    BSP_LCD_FillTriangle(x, x2, xcenter, y, y2, ycenter);
 8005294:	f834 3c02 	ldrh.w	r3, [r4, #-2]
    x2 = Points->X;
 8005298:	f9b4 b000 	ldrsh.w	fp, [r4]
    BSP_LCD_FillTriangle(x, x2, xcenter, y, y2, ycenter);
 800529c:	9302      	str	r3, [sp, #8]
 800529e:	fa1f f38a 	uxth.w	r3, sl
 80052a2:	f834 9c04 	ldrh.w	r9, [r4, #-4]
 80052a6:	9303      	str	r3, [sp, #12]
 80052a8:	9b05      	ldr	r3, [sp, #20]
 80052aa:	9301      	str	r3, [sp, #4]
 80052ac:	fa1f f88b 	uxth.w	r8, fp
 80052b0:	9b03      	ldr	r3, [sp, #12]
 80052b2:	9300      	str	r3, [sp, #0]
 80052b4:	9a04      	ldr	r2, [sp, #16]
 80052b6:	9b02      	ldr	r3, [sp, #8]
 80052b8:	4641      	mov	r1, r8
 80052ba:	4648      	mov	r0, r9
 80052bc:	f7ff ff24 	bl	8005108 <BSP_LCD_FillTriangle>
    BSP_LCD_FillTriangle(x, xcenter, x2, y, ycenter, y2);
 80052c0:	9b03      	ldr	r3, [sp, #12]
 80052c2:	9301      	str	r3, [sp, #4]
 80052c4:	9b05      	ldr	r3, [sp, #20]
 80052c6:	9300      	str	r3, [sp, #0]
 80052c8:	4642      	mov	r2, r8
 80052ca:	9b02      	ldr	r3, [sp, #8]
 80052cc:	9904      	ldr	r1, [sp, #16]
 80052ce:	4648      	mov	r0, r9
 80052d0:	f7ff ff1a 	bl	8005108 <BSP_LCD_FillTriangle>
    BSP_LCD_FillTriangle(xcenter, x2, x, ycenter, y2, y);   
 80052d4:	9b02      	ldr	r3, [sp, #8]
 80052d6:	9301      	str	r3, [sp, #4]
 80052d8:	9b03      	ldr	r3, [sp, #12]
 80052da:	9300      	str	r3, [sp, #0]
 80052dc:	464a      	mov	r2, r9
 80052de:	9b05      	ldr	r3, [sp, #20]
 80052e0:	9804      	ldr	r0, [sp, #16]
 80052e2:	4641      	mov	r1, r8
 80052e4:	f7ff ff10 	bl	8005108 <BSP_LCD_FillTriangle>
 80052e8:	e793      	b.n	8005212 <BSP_LCD_FillPolygon+0x3e>
	...

080052ec <BSP_SDRAM_Initialization_sequence>:
  * @brief  Programs the SDRAM device.
  * @param  RefreshCount: SDRAM refresh counter value 
  * @retval None
  */
void BSP_SDRAM_Initialization_sequence(uint32_t RefreshCount)
{
 80052ec:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  __IO uint32_t tmpmrd =0;
  
  /* Step 1:  Configure a clock configuration enable command */
  Command.CommandMode             = FMC_SDRAM_CMD_CLK_ENABLE;
 80052f0:	4c23      	ldr	r4, [pc, #140]	; (8005380 <BSP_SDRAM_Initialization_sequence+0x94>)
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
  Command.AutoRefreshNumber       = 1;
  Command.ModeRegisterDefinition  = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 80052f2:	4d24      	ldr	r5, [pc, #144]	; (8005384 <BSP_SDRAM_Initialization_sequence+0x98>)
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
 80052f4:	2601      	movs	r6, #1
  __IO uint32_t tmpmrd =0;
 80052f6:	f04f 0800 	mov.w	r8, #0
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
 80052fa:	2708      	movs	r7, #8
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 80052fc:	4621      	mov	r1, r4
{
 80052fe:	4682      	mov	sl, r0
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 8005300:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8005304:	4628      	mov	r0, r5
  __IO uint32_t tmpmrd =0;
 8005306:	f8cd 8004 	str.w	r8, [sp, #4]
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
 800530a:	e884 00c0 	stmia.w	r4, {r6, r7}
  Command.AutoRefreshNumber       = 1;
 800530e:	60a6      	str	r6, [r4, #8]
  Command.ModeRegisterDefinition  = 0;
 8005310:	f8c4 800c 	str.w	r8, [r4, #12]
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 8005314:	f7fd f93f 	bl	8002596 <HAL_SDRAM_SendCommand>

  /* Step 2: Insert 100 us minimum delay */ 
  /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
  HAL_Delay(1);
 8005318:	4630      	mov	r0, r6
 800531a:	f7fa ffc9 	bl	80002b0 <HAL_Delay>

  /* Step 3: Configure a PALL (precharge all) command */ 
  Command.CommandMode             = FMC_SDRAM_CMD_PALL;
 800531e:	2302      	movs	r3, #2
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
  Command.AutoRefreshNumber       = 1;
  Command.ModeRegisterDefinition  = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);  
 8005320:	4621      	mov	r1, r4
 8005322:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8005326:	4628      	mov	r0, r5
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
 8005328:	e884 0088 	stmia.w	r4, {r3, r7}
  
  /* Step 4: Configure an Auto Refresh command */ 
  Command.CommandMode             = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
  Command.AutoRefreshNumber       = 4;
 800532c:	f04f 0904 	mov.w	r9, #4
  Command.AutoRefreshNumber       = 1;
 8005330:	60a6      	str	r6, [r4, #8]
  Command.ModeRegisterDefinition  = 0;
 8005332:	f8c4 800c 	str.w	r8, [r4, #12]
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);  
 8005336:	f7fd f92e 	bl	8002596 <HAL_SDRAM_SendCommand>
  Command.CommandMode             = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 800533a:	2303      	movs	r3, #3
  Command.ModeRegisterDefinition  = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 800533c:	4621      	mov	r1, r4
 800533e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8005342:	4628      	mov	r0, r5
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
 8005344:	e884 0088 	stmia.w	r4, {r3, r7}
  Command.AutoRefreshNumber       = 4;
 8005348:	f8c4 9008 	str.w	r9, [r4, #8]
  Command.ModeRegisterDefinition  = 0;
 800534c:	f8c4 800c 	str.w	r8, [r4, #12]
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 8005350:	f7fd f921 	bl	8002596 <HAL_SDRAM_SendCommand>
  
  /* Step 5: Program the external memory mode register */
  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_2          |
 8005354:	f240 2331 	movw	r3, #561	; 0x231
 8005358:	9301      	str	r3, [sp, #4]
                     SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;
  
  Command.CommandMode             = FMC_SDRAM_CMD_LOAD_MODE;
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
  Command.AutoRefreshNumber       = 1;
  Command.ModeRegisterDefinition  = tmpmrd;
 800535a:	9b01      	ldr	r3, [sp, #4]
 800535c:	60e3      	str	r3, [r4, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 800535e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8005362:	4621      	mov	r1, r4
 8005364:	4628      	mov	r0, r5
  Command.CommandMode             = FMC_SDRAM_CMD_LOAD_MODE;
 8005366:	f8c4 9000 	str.w	r9, [r4]
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
 800536a:	6067      	str	r7, [r4, #4]
  Command.AutoRefreshNumber       = 1;
 800536c:	60a6      	str	r6, [r4, #8]
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 800536e:	f7fd f912 	bl	8002596 <HAL_SDRAM_SendCommand>
  
  /* Step 6: Set the refresh rate counter */
  /* Set the device refresh rate */
  HAL_SDRAM_ProgramRefreshRate(&SdramHandle, RefreshCount); 
 8005372:	4651      	mov	r1, sl
 8005374:	4628      	mov	r0, r5
 8005376:	f7fd f925 	bl	80025c4 <HAL_SDRAM_ProgramRefreshRate>
}
 800537a:	b002      	add	sp, #8
 800537c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005380:	20000404 	.word	0x20000404
 8005384:	20000414 	.word	0x20000414

08005388 <BSP_SDRAM_Init>:
{
 8005388:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  SdramHandle.Instance = FMC_SDRAM_DEVICE;
 800538c:	4d54      	ldr	r5, [pc, #336]	; (80054e0 <BSP_SDRAM_Init+0x158>)
  Timing.LoadToActiveDelay    = 2;
 800538e:	4f55      	ldr	r7, [pc, #340]	; (80054e4 <BSP_SDRAM_Init+0x15c>)
  SdramHandle.Instance = FMC_SDRAM_DEVICE;
 8005390:	4b55      	ldr	r3, [pc, #340]	; (80054e8 <BSP_SDRAM_Init+0x160>)
 8005392:	602b      	str	r3, [r5, #0]
  Timing.SelfRefreshTime      = 4;
 8005394:	2304      	movs	r3, #4
 8005396:	60bb      	str	r3, [r7, #8]
  SdramHandle.Init.RowBitsNumber      = FMC_SDRAM_ROW_BITS_NUM_12;
 8005398:	60eb      	str	r3, [r5, #12]
  SdramHandle.Init.MemoryDataWidth    = SDRAM_MEMORY_WIDTH;
 800539a:	2310      	movs	r3, #16
 800539c:	612b      	str	r3, [r5, #16]
  SdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 800539e:	2340      	movs	r3, #64	; 0x40
 80053a0:	616b      	str	r3, [r5, #20]
  SdramHandle.Init.CASLatency         = SDRAM_CAS_LATENCY;
 80053a2:	f44f 73c0 	mov.w	r3, #384	; 0x180
 80053a6:	61ab      	str	r3, [r5, #24]
  SdramHandle.Init.SDClockPeriod      = SDCLOCK_PERIOD;
 80053a8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80053ac:	622b      	str	r3, [r5, #32]
  SdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_1;
 80053ae:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  Timing.LoadToActiveDelay    = 2;
 80053b2:	2202      	movs	r2, #2
  SdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_1;
 80053b4:	62ab      	str	r3, [r5, #40]	; 0x28
  SdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
 80053b6:	2600      	movs	r6, #0
  static DMA_HandleTypeDef dmaHandle;
  GPIO_InitTypeDef GPIO_InitStructure;
  SDRAM_HandleTypeDef  *hsdram = &SdramHandle;

  /* Enable FMC clock */
  __FMC_CLK_ENABLE();
 80053b8:	4b4c      	ldr	r3, [pc, #304]	; (80054ec <BSP_SDRAM_Init+0x164>)
  Timing.LoadToActiveDelay    = 2;
 80053ba:	603a      	str	r2, [r7, #0]
  SdramHandle.Init.SDBank             = FMC_SDRAM_BANK2;
 80053bc:	f04f 0801 	mov.w	r8, #1
  Timing.ExitSelfRefreshDelay = 7;
 80053c0:	2107      	movs	r1, #7
  Timing.WriteRecoveryTime    = 2;
 80053c2:	613a      	str	r2, [r7, #16]
  Timing.RPDelay              = 2;
 80053c4:	617a      	str	r2, [r7, #20]
  Timing.RCDDelay             = 2;
 80053c6:	61ba      	str	r2, [r7, #24]
  Timing.ExitSelfRefreshDelay = 7;
 80053c8:	6079      	str	r1, [r7, #4]
  Timing.RowCycleDelay        = 7;
 80053ca:	60f9      	str	r1, [r7, #12]
  SdramHandle.Init.SDBank             = FMC_SDRAM_BANK2;
 80053cc:	f8c5 8004 	str.w	r8, [r5, #4]
  SdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
 80053d0:	60ae      	str	r6, [r5, #8]
  SdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 80053d2:	61ee      	str	r6, [r5, #28]
  SdramHandle.Init.ReadBurst          = SDRAM_READBURST;
 80053d4:	626e      	str	r6, [r5, #36]	; 0x24
  __FMC_CLK_ENABLE();
 80053d6:	6b99      	ldr	r1, [r3, #56]	; 0x38
  GPIO_InitStructure.Pull  = GPIO_NOPULL;
  GPIO_InitStructure.Alternate = GPIO_AF12_FMC;

  /* GPIOB configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_5 | GPIO_PIN_6;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);  
 80053d8:	4845      	ldr	r0, [pc, #276]	; (80054f0 <BSP_SDRAM_Init+0x168>)
  __FMC_CLK_ENABLE();
 80053da:	ea41 0108 	orr.w	r1, r1, r8
 80053de:	6399      	str	r1, [r3, #56]	; 0x38
  __DMAx_CLK_ENABLE();
 80053e0:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80053e2:	f441 0180 	orr.w	r1, r1, #4194304	; 0x400000
 80053e6:	6319      	str	r1, [r3, #48]	; 0x30
  __GPIOB_CLK_ENABLE();
 80053e8:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80053ea:	4311      	orrs	r1, r2
 80053ec:	6319      	str	r1, [r3, #48]	; 0x30
  __GPIOC_CLK_ENABLE();
 80053ee:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80053f0:	f041 0104 	orr.w	r1, r1, #4
 80053f4:	6319      	str	r1, [r3, #48]	; 0x30
  __GPIOD_CLK_ENABLE();
 80053f6:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80053f8:	f041 0108 	orr.w	r1, r1, #8
 80053fc:	6319      	str	r1, [r3, #48]	; 0x30
  __GPIOE_CLK_ENABLE();
 80053fe:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8005400:	f041 0110 	orr.w	r1, r1, #16
 8005404:	6319      	str	r1, [r3, #48]	; 0x30
  __GPIOF_CLK_ENABLE();
 8005406:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8005408:	f041 0120 	orr.w	r1, r1, #32
 800540c:	6319      	str	r1, [r3, #48]	; 0x30
  __GPIOG_CLK_ENABLE();
 800540e:	6b19      	ldr	r1, [r3, #48]	; 0x30
{
 8005410:	b086      	sub	sp, #24
  __GPIOG_CLK_ENABLE();
 8005412:	f041 0140 	orr.w	r1, r1, #64	; 0x40
  GPIO_InitStructure.Pin = GPIO_PIN_5 | GPIO_PIN_6;
 8005416:	ac06      	add	r4, sp, #24
  __GPIOG_CLK_ENABLE();
 8005418:	6319      	str	r1, [r3, #48]	; 0x30
  GPIO_InitStructure.Alternate = GPIO_AF12_FMC;
 800541a:	230c      	movs	r3, #12
 800541c:	9305      	str	r3, [sp, #20]
  GPIO_InitStructure.Pin = GPIO_PIN_5 | GPIO_PIN_6;
 800541e:	2360      	movs	r3, #96	; 0x60
 8005420:	f844 3d14 	str.w	r3, [r4, #-20]!
  HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);  
 8005424:	4621      	mov	r1, r4
  GPIO_InitStructure.Mode  = GPIO_MODE_AF_PP;
 8005426:	9202      	str	r2, [sp, #8]
  GPIO_InitStructure.Speed = GPIO_SPEED_FAST;
 8005428:	9204      	str	r2, [sp, #16]
  GPIO_InitStructure.Pull  = GPIO_NOPULL;
 800542a:	9603      	str	r6, [sp, #12]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);  
 800542c:	f7fb fb12 	bl	8000a54 <HAL_GPIO_Init>

  /* GPIOC configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0;      
  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);  
 8005430:	4621      	mov	r1, r4
 8005432:	4830      	ldr	r0, [pc, #192]	; (80054f4 <BSP_SDRAM_Init+0x16c>)
  GPIO_InitStructure.Pin = GPIO_PIN_0;      
 8005434:	f8cd 8004 	str.w	r8, [sp, #4]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);  
 8005438:	f7fb fb0c 	bl	8000a54 <HAL_GPIO_Init>
  
  /* GPIOD configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1  | GPIO_PIN_8 |
 800543c:	f24c 7303 	movw	r3, #50947	; 0xc703
                           GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_14 |
                           GPIO_PIN_15;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);
 8005440:	4621      	mov	r1, r4
 8005442:	482d      	ldr	r0, [pc, #180]	; (80054f8 <BSP_SDRAM_Init+0x170>)
  GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1  | GPIO_PIN_8 |
 8005444:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);
 8005446:	f7fb fb05 	bl	8000a54 <HAL_GPIO_Init>

  /* GPIOE configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0  | GPIO_PIN_1  | GPIO_PIN_7 |
 800544a:	f64f 7383 	movw	r3, #65411	; 0xff83
                           GPIO_PIN_8  | GPIO_PIN_9  | GPIO_PIN_10 |
                           GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 |
                           GPIO_PIN_14 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStructure);
 800544e:	4621      	mov	r1, r4
 8005450:	482a      	ldr	r0, [pc, #168]	; (80054fc <BSP_SDRAM_Init+0x174>)
  GPIO_InitStructure.Pin = GPIO_PIN_0  | GPIO_PIN_1  | GPIO_PIN_7 |
 8005452:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStructure);
 8005454:	f7fb fafe 	bl	8000a54 <HAL_GPIO_Init>

  /* GPIOF configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0  | GPIO_PIN_1 | GPIO_PIN_2 | 
 8005458:	f64f 033f 	movw	r3, #63551	; 0xf83f
                           GPIO_PIN_3  | GPIO_PIN_4 | GPIO_PIN_5 |
                           GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 |
                           GPIO_PIN_14 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOF, &GPIO_InitStructure);
 800545c:	4621      	mov	r1, r4
 800545e:	4828      	ldr	r0, [pc, #160]	; (8005500 <BSP_SDRAM_Init+0x178>)
  GPIO_InitStructure.Pin = GPIO_PIN_0  | GPIO_PIN_1 | GPIO_PIN_2 | 
 8005460:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOF, &GPIO_InitStructure);
 8005462:	f7fb faf7 	bl	8000a54 <HAL_GPIO_Init>

  /* GPIOG configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 |
                           GPIO_PIN_5 | GPIO_PIN_8 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
 8005466:	4621      	mov	r1, r4
  GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 |
 8005468:	f248 1333 	movw	r3, #33075	; 0x8133

  /* Configure common DMA parameters */
  dmaHandle.Init.Channel             = SDRAM_DMAx_CHANNEL;
 800546c:	4c25      	ldr	r4, [pc, #148]	; (8005504 <BSP_SDRAM_Init+0x17c>)
  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
 800546e:	4826      	ldr	r0, [pc, #152]	; (8005508 <BSP_SDRAM_Init+0x180>)
  GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 |
 8005470:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
 8005472:	f7fb faef 	bl	8000a54 <HAL_GPIO_Init>
  dmaHandle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
 8005476:	2380      	movs	r3, #128	; 0x80
 8005478:	60a3      	str	r3, [r4, #8]
  dmaHandle.Init.PeriphInc           = DMA_PINC_ENABLE;
 800547a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800547e:	60e3      	str	r3, [r4, #12]
  dmaHandle.Init.MemInc              = DMA_MINC_ENABLE;
 8005480:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8005484:	6123      	str	r3, [r4, #16]
  dmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8005486:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800548a:	6163      	str	r3, [r4, #20]
  dmaHandle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
 800548c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8005490:	61a3      	str	r3, [r4, #24]
  dmaHandle.Init.Mode                = DMA_NORMAL;
  dmaHandle.Init.Priority            = DMA_PRIORITY_HIGH;
 8005492:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8005496:	6223      	str	r3, [r4, #32]
  dmaHandle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
  dmaHandle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 8005498:	2303      	movs	r3, #3
 800549a:	62a3      	str	r3, [r4, #40]	; 0x28
  
  /* Associate the DMA handle */
  __HAL_LINKDMA(hsdram, hdma, dmaHandle);
  
  /* Deinitialize the stream for new transfer */
  HAL_DMA_DeInit(&dmaHandle);
 800549c:	4620      	mov	r0, r4
  dmaHandle.Instance = SDRAM_DMAx_STREAM;
 800549e:	4b1b      	ldr	r3, [pc, #108]	; (800550c <BSP_SDRAM_Init+0x184>)
 80054a0:	6023      	str	r3, [r4, #0]
  dmaHandle.Init.Channel             = SDRAM_DMAx_CHANNEL;
 80054a2:	6066      	str	r6, [r4, #4]
  dmaHandle.Init.Mode                = DMA_NORMAL;
 80054a4:	61e6      	str	r6, [r4, #28]
  dmaHandle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
 80054a6:	6266      	str	r6, [r4, #36]	; 0x24
  dmaHandle.Init.MemBurst            = DMA_MBURST_SINGLE;
 80054a8:	62e6      	str	r6, [r4, #44]	; 0x2c
  dmaHandle.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
 80054aa:	6326      	str	r6, [r4, #48]	; 0x30
  __HAL_LINKDMA(hsdram, hdma, dmaHandle);
 80054ac:	632c      	str	r4, [r5, #48]	; 0x30
 80054ae:	63a5      	str	r5, [r4, #56]	; 0x38
  HAL_DMA_DeInit(&dmaHandle);
 80054b0:	f7fa ffae 	bl	8000410 <HAL_DMA_DeInit>
  
  /* Configure the DMA stream */
  HAL_DMA_Init(&dmaHandle); 
 80054b4:	4620      	mov	r0, r4
 80054b6:	f7fa ff71 	bl	800039c <HAL_DMA_Init>
  
  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(SDRAM_DMAx_IRQn, 0, 0);
 80054ba:	4632      	mov	r2, r6
 80054bc:	4631      	mov	r1, r6
 80054be:	2038      	movs	r0, #56	; 0x38
 80054c0:	f7fa ff16 	bl	80002f0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SDRAM_DMAx_IRQn);
 80054c4:	2038      	movs	r0, #56	; 0x38
 80054c6:	f7fa ff47 	bl	8000358 <HAL_NVIC_EnableIRQ>
  HAL_SDRAM_Init(&SdramHandle, &Timing);
 80054ca:	4639      	mov	r1, r7
 80054cc:	4628      	mov	r0, r5
 80054ce:	f7fd f846 	bl	800255e <HAL_SDRAM_Init>
  BSP_SDRAM_Initialization_sequence(REFRESH_COUNT);
 80054d2:	f240 506a 	movw	r0, #1386	; 0x56a
 80054d6:	f7ff ff09 	bl	80052ec <BSP_SDRAM_Initialization_sequence>
}
 80054da:	b006      	add	sp, #24
 80054dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80054e0:	20000414 	.word	0x20000414
 80054e4:	20000448 	.word	0x20000448
 80054e8:	a0000140 	.word	0xa0000140
 80054ec:	40023800 	.word	0x40023800
 80054f0:	40020400 	.word	0x40020400
 80054f4:	40020800 	.word	0x40020800
 80054f8:	40020c00 	.word	0x40020c00
 80054fc:	40021000 	.word	0x40021000
 8005500:	40021400 	.word	0x40021400
 8005504:	20000464 	.word	0x20000464
 8005508:	40021800 	.word	0x40021800
 800550c:	40026410 	.word	0x40026410

08005510 <BSP_TS_Init>:
  * @param  XSize: The maximum X size of the TS area on LCD
  * @param  YSize: The maximum Y size of the TS area on LCD  
  * @retval TS_OK: if all initializations are OK. Other value if error.
  */
uint8_t BSP_TS_Init(uint16_t XSize, uint16_t YSize)
{
 8005510:	b538      	push	{r3, r4, r5, lr}
  uint8_t ret = TS_ERROR;

  /* Initialize x and y positions boundaries */
  TsXBoundary = XSize;
 8005512:	4b0c      	ldr	r3, [pc, #48]	; (8005544 <BSP_TS_Init+0x34>)
  TsYBoundary = YSize;

  /* Read ID and verify if the IO expander is ready */
  if(stmpe811_ts_drv.ReadID(TS_I2C_ADDRESS) == STMPE811_ID)
 8005514:	4c0c      	ldr	r4, [pc, #48]	; (8005548 <BSP_TS_Init+0x38>)
  TsXBoundary = XSize;
 8005516:	8018      	strh	r0, [r3, #0]
  TsYBoundary = YSize;
 8005518:	4b0c      	ldr	r3, [pc, #48]	; (800554c <BSP_TS_Init+0x3c>)
  if(stmpe811_ts_drv.ReadID(TS_I2C_ADDRESS) == STMPE811_ID)
 800551a:	2082      	movs	r0, #130	; 0x82
  TsYBoundary = YSize;
 800551c:	8019      	strh	r1, [r3, #0]
  if(stmpe811_ts_drv.ReadID(TS_I2C_ADDRESS) == STMPE811_ID)
 800551e:	6863      	ldr	r3, [r4, #4]
 8005520:	4798      	blx	r3
 8005522:	f640 0311 	movw	r3, #2065	; 0x811
 8005526:	4298      	cmp	r0, r3
 8005528:	d10a      	bne.n	8005540 <BSP_TS_Init+0x30>
  {
    /* Initialize the TS driver structure */
    TsDrv = &stmpe811_ts_drv;
 800552a:	4d09      	ldr	r5, [pc, #36]	; (8005550 <BSP_TS_Init+0x40>)
  }

  if(ret == TS_OK)
  {
    /* Initialize the LL TS Driver */
    TsDrv->Init(TS_I2C_ADDRESS);
 800552c:	6823      	ldr	r3, [r4, #0]
    TsDrv = &stmpe811_ts_drv;
 800552e:	602c      	str	r4, [r5, #0]
    TsDrv->Init(TS_I2C_ADDRESS);
 8005530:	2082      	movs	r0, #130	; 0x82
 8005532:	4798      	blx	r3
    TsDrv->Start(TS_I2C_ADDRESS);
 8005534:	682b      	ldr	r3, [r5, #0]
 8005536:	2082      	movs	r0, #130	; 0x82
 8005538:	68db      	ldr	r3, [r3, #12]
 800553a:	4798      	blx	r3
    ret = TS_OK;
 800553c:	2000      	movs	r0, #0
 800553e:	bd38      	pop	{r3, r4, r5, pc}
  uint8_t ret = TS_ERROR;
 8005540:	2001      	movs	r0, #1
  }

  return ret;
}
 8005542:	bd38      	pop	{r3, r4, r5, pc}
 8005544:	200004b8 	.word	0x200004b8
 8005548:	20000158 	.word	0x20000158
 800554c:	200004ba 	.word	0x200004ba
 8005550:	200004b4 	.word	0x200004b4

08005554 <HAL_LTDC_MspInit>:
{  
  GPIO_InitTypeDef GPIO_Init_Structure;
  
  /*##-1- Enable peripherals and GPIO Clocks #################################*/  
  /* Enable the LTDC Clock */
  __LTDC_CLK_ENABLE();
 8005554:	4b30      	ldr	r3, [pc, #192]	; (8005618 <HAL_LTDC_MspInit+0xc4>)
                                GPIO_PIN_11 | GPIO_PIN_12;
  GPIO_Init_Structure.Mode = GPIO_MODE_AF_PP;
  GPIO_Init_Structure.Pull = GPIO_NOPULL;
  GPIO_Init_Structure.Speed = GPIO_SPEED_FAST;
  GPIO_Init_Structure.Alternate= GPIO_AF14_LTDC;
  HAL_GPIO_Init(GPIOA, &GPIO_Init_Structure);
 8005556:	4831      	ldr	r0, [pc, #196]	; (800561c <HAL_LTDC_MspInit+0xc8>)
  __LTDC_CLK_ENABLE();
 8005558:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800555a:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
{  
 800555e:	b570      	push	{r4, r5, r6, lr}
  __LTDC_CLK_ENABLE();
 8005560:	645a      	str	r2, [r3, #68]	; 0x44
  __GPIOA_CLK_ENABLE();
 8005562:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  
  /* LTDC pins configuraiton: PB8 -- 11 */  
  GPIO_Init_Structure.Pin = GPIO_PIN_8 | \
                             GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;
  HAL_GPIO_Init(GPIOB, &GPIO_Init_Structure);
 8005564:	4d2e      	ldr	r5, [pc, #184]	; (8005620 <HAL_LTDC_MspInit+0xcc>)
  HAL_GPIO_Init(GPIOF, &GPIO_Init_Structure);     

  /* LTDC pins configuraiton: PG6 -- 7 */  
  GPIO_Init_Structure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | \
                             GPIO_PIN_11;
  HAL_GPIO_Init(GPIOG, &GPIO_Init_Structure);
 8005566:	4c2f      	ldr	r4, [pc, #188]	; (8005624 <HAL_LTDC_MspInit+0xd0>)
  __GPIOA_CLK_ENABLE();
 8005568:	f042 0201 	orr.w	r2, r2, #1
 800556c:	631a      	str	r2, [r3, #48]	; 0x30
  __GPIOB_CLK_ENABLE();
 800556e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005570:	f042 0202 	orr.w	r2, r2, #2
 8005574:	631a      	str	r2, [r3, #48]	; 0x30
  __GPIOC_CLK_ENABLE();
 8005576:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005578:	f042 0204 	orr.w	r2, r2, #4
 800557c:	631a      	str	r2, [r3, #48]	; 0x30
  __GPIOD_CLK_ENABLE();
 800557e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005580:	f042 0208 	orr.w	r2, r2, #8
 8005584:	631a      	str	r2, [r3, #48]	; 0x30
  __GPIOF_CLK_ENABLE();
 8005586:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005588:	f042 0220 	orr.w	r2, r2, #32
 800558c:	631a      	str	r2, [r3, #48]	; 0x30
  __GPIOG_CLK_ENABLE();
 800558e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
{  
 8005590:	b086      	sub	sp, #24
  __GPIOG_CLK_ENABLE();
 8005592:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8005596:	631a      	str	r2, [r3, #48]	; 0x30
  GPIO_Init_Structure.Pin = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6 |
 8005598:	f641 0358 	movw	r3, #6232	; 0x1858
  GPIO_Init_Structure.Pull = GPIO_NOPULL;
 800559c:	2200      	movs	r2, #0
  GPIO_Init_Structure.Pin = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6 |
 800559e:	9301      	str	r3, [sp, #4]
  GPIO_Init_Structure.Alternate= GPIO_AF14_LTDC;
 80055a0:	260e      	movs	r6, #14
  GPIO_Init_Structure.Mode = GPIO_MODE_AF_PP;
 80055a2:	2302      	movs	r3, #2
  HAL_GPIO_Init(GPIOA, &GPIO_Init_Structure);
 80055a4:	a901      	add	r1, sp, #4
  GPIO_Init_Structure.Pull = GPIO_NOPULL;
 80055a6:	9203      	str	r2, [sp, #12]
  GPIO_Init_Structure.Mode = GPIO_MODE_AF_PP;
 80055a8:	9302      	str	r3, [sp, #8]
  GPIO_Init_Structure.Speed = GPIO_SPEED_FAST;
 80055aa:	9304      	str	r3, [sp, #16]
  GPIO_Init_Structure.Alternate= GPIO_AF14_LTDC;
 80055ac:	9605      	str	r6, [sp, #20]
  HAL_GPIO_Init(GPIOA, &GPIO_Init_Structure);
 80055ae:	f7fb fa51 	bl	8000a54 <HAL_GPIO_Init>
  GPIO_Init_Structure.Pin = GPIO_PIN_8 | \
 80055b2:	f44f 6370 	mov.w	r3, #3840	; 0xf00
  HAL_GPIO_Init(GPIOB, &GPIO_Init_Structure);
 80055b6:	a901      	add	r1, sp, #4
 80055b8:	4628      	mov	r0, r5
  GPIO_Init_Structure.Pin = GPIO_PIN_8 | \
 80055ba:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOB, &GPIO_Init_Structure);
 80055bc:	f7fb fa4a 	bl	8000a54 <HAL_GPIO_Init>
  GPIO_Init_Structure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_10;
 80055c0:	f44f 6398 	mov.w	r3, #1216	; 0x4c0
  HAL_GPIO_Init(GPIOC, &GPIO_Init_Structure);
 80055c4:	a901      	add	r1, sp, #4
 80055c6:	4818      	ldr	r0, [pc, #96]	; (8005628 <HAL_LTDC_MspInit+0xd4>)
  GPIO_Init_Structure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_10;
 80055c8:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOC, &GPIO_Init_Structure);
 80055ca:	f7fb fa43 	bl	8000a54 <HAL_GPIO_Init>
  GPIO_Init_Structure.Pin = GPIO_PIN_3 | GPIO_PIN_6;
 80055ce:	2348      	movs	r3, #72	; 0x48
  HAL_GPIO_Init(GPIOD, &GPIO_Init_Structure);
 80055d0:	a901      	add	r1, sp, #4
 80055d2:	4816      	ldr	r0, [pc, #88]	; (800562c <HAL_LTDC_MspInit+0xd8>)
  GPIO_Init_Structure.Pin = GPIO_PIN_3 | GPIO_PIN_6;
 80055d4:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOD, &GPIO_Init_Structure);
 80055d6:	f7fb fa3d 	bl	8000a54 <HAL_GPIO_Init>
  GPIO_Init_Structure.Pin = GPIO_PIN_10;
 80055da:	f44f 6380 	mov.w	r3, #1024	; 0x400
  HAL_GPIO_Init(GPIOF, &GPIO_Init_Structure);     
 80055de:	a901      	add	r1, sp, #4
 80055e0:	4813      	ldr	r0, [pc, #76]	; (8005630 <HAL_LTDC_MspInit+0xdc>)
  GPIO_Init_Structure.Pin = GPIO_PIN_10;
 80055e2:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOF, &GPIO_Init_Structure);     
 80055e4:	f7fb fa36 	bl	8000a54 <HAL_GPIO_Init>
  GPIO_Init_Structure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | \
 80055e8:	f44f 630c 	mov.w	r3, #2240	; 0x8c0
  HAL_GPIO_Init(GPIOG, &GPIO_Init_Structure);
 80055ec:	a901      	add	r1, sp, #4
 80055ee:	4620      	mov	r0, r4
  GPIO_Init_Structure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | \
 80055f0:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOG, &GPIO_Init_Structure);
 80055f2:	f7fb fa2f 	bl	8000a54 <HAL_GPIO_Init>
 
  /* LTDC pins configuraiton: PB1 -- 1 */  
  GPIO_Init_Structure.Pin = GPIO_PIN_0 | GPIO_PIN_1;
 80055f6:	2303      	movs	r3, #3
  GPIO_Init_Structure.Alternate= GPIO_AF14_LTDC;
  HAL_GPIO_Init(GPIOB, &GPIO_Init_Structure);
 80055f8:	a901      	add	r1, sp, #4
 80055fa:	4628      	mov	r0, r5
  GPIO_Init_Structure.Pin = GPIO_PIN_0 | GPIO_PIN_1;
 80055fc:	9301      	str	r3, [sp, #4]
  GPIO_Init_Structure.Alternate= GPIO_AF14_LTDC;
 80055fe:	9605      	str	r6, [sp, #20]
  HAL_GPIO_Init(GPIOB, &GPIO_Init_Structure);
 8005600:	f7fb fa28 	bl	8000a54 <HAL_GPIO_Init>

  /* LTDC pins configuraiton: PG10 -- 12 */  
  GPIO_Init_Structure.Pin = GPIO_PIN_10 | GPIO_PIN_12;
 8005604:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  HAL_GPIO_Init(GPIOG, &GPIO_Init_Structure);
 8005608:	a901      	add	r1, sp, #4
 800560a:	4620      	mov	r0, r4
  GPIO_Init_Structure.Pin = GPIO_PIN_10 | GPIO_PIN_12;
 800560c:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(GPIOG, &GPIO_Init_Structure);
 800560e:	f7fb fa21 	bl	8000a54 <HAL_GPIO_Init>
}
 8005612:	b006      	add	sp, #24
 8005614:	bd70      	pop	{r4, r5, r6, pc}
 8005616:	bf00      	nop
 8005618:	40023800 	.word	0x40023800
 800561c:	40020000 	.word	0x40020000
 8005620:	40020400 	.word	0x40020400
 8005624:	40021800 	.word	0x40021800
 8005628:	40020800 	.word	0x40020800
 800562c:	40020c00 	.word	0x40020c00
 8005630:	40021400 	.word	0x40021400

08005634 <NMI_Handler>:
 8005634:	4770      	bx	lr

08005636 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8005636:	e7fe      	b.n	8005636 <HardFault_Handler>

08005638 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8005638:	e7fe      	b.n	8005638 <MemManage_Handler>

0800563a <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 800563a:	e7fe      	b.n	800563a <BusFault_Handler>

0800563c <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 800563c:	e7fe      	b.n	800563c <UsageFault_Handler>

0800563e <SVC_Handler>:
 800563e:	4770      	bx	lr

08005640 <DebugMon_Handler>:
 8005640:	4770      	bx	lr

08005642 <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 8005642:	4770      	bx	lr

08005644 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler (void)
{
 8005644:	b570      	push	{r4, r5, r6, lr}
  static __IO uint32_t counter=0;
  HAL_IncTick();
 8005646:	f7fa fe25 	bl	8000294 <HAL_IncTick>
  
	// For touch driver purposes
	++ts_buttons_delay ;
 800564a:	4a1a      	ldr	r2, [pc, #104]	; (80056b4 <SysTick_Handler+0x70>)
	++ts_mouse_last_signal_delay ;
	if (ts_slider_hop_time > 0 )
		++ts_slider_hop_time ;
	++gyro_interval;
  /* check Joystick state every polling interval (1ms) */
  if (counter++ == USBD_HID_GetPollingInterval(&USBD_Device))
 800564c:	4c1a      	ldr	r4, [pc, #104]	; (80056b8 <SysTick_Handler+0x74>)
	++ts_buttons_delay ;
 800564e:	6813      	ldr	r3, [r2, #0]
  if (counter++ == USBD_HID_GetPollingInterval(&USBD_Device))
 8005650:	481a      	ldr	r0, [pc, #104]	; (80056bc <SysTick_Handler+0x78>)
	++ts_buttons_delay ;
 8005652:	3301      	adds	r3, #1
 8005654:	6013      	str	r3, [r2, #0]
	++ts_mouse_last_signal_delay ;
 8005656:	4a1a      	ldr	r2, [pc, #104]	; (80056c0 <SysTick_Handler+0x7c>)
 8005658:	6813      	ldr	r3, [r2, #0]
 800565a:	3301      	adds	r3, #1
 800565c:	6013      	str	r3, [r2, #0]
	if (ts_slider_hop_time > 0 )
 800565e:	4b19      	ldr	r3, [pc, #100]	; (80056c4 <SysTick_Handler+0x80>)
 8005660:	681a      	ldr	r2, [r3, #0]
 8005662:	2a00      	cmp	r2, #0
		++ts_slider_hop_time ;
 8005664:	bfc2      	ittt	gt
 8005666:	681a      	ldrgt	r2, [r3, #0]
 8005668:	3201      	addgt	r2, #1
 800566a:	601a      	strgt	r2, [r3, #0]
	++gyro_interval;
 800566c:	4a16      	ldr	r2, [pc, #88]	; (80056c8 <SysTick_Handler+0x84>)
 800566e:	7813      	ldrb	r3, [r2, #0]
 8005670:	3301      	adds	r3, #1
 8005672:	b2db      	uxtb	r3, r3
 8005674:	7013      	strb	r3, [r2, #0]
  if (counter++ == USBD_HID_GetPollingInterval(&USBD_Device))
 8005676:	6825      	ldr	r5, [r4, #0]
 8005678:	1c6b      	adds	r3, r5, #1
 800567a:	6023      	str	r3, [r4, #0]
 800567c:	f7fe f848 	bl	8003710 <USBD_HID_GetPollingInterval>
 8005680:	4285      	cmp	r5, r0
 8005682:	4625      	mov	r5, r4
 8005684:	d115      	bne.n	80056b2 <SysTick_Handler+0x6e>
  {  
    
    /* send data though IN endpoint*/
    if((HID_Buffer[0] != 0) || (HID_Buffer[1] != 0) || HID_Buffer[2] != 0 || HID_Buffer[3] != 0 || unclick != 0 )
 8005686:	4c11      	ldr	r4, [pc, #68]	; (80056cc <SysTick_Handler+0x88>)
 8005688:	4e11      	ldr	r6, [pc, #68]	; (80056d0 <SysTick_Handler+0x8c>)
 800568a:	7823      	ldrb	r3, [r4, #0]
 800568c:	b93b      	cbnz	r3, 800569e <SysTick_Handler+0x5a>
 800568e:	7863      	ldrb	r3, [r4, #1]
 8005690:	b92b      	cbnz	r3, 800569e <SysTick_Handler+0x5a>
 8005692:	78a3      	ldrb	r3, [r4, #2]
 8005694:	b91b      	cbnz	r3, 800569e <SysTick_Handler+0x5a>
 8005696:	78e3      	ldrb	r3, [r4, #3]
 8005698:	b90b      	cbnz	r3, 800569e <SysTick_Handler+0x5a>
 800569a:	7833      	ldrb	r3, [r6, #0]
 800569c:	b13b      	cbz	r3, 80056ae <SysTick_Handler+0x6a>
    {
      USBD_HID_SendReport(&USBD_Device, HID_Buffer, 4);
 800569e:	2204      	movs	r2, #4
 80056a0:	490a      	ldr	r1, [pc, #40]	; (80056cc <SysTick_Handler+0x88>)
 80056a2:	4806      	ldr	r0, [pc, #24]	; (80056bc <SysTick_Handler+0x78>)
 80056a4:	f7fe f822 	bl	80036ec <USBD_HID_SendReport>
			unclick = 0;
 80056a8:	2300      	movs	r3, #0
 80056aa:	7033      	strb	r3, [r6, #0]
			HID_Buffer[3] = 0;
 80056ac:	70e3      	strb	r3, [r4, #3]
    }
    counter =0;
 80056ae:	2300      	movs	r3, #0
 80056b0:	602b      	str	r3, [r5, #0]
 80056b2:	bd70      	pop	{r4, r5, r6, pc}
 80056b4:	20000528 	.word	0x20000528
 80056b8:	200004bc 	.word	0x200004bc
 80056bc:	20000618 	.word	0x20000618
 80056c0:	20000530 	.word	0x20000530
 80056c4:	20000534 	.word	0x20000534
 80056c8:	20000276 	.word	0x20000276
 80056cc:	2000054c 	.word	0x2000054c
 80056d0:	20000550 	.word	0x20000550

080056d4 <OTG_HS_IRQHandler>:
  * @retval None
  */

void OTG_HS_IRQHandler(void)
{
  HAL_PCD_IRQHandler(&hpcd);
 80056d4:	4801      	ldr	r0, [pc, #4]	; (80056dc <OTG_HS_IRQHandler+0x8>)
 80056d6:	f7fb bf76 	b.w	80015c6 <HAL_PCD_IRQHandler>
 80056da:	bf00      	nop
 80056dc:	20000878 	.word	0x20000878

080056e0 <OTG_HS_WKUP_IRQHandler>:
  * @retval None
  */
  
void OTG_HS_WKUP_IRQHandler(void)
{
  if((&hpcd)->Init.low_power_enable)
 80056e0:	4916      	ldr	r1, [pc, #88]	; (800573c <OTG_HS_WKUP_IRQHandler+0x5c>)
 80056e2:	6a0a      	ldr	r2, [r1, #32]
 80056e4:	b32a      	cbz	r2, 8005732 <OTG_HS_WKUP_IRQHandler+0x52>
  {
    /* Reset SLEEPDEEP bit of Cortex System Control Register */
    SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));  
 80056e6:	4a16      	ldr	r2, [pc, #88]	; (8005740 <OTG_HS_WKUP_IRQHandler+0x60>)
 80056e8:	6913      	ldr	r3, [r2, #16]
 80056ea:	f023 0306 	bic.w	r3, r3, #6
 80056ee:	6113      	str	r3, [r2, #16]
    
    /* Configures system clock after wake-up from STOP: enable HSE, PLL and select 
    PLL as system clock source (HSE and PLL are disabled in STOP mode) */
    
    __HAL_RCC_HSE_CONFIG(RCC_HSE_ON);
 80056f0:	4b14      	ldr	r3, [pc, #80]	; (8005744 <OTG_HS_WKUP_IRQHandler+0x64>)
 80056f2:	2201      	movs	r2, #1
 80056f4:	701a      	strb	r2, [r3, #0]
    
    /* Wait till HSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80056f6:	3b02      	subs	r3, #2
 80056f8:	461a      	mov	r2, r3
 80056fa:	6818      	ldr	r0, [r3, #0]
 80056fc:	0380      	lsls	r0, r0, #14
 80056fe:	d5fc      	bpl.n	80056fa <OTG_HS_WKUP_IRQHandler+0x1a>
    {}
    
    /* Enable the main PLL. */
    __HAL_RCC_PLL_ENABLE();
 8005700:	4b11      	ldr	r3, [pc, #68]	; (8005748 <OTG_HS_WKUP_IRQHandler+0x68>)
 8005702:	2001      	movs	r0, #1
 8005704:	6018      	str	r0, [r3, #0]
    
    /* Wait till PLL is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8005706:	6813      	ldr	r3, [r2, #0]
 8005708:	019b      	lsls	r3, r3, #6
 800570a:	d5fc      	bpl.n	8005706 <OTG_HS_WKUP_IRQHandler+0x26>
    {}
    
    /* Select PLL as SYSCLK */
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_SYSCLKSOURCE_PLLCLK);
 800570c:	6893      	ldr	r3, [r2, #8]
 800570e:	f023 0303 	bic.w	r3, r3, #3
 8005712:	f043 0302 	orr.w	r3, r3, #2
 8005716:	6093      	str	r3, [r2, #8]
    
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8005718:	4a0c      	ldr	r2, [pc, #48]	; (800574c <OTG_HS_WKUP_IRQHandler+0x6c>)
 800571a:	6893      	ldr	r3, [r2, #8]
 800571c:	f003 030c 	and.w	r3, r3, #12
 8005720:	2b08      	cmp	r3, #8
 8005722:	d1fa      	bne.n	800571a <OTG_HS_WKUP_IRQHandler+0x3a>
    {}
    
    /* ungate PHY clock */
     __HAL_PCD_UNGATE_PHYCLOCK((&hpcd)); 
 8005724:	680a      	ldr	r2, [r1, #0]
 8005726:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 800572a:	f023 0301 	bic.w	r3, r3, #1
 800572e:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
  }

    /* Clear EXTI pending Bit*/
  __HAL_USB_HS_EXTI_CLEAR_FLAG();
 8005732:	4b07      	ldr	r3, [pc, #28]	; (8005750 <OTG_HS_WKUP_IRQHandler+0x70>)
 8005734:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8005738:	615a      	str	r2, [r3, #20]
 800573a:	4770      	bx	lr
 800573c:	20000878 	.word	0x20000878
 8005740:	e000ed00 	.word	0xe000ed00
 8005744:	40023802 	.word	0x40023802
 8005748:	42470060 	.word	0x42470060
 800574c:	40023800 	.word	0x40023800
 8005750:	40013c00 	.word	0x40013c00

08005754 <EXTI15_10_IRQHandler>:
	*	And STMPE811 driver is handling there.
*/

void STMPE811_INT_EXTIHandler(void) {
	
		ts_int_catched = 1 ;
 8005754:	4b04      	ldr	r3, [pc, #16]	; (8005768 <EXTI15_10_IRQHandler+0x14>)
 8005756:	2201      	movs	r2, #1
 8005758:	601a      	str	r2, [r3, #0]
	
		// Clear pending
		EXTI->PR |= STMPE811_INT_PIN ;
 800575a:	4a04      	ldr	r2, [pc, #16]	; (800576c <EXTI15_10_IRQHandler+0x18>)
 800575c:	6953      	ldr	r3, [r2, #20]
 800575e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8005762:	6153      	str	r3, [r2, #20]
 8005764:	4770      	bx	lr
 8005766:	bf00      	nop
 8005768:	2000052c 	.word	0x2000052c
 800576c:	40013c00 	.word	0x40013c00

08005770 <stmpe811_Reset>:
  * @brief  Reset the stmpe811 by Software.
  * @param  DeviceAddr: Device address on communication Bus.  
  * @retval None
  */
void stmpe811_Reset(uint16_t DeviceAddr)
{
 8005770:	b510      	push	{r4, lr}
  /* Power Down the stmpe811 */  
  IOE_Write(DeviceAddr, STMPE811_REG_SYS_CTRL1, 2);
 8005772:	b2c4      	uxtb	r4, r0
 8005774:	2202      	movs	r2, #2
 8005776:	2103      	movs	r1, #3
 8005778:	4620      	mov	r0, r4
 800577a:	f7ff f915 	bl	80049a8 <IOE_Write>

  /* Wait for a delay to ensure registers erasing */
  IOE_Delay(10); 
 800577e:	200a      	movs	r0, #10
 8005780:	f7ff f95e 	bl	8004a40 <IOE_Delay>
  
  /* Power On the Codec after the power off => all registers are reinitialized */
  IOE_Write(DeviceAddr, STMPE811_REG_SYS_CTRL1, 0);
 8005784:	4620      	mov	r0, r4
 8005786:	2200      	movs	r2, #0
 8005788:	2103      	movs	r1, #3
 800578a:	f7ff f90d 	bl	80049a8 <IOE_Write>
  
  /* Wait for a delay to ensure registers erasing */
  IOE_Delay(2); 
 800578e:	2002      	movs	r0, #2
}
 8005790:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  IOE_Delay(2); 
 8005794:	f7ff b954 	b.w	8004a40 <IOE_Delay>

08005798 <stmpe811_ReadID>:
  * @brief  Read the stmpe811 IO Expander device ID.
  * @param  DeviceAddr: Device address on communication Bus.  
  * @retval The Device ID (two bytes).
  */
uint16_t stmpe811_ReadID(uint16_t DeviceAddr)
{
 8005798:	b538      	push	{r3, r4, r5, lr}
 800579a:	4604      	mov	r4, r0
  /* Initialize IO BUS layer */
  IOE_Init(); 
  
  /* Return the device ID value */
  return ((IOE_Read(DeviceAddr, STMPE811_REG_CHP_ID_LSB) << 8) |\
 800579c:	b2e4      	uxtb	r4, r4
  IOE_Init(); 
 800579e:	f7ff f8dd 	bl	800495c <IOE_Init>
  return ((IOE_Read(DeviceAddr, STMPE811_REG_CHP_ID_LSB) << 8) |\
 80057a2:	2100      	movs	r1, #0
 80057a4:	4620      	mov	r0, r4
 80057a6:	f7ff f919 	bl	80049dc <IOE_Read>
          (IOE_Read(DeviceAddr, STMPE811_REG_CHP_ID_MSB)));
 80057aa:	2101      	movs	r1, #1
  return ((IOE_Read(DeviceAddr, STMPE811_REG_CHP_ID_LSB) << 8) |\
 80057ac:	4605      	mov	r5, r0
          (IOE_Read(DeviceAddr, STMPE811_REG_CHP_ID_MSB)));
 80057ae:	4620      	mov	r0, r4
 80057b0:	f7ff f914 	bl	80049dc <IOE_Read>
  return ((IOE_Read(DeviceAddr, STMPE811_REG_CHP_ID_LSB) << 8) |\
 80057b4:	ea40 2005 	orr.w	r0, r0, r5, lsl #8
}
 80057b8:	b280      	uxth	r0, r0
 80057ba:	bd38      	pop	{r3, r4, r5, pc}

080057bc <stmpe811_TS_DetectTouch>:
  * @brief  Return if there is touch detected or not.
  * @param  DeviceAddr: Device address on communication Bus.
  * @retval Touch detected state.
  */
uint8_t stmpe811_TS_DetectTouch(uint16_t DeviceAddr)
{
 80057bc:	b510      	push	{r4, lr}
  uint8_t state;
  uint8_t ret = 0;
  
  state = ((IOE_Read(DeviceAddr, STMPE811_REG_TSC_CTRL) & (uint8_t)STMPE811_TS_CTRL_STATUS) == (uint8_t)0x80);
 80057be:	b2c4      	uxtb	r4, r0
 80057c0:	2140      	movs	r1, #64	; 0x40
 80057c2:	4620      	mov	r0, r4
 80057c4:	f7ff f90a 	bl	80049dc <IOE_Read>
  
  if(state > 0)
 80057c8:	0603      	lsls	r3, r0, #24
 80057ca:	d507      	bpl.n	80057dc <stmpe811_TS_DetectTouch+0x20>
  {
    if(IOE_Read(DeviceAddr, STMPE811_REG_FIFO_SIZE) > 0)
 80057cc:	214c      	movs	r1, #76	; 0x4c
 80057ce:	4620      	mov	r0, r4
 80057d0:	f7ff f904 	bl	80049dc <IOE_Read>
    {
      ret = 1;
 80057d4:	3000      	adds	r0, #0
 80057d6:	bf18      	it	ne
 80057d8:	2001      	movne	r0, #1
 80057da:	bd10      	pop	{r4, pc}
    }
  }
  else
  {
    /* Reset FIFO */
    IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x01);
 80057dc:	4620      	mov	r0, r4
 80057de:	2201      	movs	r2, #1
 80057e0:	214b      	movs	r1, #75	; 0x4b
 80057e2:	f7ff f8e1 	bl	80049a8 <IOE_Write>
    /* Enable the FIFO again */
    IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x00);
 80057e6:	4620      	mov	r0, r4
 80057e8:	2200      	movs	r2, #0
 80057ea:	214b      	movs	r1, #75	; 0x4b
 80057ec:	f7ff f8dc 	bl	80049a8 <IOE_Write>
  uint8_t ret = 0;
 80057f0:	2000      	movs	r0, #0
  }
  
  return ret;
}
 80057f2:	bd10      	pop	{r4, pc}

080057f4 <stmpe811_TS_GetXY>:
  * @param  X: Pointer to X position value
  * @param  Y: Pointer to Y position value   
  * @retval None.
  */
void stmpe811_TS_GetXY(uint16_t DeviceAddr, uint16_t *X, uint16_t *Y)
{
 80057f4:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint8_t  dataXYZ[4];
  uint32_t uldataXYZ;

  IOE_ReadMultiple(DeviceAddr, STMPE811_REG_TSC_DATA_NON_INC, dataXYZ, sizeof(dataXYZ)) ;
 80057f6:	2304      	movs	r3, #4
 80057f8:	b2c4      	uxtb	r4, r0
{
 80057fa:	460e      	mov	r6, r1
 80057fc:	4615      	mov	r5, r2
  IOE_ReadMultiple(DeviceAddr, STMPE811_REG_TSC_DATA_NON_INC, dataXYZ, sizeof(dataXYZ)) ;
 80057fe:	21d7      	movs	r1, #215	; 0xd7
 8005800:	eb0d 0203 	add.w	r2, sp, r3
 8005804:	4620      	mov	r0, r4
 8005806:	f7ff f905 	bl	8004a14 <IOE_ReadMultiple>
 800580a:	9b01      	ldr	r3, [sp, #4]
 800580c:	ba1b      	rev	r3, r3
  
  /* Calculate positions values */
  uldataXYZ = (dataXYZ[0] << 24)|(dataXYZ[1] << 16)|(dataXYZ[2] << 8)|(dataXYZ[3] << 0);     
  *X = (uldataXYZ >> 20) & 0x00000FFF;     
 800580e:	0d1a      	lsrs	r2, r3, #20
  *Y = (uldataXYZ >>  8) & 0x00000FFF;     
 8005810:	f3c3 230b 	ubfx	r3, r3, #8, #12
  *X = (uldataXYZ >> 20) & 0x00000FFF;     
 8005814:	8032      	strh	r2, [r6, #0]

  /* Reset FIFO */
  IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x01);
 8005816:	4620      	mov	r0, r4
  *Y = (uldataXYZ >>  8) & 0x00000FFF;     
 8005818:	802b      	strh	r3, [r5, #0]
  IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x01);
 800581a:	2201      	movs	r2, #1
 800581c:	214b      	movs	r1, #75	; 0x4b
 800581e:	f7ff f8c3 	bl	80049a8 <IOE_Write>
  /* Enable the FIFO again */
  IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x00);
 8005822:	2200      	movs	r2, #0
 8005824:	214b      	movs	r1, #75	; 0x4b
 8005826:	4620      	mov	r0, r4
 8005828:	f7ff f8be 	bl	80049a8 <IOE_Write>
}
 800582c:	b002      	add	sp, #8
 800582e:	bd70      	pop	{r4, r5, r6, pc}

08005830 <stmpe811_Init>:
{
 8005830:	b510      	push	{r4, lr}
  uint8_t idx = 0;
  
  /* Check all the registered instances */
  for(idx = 0; idx < STMPE811_MAX_INSTANCE ; idx ++)
  {
    if(stmpe811[idx] == DeviceAddr)
 8005832:	4a0b      	ldr	r2, [pc, #44]	; (8005860 <stmpe811_Init+0x30>)
 8005834:	7813      	ldrb	r3, [r2, #0]
 8005836:	4298      	cmp	r0, r3
{
 8005838:	4604      	mov	r4, r0
    if(stmpe811[idx] == DeviceAddr)
 800583a:	d010      	beq.n	800585e <stmpe811_Init+0x2e>
 800583c:	7851      	ldrb	r1, [r2, #1]
 800583e:	4288      	cmp	r0, r1
 8005840:	d103      	bne.n	800584a <stmpe811_Init+0x1a>
 8005842:	bd10      	pop	{r4, pc}
 8005844:	b959      	cbnz	r1, 800585e <stmpe811_Init+0x2e>
  for(idx = 0; idx < STMPE811_MAX_INSTANCE ; idx ++)
 8005846:	2301      	movs	r3, #1
 8005848:	e001      	b.n	800584e <stmpe811_Init+0x1e>
    if(stmpe811[idx] == DeviceAddr)
 800584a:	2b00      	cmp	r3, #0
 800584c:	d1fa      	bne.n	8005844 <stmpe811_Init+0x14>
      stmpe811[empty] = DeviceAddr;
 800584e:	54d4      	strb	r4, [r2, r3]
      IOE_Init(); 
 8005850:	f7ff f884 	bl	800495c <IOE_Init>
      stmpe811_Reset(DeviceAddr);
 8005854:	4620      	mov	r0, r4
}
 8005856:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      stmpe811_Reset(DeviceAddr);
 800585a:	f7ff bf89 	b.w	8005770 <stmpe811_Reset>
 800585e:	bd10      	pop	{r4, pc}
 8005860:	200004c0 	.word	0x200004c0

08005864 <stmpe811_EnableGlobalIT>:
{
 8005864:	b510      	push	{r4, lr}
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_INT_CTRL);
 8005866:	b2c4      	uxtb	r4, r0
 8005868:	2109      	movs	r1, #9
 800586a:	4620      	mov	r0, r4
 800586c:	f7ff f8b6 	bl	80049dc <IOE_Read>
  tmp |= (uint8_t)STMPE811_GIT_EN;
 8005870:	f040 0201 	orr.w	r2, r0, #1
  IOE_Write(DeviceAddr, STMPE811_REG_INT_CTRL, tmp); 
 8005874:	b2d2      	uxtb	r2, r2
 8005876:	4620      	mov	r0, r4
 8005878:	2109      	movs	r1, #9
}
 800587a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  IOE_Write(DeviceAddr, STMPE811_REG_INT_CTRL, tmp); 
 800587e:	f7ff b893 	b.w	80049a8 <IOE_Write>

08005882 <stmpe811_DisableGlobalIT>:
{
 8005882:	b510      	push	{r4, lr}
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_INT_CTRL);
 8005884:	b2c4      	uxtb	r4, r0
 8005886:	2109      	movs	r1, #9
 8005888:	4620      	mov	r0, r4
 800588a:	f7ff f8a7 	bl	80049dc <IOE_Read>
  IOE_Write(DeviceAddr, STMPE811_REG_INT_CTRL, tmp);
 800588e:	2109      	movs	r1, #9
 8005890:	f000 02fe 	and.w	r2, r0, #254	; 0xfe
 8005894:	4620      	mov	r0, r4
}
 8005896:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  IOE_Write(DeviceAddr, STMPE811_REG_INT_CTRL, tmp);
 800589a:	f7ff b885 	b.w	80049a8 <IOE_Write>

0800589e <stmpe811_EnableITSource>:
{
 800589e:	b538      	push	{r3, r4, r5, lr}
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_INT_EN);
 80058a0:	b2c5      	uxtb	r5, r0
{
 80058a2:	460c      	mov	r4, r1
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_INT_EN);
 80058a4:	4628      	mov	r0, r5
 80058a6:	210a      	movs	r1, #10
 80058a8:	f7ff f898 	bl	80049dc <IOE_Read>
  tmp |= Source; 
 80058ac:	ea40 0204 	orr.w	r2, r0, r4
  IOE_Write(DeviceAddr, STMPE811_REG_INT_EN, tmp);   
 80058b0:	b2d2      	uxtb	r2, r2
 80058b2:	4628      	mov	r0, r5
 80058b4:	210a      	movs	r1, #10
}
 80058b6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  IOE_Write(DeviceAddr, STMPE811_REG_INT_EN, tmp);   
 80058ba:	f7ff b875 	b.w	80049a8 <IOE_Write>

080058be <stmpe811_TS_EnableIT>:
{
 80058be:	b510      	push	{r4, lr}
 80058c0:	4604      	mov	r4, r0
  IOE_ITConfig();
 80058c2:	f7ff f84d 	bl	8004960 <IOE_ITConfig>
  stmpe811_EnableITSource(DeviceAddr, STMPE811_TS_IT); 
 80058c6:	4620      	mov	r0, r4
 80058c8:	211f      	movs	r1, #31
 80058ca:	f7ff ffe8 	bl	800589e <stmpe811_EnableITSource>
  stmpe811_EnableGlobalIT(DeviceAddr);
 80058ce:	4620      	mov	r0, r4
}
 80058d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  stmpe811_EnableGlobalIT(DeviceAddr);
 80058d4:	f7ff bfc6 	b.w	8005864 <stmpe811_EnableGlobalIT>

080058d8 <stmpe811_DisableITSource>:
{
 80058d8:	b538      	push	{r3, r4, r5, lr}
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_INT_EN);
 80058da:	b2c5      	uxtb	r5, r0
{
 80058dc:	460c      	mov	r4, r1
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_INT_EN);
 80058de:	4628      	mov	r0, r5
 80058e0:	210a      	movs	r1, #10
 80058e2:	f7ff f87b 	bl	80049dc <IOE_Read>
  tmp &= ~Source; 
 80058e6:	ea20 0204 	bic.w	r2, r0, r4
  IOE_Write(DeviceAddr, STMPE811_REG_INT_EN, tmp);   
 80058ea:	b2d2      	uxtb	r2, r2
 80058ec:	4628      	mov	r0, r5
 80058ee:	210a      	movs	r1, #10
}
 80058f0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  IOE_Write(DeviceAddr, STMPE811_REG_INT_EN, tmp);   
 80058f4:	f7ff b858 	b.w	80049a8 <IOE_Write>

080058f8 <stmpe811_TS_DisableIT>:
{
 80058f8:	b510      	push	{r4, lr}
 80058fa:	4604      	mov	r4, r0
  stmpe811_DisableGlobalIT(DeviceAddr);
 80058fc:	f7ff ffc1 	bl	8005882 <stmpe811_DisableGlobalIT>
  stmpe811_DisableITSource(DeviceAddr, STMPE811_TS_IT); 
 8005900:	4620      	mov	r0, r4
 8005902:	211f      	movs	r1, #31
}
 8005904:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  stmpe811_DisableITSource(DeviceAddr, STMPE811_TS_IT); 
 8005908:	f7ff bfe6 	b.w	80058d8 <stmpe811_DisableITSource>

0800590c <stmpe811_ReadGITStatus>:
{
 800590c:	b510      	push	{r4, lr}
  return((IOE_Read(DeviceAddr, STMPE811_REG_INT_STA) & Source));
 800590e:	b2c0      	uxtb	r0, r0
{
 8005910:	460c      	mov	r4, r1
  return((IOE_Read(DeviceAddr, STMPE811_REG_INT_STA) & Source));
 8005912:	210b      	movs	r1, #11
 8005914:	f7ff f862 	bl	80049dc <IOE_Read>
}
 8005918:	4020      	ands	r0, r4
 800591a:	bd10      	pop	{r4, pc}

0800591c <stmpe811_TS_ITStatus>:
  return(stmpe811_ReadGITStatus(DeviceAddr, STMPE811_TS_IT));
 800591c:	211f      	movs	r1, #31
 800591e:	f7ff bff5 	b.w	800590c <stmpe811_ReadGITStatus>

08005922 <stmpe811_ClearGlobalIT>:
  IOE_Write(DeviceAddr, STMPE811_REG_INT_STA, Source);
 8005922:	460a      	mov	r2, r1
 8005924:	b2c0      	uxtb	r0, r0
 8005926:	210b      	movs	r1, #11
 8005928:	f7ff b83e 	b.w	80049a8 <IOE_Write>

0800592c <stmpe811_TS_ClearIT>:
  stmpe811_ClearGlobalIT(DeviceAddr, STMPE811_TS_IT);
 800592c:	211f      	movs	r1, #31
 800592e:	f7ff bff8 	b.w	8005922 <stmpe811_ClearGlobalIT>

08005932 <stmpe811_IO_DisableAF>:
{
 8005932:	b538      	push	{r3, r4, r5, lr}
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_IO_AF);
 8005934:	b2c5      	uxtb	r5, r0
{
 8005936:	460c      	mov	r4, r1
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_IO_AF);
 8005938:	4628      	mov	r0, r5
 800593a:	2117      	movs	r1, #23
 800593c:	f7ff f84e 	bl	80049dc <IOE_Read>
  tmp &= ~(uint8_t)IO_Pin;   
 8005940:	ea20 0204 	bic.w	r2, r0, r4
  IOE_Write(DeviceAddr, STMPE811_REG_IO_AF, tmp);
 8005944:	b2d2      	uxtb	r2, r2
 8005946:	4628      	mov	r0, r5
 8005948:	2117      	movs	r1, #23
}
 800594a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  IOE_Write(DeviceAddr, STMPE811_REG_IO_AF, tmp);
 800594e:	f7ff b82b 	b.w	80049a8 <IOE_Write>

08005952 <stmpe811_TS_Start>:
{
 8005952:	b538      	push	{r3, r4, r5, lr}
  mode = IOE_Read(DeviceAddr, STMPE811_REG_SYS_CTRL2);
 8005954:	b2c4      	uxtb	r4, r0
{
 8005956:	4605      	mov	r5, r0
  mode = IOE_Read(DeviceAddr, STMPE811_REG_SYS_CTRL2);
 8005958:	2104      	movs	r1, #4
 800595a:	4620      	mov	r0, r4
 800595c:	f7ff f83e 	bl	80049dc <IOE_Read>
  IOE_Write(DeviceAddr, STMPE811_REG_SYS_CTRL2, mode); 
 8005960:	2104      	movs	r1, #4
 8005962:	f000 02fc 	and.w	r2, r0, #252	; 0xfc
 8005966:	4620      	mov	r0, r4
 8005968:	f7ff f81e 	bl	80049a8 <IOE_Write>
  IOE_Write(DeviceAddr, STMPE811_REG_ADC_CTRL1, 0x49);
 800596c:	2249      	movs	r2, #73	; 0x49
 800596e:	2120      	movs	r1, #32
 8005970:	4620      	mov	r0, r4
 8005972:	f7ff f819 	bl	80049a8 <IOE_Write>
  IOE_Delay(2); 
 8005976:	2002      	movs	r0, #2
 8005978:	f7ff f862 	bl	8004a40 <IOE_Delay>
  IOE_Write(DeviceAddr, STMPE811_REG_ADC_CTRL2, 0x01);
 800597c:	2201      	movs	r2, #1
 800597e:	4620      	mov	r0, r4
 8005980:	2121      	movs	r1, #33	; 0x21
 8005982:	f7ff f811 	bl	80049a8 <IOE_Write>
  stmpe811_IO_DisableAF(DeviceAddr, STMPE811_TOUCH_IO_ALL);
 8005986:	4628      	mov	r0, r5
 8005988:	211e      	movs	r1, #30
 800598a:	f7ff ffd2 	bl	8005932 <stmpe811_IO_DisableAF>
  IOE_Write(DeviceAddr, STMPE811_REG_TSC_CFG, 0x9A); 
 800598e:	4620      	mov	r0, r4
 8005990:	229a      	movs	r2, #154	; 0x9a
 8005992:	2141      	movs	r1, #65	; 0x41
 8005994:	f7ff f808 	bl	80049a8 <IOE_Write>
  IOE_Write(DeviceAddr, STMPE811_REG_FIFO_TH, 0x01);
 8005998:	4620      	mov	r0, r4
 800599a:	2201      	movs	r2, #1
 800599c:	214a      	movs	r1, #74	; 0x4a
 800599e:	f7ff f803 	bl	80049a8 <IOE_Write>
  IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x01);
 80059a2:	4620      	mov	r0, r4
 80059a4:	2201      	movs	r2, #1
 80059a6:	214b      	movs	r1, #75	; 0x4b
 80059a8:	f7fe fffe 	bl	80049a8 <IOE_Write>
  IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x00);
 80059ac:	4620      	mov	r0, r4
 80059ae:	2200      	movs	r2, #0
 80059b0:	214b      	movs	r1, #75	; 0x4b
 80059b2:	f7fe fff9 	bl	80049a8 <IOE_Write>
  IOE_Write(DeviceAddr, STMPE811_REG_TSC_FRACT_XYZ, 0x01);
 80059b6:	4620      	mov	r0, r4
 80059b8:	2201      	movs	r2, #1
 80059ba:	2156      	movs	r1, #86	; 0x56
 80059bc:	f7fe fff4 	bl	80049a8 <IOE_Write>
  IOE_Write(DeviceAddr, STMPE811_REG_TSC_I_DRIVE, 0x01);
 80059c0:	4620      	mov	r0, r4
 80059c2:	2201      	movs	r2, #1
 80059c4:	2158      	movs	r1, #88	; 0x58
 80059c6:	f7fe ffef 	bl	80049a8 <IOE_Write>
  IOE_Write(DeviceAddr, STMPE811_REG_TSC_CTRL, 0x01);
 80059ca:	4620      	mov	r0, r4
 80059cc:	2201      	movs	r2, #1
 80059ce:	2140      	movs	r1, #64	; 0x40
 80059d0:	f7fe ffea 	bl	80049a8 <IOE_Write>
  IOE_Write(DeviceAddr, STMPE811_REG_INT_STA, 0xFF);
 80059d4:	4620      	mov	r0, r4
 80059d6:	22ff      	movs	r2, #255	; 0xff
 80059d8:	210b      	movs	r1, #11
 80059da:	f7fe ffe5 	bl	80049a8 <IOE_Write>
  IOE_Delay(2); 
 80059de:	2002      	movs	r0, #2
}
 80059e0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  IOE_Delay(2); 
 80059e4:	f7ff b82c 	b.w	8004a40 <IOE_Delay>

080059e8 <BSP_TS_Init_extends>:
volatile sig_atomic_t ts_slider_hop_time = 0 ;

/** 
	* Enable FIFO Threshold and Touch Detection interrupts
*/
void BSP_TS_Init_extends( uint16_t DeviceAddr ) {
 80059e8:	b510      	push	{r4, lr}
	
	// Disable the TS module
	IOE_Write( DeviceAddr, STMPE811_REG_TSC_CTRL, 0x00);
 80059ea:	b2c4      	uxtb	r4, r0
 80059ec:	4620      	mov	r0, r4
 80059ee:	2200      	movs	r2, #0
 80059f0:	2140      	movs	r1, #64	; 0x40
 80059f2:	f7fe ffd9 	bl	80049a8 <IOE_Write>
	

	// Set FIFO Threshold and touch detection interrupts and fifo overflow
	IOE_Write( DeviceAddr, STMPE811_REG_INT_EN, (uint8_t)( STMPE811_GIT_TOUCH | STMPE811_GIT_FTH | STMPE811_GIT_FOV ) ) ;
 80059f6:	4620      	mov	r0, r4
 80059f8:	2207      	movs	r2, #7
 80059fa:	210a      	movs	r1, #10
 80059fc:	f7fe ffd4 	bl	80049a8 <IOE_Write>
	
	// Set Innterrupt polarity: falling and type: edge
	// and enable Global interrupts
	IOE_Write(DeviceAddr, STMPE811_REG_INT_CTRL , 0x03 ) ;
 8005a00:	4620      	mov	r0, r4
 8005a02:	2203      	movs	r2, #3
 8005a04:	2109      	movs	r1, #9
 8005a06:	f7fe ffcf 	bl	80049a8 <IOE_Write>
	
	// Set FIFO Threshold samples
	IOE_Write( DeviceAddr, STMPE811_REG_FIFO_TH, TS_FIFO_THRESHOLD_VALUE ) ;
 8005a0a:	4620      	mov	r0, r4
 8005a0c:	220c      	movs	r2, #12
 8005a0e:	214a      	movs	r1, #74	; 0x4a
 8005a10:	f7fe ffca 	bl	80049a8 <IOE_Write>
	
	// Enable TC module with:
	// Enable XY mode and movement tracking
	IOE_Write( DeviceAddr, STMPE811_REG_TSC_CTRL,   (1<<5) | ( 1<<5 ) | 0x03 );
 8005a14:	4620      	mov	r0, r4
 8005a16:	2223      	movs	r2, #35	; 0x23
 8005a18:	2140      	movs	r1, #64	; 0x40
 8005a1a:	f7fe ffc5 	bl	80049a8 <IOE_Write>
  
  // Clear all the status pending bits if any
  IOE_Write( DeviceAddr, STMPE811_REG_INT_STA, 0xFF );
 8005a1e:	4620      	mov	r0, r4
 8005a20:	22ff      	movs	r2, #255	; 0xff
 8005a22:	210b      	movs	r1, #11
 8005a24:	f7fe ffc0 	bl	80049a8 <IOE_Write>

  // Wait for 2 ms delay
  IOE_Delay(2);
 8005a28:	2002      	movs	r0, #2
 8005a2a:	f7ff f809 	bl	8004a40 <IOE_Delay>
	
	// Config EXTI
	IOE_ITConfig();
	
}
 8005a2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	IOE_ITConfig();
 8005a32:	f7fe bf95 	b.w	8004960 <IOE_ITConfig>

08005a36 <TS_getFIFO_size>:




uint8_t TS_getFIFO_size ( uint16_t DeviceAddr ) {
	 return IOE_Read( DeviceAddr, STMPE811_REG_FIFO_SIZE ) ;
 8005a36:	214c      	movs	r1, #76	; 0x4c
 8005a38:	b2c0      	uxtb	r0, r0
 8005a3a:	f7fe bfcf 	b.w	80049dc <IOE_Read>

08005a3e <TS_readFIFO>:
}

uint8_t TS_readFIFO ( uint16_t DeviceAddr, uint16_t no, uint8_t *pTab ) {
 8005a3e:	b508      	push	{r3, lr}

	//STMPE811_REG_TSC_DATA_XYZ;
	return (uint8_t)IOE_ReadMultiple( DeviceAddr, STMPE811_REG_TSC_DATA_NON_INC , pTab, no ) ;
 8005a40:	b2c0      	uxtb	r0, r0
 8005a42:	460b      	mov	r3, r1
 8005a44:	21d7      	movs	r1, #215	; 0xd7
 8005a46:	f7fe ffe5 	bl	8004a14 <IOE_ReadMultiple>
	
}
 8005a4a:	b2c0      	uxtb	r0, r0
 8005a4c:	bd08      	pop	{r3, pc}

08005a4e <TS_flushFIFO>:

void TS_flushFIFO(  uint16_t DeviceAddr ) {
 8005a4e:	b510      	push	{r4, lr}
	/* Reset FIFO */
  IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x01);
 8005a50:	b2c4      	uxtb	r4, r0
 8005a52:	4620      	mov	r0, r4
 8005a54:	2201      	movs	r2, #1
 8005a56:	214b      	movs	r1, #75	; 0x4b
 8005a58:	f7fe ffa6 	bl	80049a8 <IOE_Write>
  /* Enable the FIFO again */
	//HAL_Delay(1) ;
  IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x00);
 8005a5c:	4620      	mov	r0, r4
 8005a5e:	2200      	movs	r2, #0
 8005a60:	214b      	movs	r1, #75	; 0x4b
	
}
 8005a62:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x00);
 8005a66:	f7fe bf9f 	b.w	80049a8 <IOE_Write>
	...

08005a6c <TS_setCurrMouseState>:
}

void TS_setCurrMouseStateNoNotify( const TS_mouseInputTypeDef _state_ ) {
	mouse_current_state = _state_ ;
}
void TS_setCurrMouseState( const TS_mouseInputTypeDef _state_ ) {
 8005a6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t i ;
	
	mouse_current_state = _state_ ;
 8005a6e:	4b08      	ldr	r3, [pc, #32]	; (8005a90 <TS_setCurrMouseState+0x24>)
	
	//Call user's defined funtion to sent notification to them
	for ( i = 0 ; i < TS_NOTIFIED_FUNCTION_NO ; ++i ) {
			if ( NULL != p_FuncToNotify[i] ) {
 8005a70:	4e08      	ldr	r6, [pc, #32]	; (8005a94 <TS_setCurrMouseState+0x28>)
				// send notify
				p_FuncToNotify[i]( _state_, &xy_act ) ;
 8005a72:	4f09      	ldr	r7, [pc, #36]	; (8005a98 <TS_setCurrMouseState+0x2c>)
	mouse_current_state = _state_ ;
 8005a74:	7018      	strb	r0, [r3, #0]
void TS_setCurrMouseState( const TS_mouseInputTypeDef _state_ ) {
 8005a76:	4605      	mov	r5, r0
	mouse_current_state = _state_ ;
 8005a78:	2400      	movs	r4, #0
			if ( NULL != p_FuncToNotify[i] ) {
 8005a7a:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
 8005a7e:	b113      	cbz	r3, 8005a86 <TS_setCurrMouseState+0x1a>
				p_FuncToNotify[i]( _state_, &xy_act ) ;
 8005a80:	4639      	mov	r1, r7
 8005a82:	4628      	mov	r0, r5
 8005a84:	4798      	blx	r3
 8005a86:	3401      	adds	r4, #1
	for ( i = 0 ; i < TS_NOTIFIED_FUNCTION_NO ; ++i ) {
 8005a88:	2c04      	cmp	r4, #4
 8005a8a:	d1f6      	bne.n	8005a7a <TS_setCurrMouseState+0xe>
			}
	}
	
}
 8005a8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005a8e:	bf00      	nop
 8005a90:	200004e7 	.word	0x200004e7
 8005a94:	20000518 	.word	0x20000518
 8005a98:	20000538 	.word	0x20000538

08005a9c <TS_registerNotifyFunc>:

uint8_t TS_registerNotifyFunc( func_notify_TypeDef _in_ ) {
	uint8_t i ;
	
	for ( i = 0 ; i < TS_NOTIFIED_FUNCTION_NO ; ++i ) {
		if ( NULL == p_FuncToNotify[i] ) {
 8005a9c:	4a06      	ldr	r2, [pc, #24]	; (8005ab8 <TS_registerNotifyFunc+0x1c>)
uint8_t TS_registerNotifyFunc( func_notify_TypeDef _in_ ) {
 8005a9e:	2300      	movs	r3, #0
		if ( NULL == p_FuncToNotify[i] ) {
 8005aa0:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 8005aa4:	b919      	cbnz	r1, 8005aae <TS_registerNotifyFunc+0x12>
			p_FuncToNotify[i] = _in_ ;
 8005aa6:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
			return 1 ;
 8005aaa:	2001      	movs	r0, #1
 8005aac:	4770      	bx	lr
 8005aae:	3301      	adds	r3, #1
	for ( i = 0 ; i < TS_NOTIFIED_FUNCTION_NO ; ++i ) {
 8005ab0:	2b04      	cmp	r3, #4
 8005ab2:	d1f5      	bne.n	8005aa0 <TS_registerNotifyFunc+0x4>
		}
	}
	return 0;
 8005ab4:	2000      	movs	r0, #0
}
 8005ab6:	4770      	bx	lr
 8005ab8:	20000518 	.word	0x20000518

08005abc <TS_convertXY>:

// Konwertuje na dane x, y - 3bajtowe dane wejsciowe ( tryb XY )
// no - wielokrotne liczby 3
void TS_convertXY( uint16_t DeviceAddr, uint16_t no, uint8_t *pTab, uint16_t *pX, uint16_t *pY ) {
 8005abc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005abe:	9e05      	ldr	r6, [sp, #20]
	uint16_t i, j ;
	
	for( i = 0, j = 0 ; i < no ; ++i, j+=3 ) {
 8005ac0:	2000      	movs	r0, #0
 8005ac2:	3e02      	subs	r6, #2
 8005ac4:	3b02      	subs	r3, #2
		
		pX[i] = pY[i] = 0 ;
 8005ac6:	4607      	mov	r7, r0
 8005ac8:	eb00 0540 	add.w	r5, r0, r0, lsl #1
	for( i = 0, j = 0 ; i < no ; ++i, j+=3 ) {
 8005acc:	4288      	cmp	r0, r1
 8005ace:	b2ad      	uxth	r5, r5
 8005ad0:	d100      	bne.n	8005ad4 <TS_convertXY+0x18>
		pY[i] = ( (uint16_t)( pTab[j+1] ) & 0x000Fu ) << 8  ;
		pY[i] |= pTab[j+2] ;
		
	}
	
}
 8005ad2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		pX[i] = pY[i] = 0 ;
 8005ad4:	8077      	strh	r7, [r6, #2]
 8005ad6:	805f      	strh	r7, [r3, #2]
		pX[i] = (uint16_t)( pTab[j] ) << 4 ;
 8005ad8:	5d54      	ldrb	r4, [r2, r5]
		pX[i] |= ( (uint16_t)( pTab[j+1] ) & 0x00F0u ) >> 4 ;
 8005ada:	f105 0e01 	add.w	lr, r5, #1
		pX[i] = (uint16_t)( pTab[j] ) << 4 ;
 8005ade:	0124      	lsls	r4, r4, #4
 8005ae0:	805c      	strh	r4, [r3, #2]
		pX[i] |= ( (uint16_t)( pTab[j+1] ) & 0x00F0u ) >> 4 ;
 8005ae2:	f812 c00e 	ldrb.w	ip, [r2, lr]
 8005ae6:	ea44 141c 	orr.w	r4, r4, ip, lsr #4
 8005aea:	f823 4f02 	strh.w	r4, [r3, #2]!
		pY[i] = ( (uint16_t)( pTab[j+1] ) & 0x000Fu ) << 8  ;
 8005aee:	f812 400e 	ldrb.w	r4, [r2, lr]
 8005af2:	0224      	lsls	r4, r4, #8
 8005af4:	f404 6470 	and.w	r4, r4, #3840	; 0xf00
		pY[i] |= pTab[j+2] ;
 8005af8:	4415      	add	r5, r2
		pY[i] = ( (uint16_t)( pTab[j+1] ) & 0x000Fu ) << 8  ;
 8005afa:	8074      	strh	r4, [r6, #2]
		pY[i] |= pTab[j+2] ;
 8005afc:	78ad      	ldrb	r5, [r5, #2]
	for( i = 0, j = 0 ; i < no ; ++i, j+=3 ) {
 8005afe:	3001      	adds	r0, #1
		pY[i] |= pTab[j+2] ;
 8005b00:	432c      	orrs	r4, r5
 8005b02:	f826 4f02 	strh.w	r4, [r6, #2]!
	for( i = 0, j = 0 ; i < no ; ++i, j+=3 ) {
 8005b06:	b280      	uxth	r0, r0
 8005b08:	e7de      	b.n	8005ac8 <TS_convertXY+0xc>

08005b0a <TS_match_input>:
TS_mouseInputTypeDef TS_match_input( uint16_t DeviceAddr, uint8_t *t_smpl, uint16_t *pX, uint16_t *pY ) {
 8005b0a:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8005b0e:	4681      	mov	r9, r0
 8005b10:	460d      	mov	r5, r1
 8005b12:	4690      	mov	r8, r2
 8005b14:	461f      	mov	r7, r3
	fifo_size = TS_getFIFO_size( DeviceAddr ) ;
 8005b16:	f7ff ff8e 	bl	8005a36 <TS_getFIFO_size>
	if ( fifo_size > 0 ) {
 8005b1a:	b378      	cbz	r0, 8005b7c <TS_match_input+0x72>
 8005b1c:	280c      	cmp	r0, #12
 8005b1e:	bf28      	it	cs
 8005b20:	200c      	movcs	r0, #12
 8005b22:	b2c4      	uxtb	r4, r0
		TS_readFIFO( DeviceAddr, fifo_size*3, &t_smpl[0] ) ;
 8005b24:	b2a6      	uxth	r6, r4
 8005b26:	462a      	mov	r2, r5
 8005b28:	eb06 0146 	add.w	r1, r6, r6, lsl #1
 8005b2c:	4648      	mov	r0, r9
 8005b2e:	f7ff ff86 	bl	8005a3e <TS_readFIFO>
		TS_convertXY( DeviceAddr, fifo_size, &t_smpl[0], &pX[0], &pY[0] ) ;
 8005b32:	4643      	mov	r3, r8
 8005b34:	462a      	mov	r2, r5
 8005b36:	4631      	mov	r1, r6
 8005b38:	4648      	mov	r0, r9
 8005b3a:	9700      	str	r7, [sp, #0]
 8005b3c:	f7ff ffbe 	bl	8005abc <TS_convertXY>
		t_smpl[0] = t_smpl[1]  = 0 ;	// Y up counter and Y down counter
 8005b40:	2100      	movs	r1, #0
 8005b42:	7069      	strb	r1, [r5, #1]
 8005b44:	7029      	strb	r1, [r5, #0]
		yavg = 0 ; 	// Y average
 8005b46:	460b      	mov	r3, r1
		xavg = 0 ;	// X average
 8005b48:	460a      	mov	r2, r1
		for ( i = 0 ; i < fifo_size - 1 ; ++i ) {
 8005b4a:	1e60      	subs	r0, r4, #1
 8005b4c:	b2ce      	uxtb	r6, r1
 8005b4e:	4286      	cmp	r6, r0
 8005b50:	db16      	blt.n	8005b80 <TS_match_input+0x76>
		xavg /= fifo_size - 1 ;
 8005b52:	fb92 f2f0 	sdiv	r2, r2, r0
		if ( (xavg < 2496) &&
 8005b56:	f46f 61c8 	mvn.w	r1, #1600	; 0x640
		xavg /= fifo_size - 1 ;
 8005b5a:	b292      	uxth	r2, r2
		if ( (xavg < 2496) &&
 8005b5c:	1851      	adds	r1, r2, r1
 8005b5e:	b289      	uxth	r1, r1
 8005b60:	f240 367e 	movw	r6, #894	; 0x37e
 8005b64:	42b1      	cmp	r1, r6
 8005b66:	d82f      	bhi.n	8005bc8 <TS_match_input+0xbe>
			if( t_smpl[0] >= t_smpl[1]+t_smpl[3] ) {
 8005b68:	786a      	ldrb	r2, [r5, #1]
 8005b6a:	782b      	ldrb	r3, [r5, #0]
			t_smpl[3] = fifo_size/4;
 8005b6c:	08a4      	lsrs	r4, r4, #2
			if( t_smpl[0] >= t_smpl[1]+t_smpl[3] ) {
 8005b6e:	1911      	adds	r1, r2, r4
 8005b70:	428b      	cmp	r3, r1
			t_smpl[3] = fifo_size/4;
 8005b72:	70ec      	strb	r4, [r5, #3]
			if( t_smpl[0] >= t_smpl[1]+t_smpl[3] ) {
 8005b74:	da41      	bge.n	8005bfa <TS_match_input+0xf0>
			else if ( t_smpl[1] >= t_smpl[0]+t_smpl[3] ) {
 8005b76:	441c      	add	r4, r3
 8005b78:	42a2      	cmp	r2, r4
 8005b7a:	da40      	bge.n	8005bfe <TS_match_input+0xf4>
	return TS_MOUSE_NONE ;
 8005b7c:	2000      	movs	r0, #0
 8005b7e:	e02f      	b.n	8005be0 <TS_match_input+0xd6>
				change = pY[i] - pY[i+1] ;
 8005b80:	eb07 0c46 	add.w	ip, r7, r6, lsl #1
 8005b84:	f837 e016 	ldrh.w	lr, [r7, r6, lsl #1]
 8005b88:	f8bc c002 	ldrh.w	ip, [ip, #2]
 8005b8c:	ebae 0e0c 	sub.w	lr, lr, ip
				if ( change <= 0 ) {
 8005b90:	fa0f fe8e 	sxth.w	lr, lr
 8005b94:	f1be 0f00 	cmp.w	lr, #0
					++t_smpl[0] ;		// Count Up direction
 8005b98:	bfd5      	itete	le
 8005b9a:	f895 e000 	ldrble.w	lr, [r5]
					++t_smpl[1] ;		// Count Down direction
 8005b9e:	f895 e001 	ldrbgt.w	lr, [r5, #1]
					++t_smpl[0] ;		// Count Up direction
 8005ba2:	f10e 0e01 	addle.w	lr, lr, #1
					++t_smpl[1] ;		// Count Down direction
 8005ba6:	f10e 0e01 	addgt.w	lr, lr, #1
					++t_smpl[0] ;		// Count Up direction
 8005baa:	bfd4      	ite	le
 8005bac:	f885 e000 	strble.w	lr, [r5]
					++t_smpl[1] ;		// Count Down direction
 8005bb0:	f885 e001 	strbgt.w	lr, [r5, #1]
				xavg += pX[i] ;
 8005bb4:	f838 e016 	ldrh.w	lr, [r8, r6, lsl #1]
				yavg += pY[i] ;
 8005bb8:	f837 6016 	ldrh.w	r6, [r7, r6, lsl #1]
				xavg += pX[i] ;
 8005bbc:	4472      	add	r2, lr
				yavg += pY[i] ;
 8005bbe:	4433      	add	r3, r6
				xavg += pX[i] ;
 8005bc0:	b292      	uxth	r2, r2
				yavg += pY[i] ;
 8005bc2:	b29b      	uxth	r3, r3
 8005bc4:	3101      	adds	r1, #1
 8005bc6:	e7c1      	b.n	8005b4c <TS_match_input+0x42>
		yavg /= fifo_size - 1 ;
 8005bc8:	fb93 f0f0 	sdiv	r0, r3, r0
		else if ( (xavg < TS_EDGE_LEFT_BUTTON_X-5) && 
 8005bcc:	f240 633a 	movw	r3, #1594	; 0x63a
 8005bd0:	429a      	cmp	r2, r3
 8005bd2:	d808      	bhi.n	8005be6 <TS_match_input+0xdc>
				return TS_MOUSE_SLIDER_UP ;
 8005bd4:	f640 139a 	movw	r3, #2458	; 0x99a
 8005bd8:	4298      	cmp	r0, r3
 8005bda:	bfd4      	ite	le
 8005bdc:	2000      	movle	r0, #0
 8005bde:	2001      	movgt	r0, #1
}
 8005be0:	b003      	add	sp, #12
 8005be2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		else if ( (xavg > TS_EDGE_RIGHT_BUTTON_X+5) && 
 8005be6:	f640 13c5 	movw	r3, #2501	; 0x9c5
 8005bea:	429a      	cmp	r2, r3
 8005bec:	d9c6      	bls.n	8005b7c <TS_match_input+0x72>
 8005bee:	f640 139a 	movw	r3, #2458	; 0x99a
 8005bf2:	4298      	cmp	r0, r3
 8005bf4:	ddc2      	ble.n	8005b7c <TS_match_input+0x72>
				return TS_MOUSE_RIGHT ;
 8005bf6:	2002      	movs	r0, #2
 8005bf8:	e7f2      	b.n	8005be0 <TS_match_input+0xd6>
				return TS_MOUSE_SLIDER_UP ;
 8005bfa:	2003      	movs	r0, #3
 8005bfc:	e7f0      	b.n	8005be0 <TS_match_input+0xd6>
				return TS_MOUSE_SLIDER_DOWN ;
 8005bfe:	2004      	movs	r0, #4
 8005c00:	e7ee      	b.n	8005be0 <TS_match_input+0xd6>

08005c02 <TS_isHoldDownButton>:
uint8_t TS_isHoldDownButton( uint16_t DeviceAddr, uint8_t *t_smpl, uint16_t *pX, uint16_t *pY ) {
 8005c02:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8005c06:	4607      	mov	r7, r0
 8005c08:	4688      	mov	r8, r1
 8005c0a:	4614      	mov	r4, r2
 8005c0c:	461e      	mov	r6, r3
	fifo_size = TS_getFIFO_size( DeviceAddr ) ;
 8005c0e:	f7ff ff12 	bl	8005a36 <TS_getFIFO_size>
	if ( fifo_size > 0 ) {
 8005c12:	b918      	cbnz	r0, 8005c1c <TS_isHoldDownButton+0x1a>
	return 0 ;
 8005c14:	2000      	movs	r0, #0
}
 8005c16:	b002      	add	sp, #8
 8005c18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		TS_readFIFO( DeviceAddr, fifo_size*3, &t_smpl[0] ) ;
 8005c1c:	2805      	cmp	r0, #5
 8005c1e:	bf28      	it	cs
 8005c20:	2005      	movcs	r0, #5
 8005c22:	b2c5      	uxtb	r5, r0
 8005c24:	4642      	mov	r2, r8
 8005c26:	eb05 0145 	add.w	r1, r5, r5, lsl #1
 8005c2a:	4638      	mov	r0, r7
 8005c2c:	f7ff ff07 	bl	8005a3e <TS_readFIFO>
		stmpe811_ClearGlobalIT( DeviceAddr, STMPE811_GIT_TOUCH | STMPE811_GIT_FTH | STMPE811_GIT_FOV ) ;
 8005c30:	2107      	movs	r1, #7
 8005c32:	4638      	mov	r0, r7
 8005c34:	f7ff fe75 	bl	8005922 <stmpe811_ClearGlobalIT>
		TS_convertXY( DeviceAddr, fifo_size, &t_smpl[0], &pX[0], &pY[0] ) ;
 8005c38:	4623      	mov	r3, r4
 8005c3a:	4642      	mov	r2, r8
 8005c3c:	4629      	mov	r1, r5
 8005c3e:	4638      	mov	r0, r7
 8005c40:	9600      	str	r6, [sp, #0]
 8005c42:	f7ff ff3b 	bl	8005abc <TS_convertXY>
		xavg = pX[0] ;
 8005c46:	8821      	ldrh	r1, [r4, #0]
		yavg = pY[0] ;
 8005c48:	8830      	ldrh	r0, [r6, #0]
 8005c4a:	4622      	mov	r2, r4
 8005c4c:	f104 0308 	add.w	r3, r4, #8
			xavg += pX[i] ;
 8005c50:	f832 4f02 	ldrh.w	r4, [r2, #2]!
 8005c54:	4421      	add	r1, r4
			yavg += pY[i] ;
 8005c56:	f836 4f02 	ldrh.w	r4, [r6, #2]!
		for( i = 1 ; i < avg_smpl ; ++i ) {
 8005c5a:	4293      	cmp	r3, r2
			yavg += pY[i] ;
 8005c5c:	4420      	add	r0, r4
			xavg += pX[i] ;
 8005c5e:	b289      	uxth	r1, r1
			yavg += pY[i] ;
 8005c60:	b280      	uxth	r0, r0
		for( i = 1 ; i < avg_smpl ; ++i ) {
 8005c62:	d1f5      	bne.n	8005c50 <TS_isHoldDownButton+0x4e>
		xavg /= avg_smpl ;
 8005c64:	2305      	movs	r3, #5
 8005c66:	fb91 f1f3 	sdiv	r1, r1, r3
		if ( (xavg < TS_EDGE_LEFT_BUTTON_X) && (yavg > TS_EDGE_LEFT_BUTTON_Y) ) {
 8005c6a:	f5b1 6fc8 	cmp.w	r1, #1600	; 0x640
		xavg /= avg_smpl ;
 8005c6e:	b28a      	uxth	r2, r1
		yavg /= avg_smpl ;
 8005c70:	fb90 f0f3 	sdiv	r0, r0, r3
		if ( (xavg < TS_EDGE_LEFT_BUTTON_X) && (yavg > TS_EDGE_LEFT_BUTTON_Y) ) {
 8005c74:	da06      	bge.n	8005c84 <TS_isHoldDownButton+0x82>
			return 1 ;
 8005c76:	f640 139a 	movw	r3, #2458	; 0x99a
 8005c7a:	4298      	cmp	r0, r3
 8005c7c:	bf94      	ite	ls
 8005c7e:	2000      	movls	r0, #0
 8005c80:	2001      	movhi	r0, #1
 8005c82:	e7c8      	b.n	8005c16 <TS_isHoldDownButton+0x14>
		else if ( (xavg > TS_EDGE_RIGHT_BUTTON_X) && (yavg > TS_EDGE_RIGHT_BUTTON_Y) ) {
 8005c84:	f5b2 6f1c 	cmp.w	r2, #2496	; 0x9c0
 8005c88:	d8f5      	bhi.n	8005c76 <TS_isHoldDownButton+0x74>
 8005c8a:	e7c3      	b.n	8005c14 <TS_isHoldDownButton+0x12>

08005c8c <TS_checkEvent>:
	if ( ts_buttons_delay > TS_CHECKING_PERIOD ) {
 8005c8c:	4b34      	ldr	r3, [pc, #208]	; (8005d60 <TS_checkEvent+0xd4>)
 8005c8e:	681a      	ldr	r2, [r3, #0]
 8005c90:	2a14      	cmp	r2, #20
void TS_checkEvent( uint16_t DeviceAddr ) {
 8005c92:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005c96:	4605      	mov	r5, r0
	if ( ts_buttons_delay > TS_CHECKING_PERIOD ) {
 8005c98:	dd60      	ble.n	8005d5c <TS_checkEvent+0xd0>
	return mouse_current_state ;
 8005c9a:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 8005d80 <TS_checkEvent+0xf4>
		ts_buttons_delay = 0 ;
 8005c9e:	2400      	movs	r4, #0
 8005ca0:	601c      	str	r4, [r3, #0]
	return mouse_current_state ;
 8005ca2:	f898 3000 	ldrb.w	r3, [r8]
		if ( (state == TS_MOUSE_LEFT) || 
 8005ca6:	1e5a      	subs	r2, r3, #1
 8005ca8:	2a01      	cmp	r2, #1
 8005caa:	d816      	bhi.n	8005cda <TS_checkEvent+0x4e>
							0 == TS_isHoldDownButton( DeviceAddr, &fifo_values[0], &pX[0], &pY[0] )
 8005cac:	4a2d      	ldr	r2, [pc, #180]	; (8005d64 <TS_checkEvent+0xd8>)
 8005cae:	4b2e      	ldr	r3, [pc, #184]	; (8005d68 <TS_checkEvent+0xdc>)
 8005cb0:	492e      	ldr	r1, [pc, #184]	; (8005d6c <TS_checkEvent+0xe0>)
 8005cb2:	f7ff ffa6 	bl	8005c02 <TS_isHoldDownButton>
 8005cb6:	4a2e      	ldr	r2, [pc, #184]	; (8005d70 <TS_checkEvent+0xe4>)
					if ( 
 8005cb8:	b960      	cbnz	r0, 8005cd4 <TS_checkEvent+0x48>
						++button_hold_cnt;
 8005cba:	7813      	ldrb	r3, [r2, #0]
 8005cbc:	3301      	adds	r3, #1
 8005cbe:	b2db      	uxtb	r3, r3
						if ( button_hold_cnt >= 3 ) {
 8005cc0:	2b02      	cmp	r3, #2
 8005cc2:	d802      	bhi.n	8005cca <TS_checkEvent+0x3e>
						++button_hold_cnt;
 8005cc4:	7013      	strb	r3, [r2, #0]
 8005cc6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
							button_hold_cnt = 0 ;
 8005cca:	7010      	strb	r0, [r2, #0]
}
 8005ccc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
							TS_setCurrMouseState( TS_MOUSE_NONE );
 8005cd0:	f7ff becc 	b.w	8005a6c <TS_setCurrMouseState>
						button_hold_cnt = 0 ;
 8005cd4:	7014      	strb	r4, [r2, #0]
 8005cd6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		else if ( ts_slider_hop_time > 0 ) {
 8005cda:	4f26      	ldr	r7, [pc, #152]	; (8005d74 <TS_checkEvent+0xe8>)
 8005cdc:	683a      	ldr	r2, [r7, #0]
 8005cde:	2a00      	cmp	r2, #0
 8005ce0:	dd07      	ble.n	8005cf2 <TS_checkEvent+0x66>
			if ( ts_slider_hop_time > TS_SLIDER_HOP_TIME ) {
 8005ce2:	683b      	ldr	r3, [r7, #0]
 8005ce4:	2b0f      	cmp	r3, #15
 8005ce6:	dd39      	ble.n	8005d5c <TS_checkEvent+0xd0>
				ts_slider_hop_time = 0 ;
 8005ce8:	603c      	str	r4, [r7, #0]
				TS_flushFIFO( DeviceAddr ) ;
 8005cea:	f7ff feb0 	bl	8005a4e <TS_flushFIFO>
				stmpe811_ClearGlobalIT( DeviceAddr, status ) ;
 8005cee:	4621      	mov	r1, r4
 8005cf0:	e024      	b.n	8005d3c <TS_checkEvent+0xb0>
		else if ( ts_int_catched == 1 ) {
 8005cf2:	4a21      	ldr	r2, [pc, #132]	; (8005d78 <TS_checkEvent+0xec>)
 8005cf4:	f8d2 9000 	ldr.w	r9, [r2]
 8005cf8:	f1b9 0f01 	cmp.w	r9, #1
 8005cfc:	d123      	bne.n	8005d46 <TS_checkEvent+0xba>
			ts_int_catched = 0 ;
 8005cfe:	6014      	str	r4, [r2, #0]
			status = stmpe811_TS_ITStatus( DeviceAddr ) ;
 8005d00:	f7ff fe0c 	bl	800591c <stmpe811_TS_ITStatus>
			if ( (status & STMPE811_GIT_FTH) || (status & STMPE811_GIT_TOUCH) ) {
 8005d04:	0783      	lsls	r3, r0, #30
			status &= ( STMPE811_GIT_TOUCH | STMPE811_GIT_FTH | STMPE811_GIT_FOV ) ;
 8005d06:	f000 0a07 	and.w	sl, r0, #7
			if ( (status & STMPE811_GIT_FTH) || (status & STMPE811_GIT_TOUCH) ) {
 8005d0a:	d013      	beq.n	8005d34 <TS_checkEvent+0xa8>
				state = TS_match_input(DeviceAddr, &fifo_values[0], &pX[0], &pY[0]) ;
 8005d0c:	4b16      	ldr	r3, [pc, #88]	; (8005d68 <TS_checkEvent+0xdc>)
 8005d0e:	4a15      	ldr	r2, [pc, #84]	; (8005d64 <TS_checkEvent+0xd8>)
 8005d10:	4916      	ldr	r1, [pc, #88]	; (8005d6c <TS_checkEvent+0xe0>)
 8005d12:	4628      	mov	r0, r5
 8005d14:	f7ff fef9 	bl	8005b0a <TS_match_input>
				if ( state != TS_MOUSE_NONE ) {
 8005d18:	4606      	mov	r6, r0
 8005d1a:	b158      	cbz	r0, 8005d34 <TS_checkEvent+0xa8>
					if ( (state == TS_MOUSE_LEFT) || (state == TS_MOUSE_RIGHT) ) {
 8005d1c:	3e01      	subs	r6, #1
 8005d1e:	b2f6      	uxtb	r6, r6
					TS_setCurrMouseState( state ) ;
 8005d20:	f7ff fea4 	bl	8005a6c <TS_setCurrMouseState>
					if ( (state == TS_MOUSE_LEFT) || (state == TS_MOUSE_RIGHT) ) {
 8005d24:	2e01      	cmp	r6, #1
						ts_mouse_last_signal_delay = 0 ;	// reset delay timer for that state
 8005d26:	bf95      	itete	ls
 8005d28:	4b14      	ldrls	r3, [pc, #80]	; (8005d7c <TS_checkEvent+0xf0>)
						ts_slider_hop_time = 1 ;					// start counting
 8005d2a:	f8c7 9000 	strhi.w	r9, [r7]
						ts_mouse_last_signal_delay = 0 ;	// reset delay timer for that state
 8005d2e:	601c      	strls	r4, [r3, #0]
	mouse_current_state = _state_ ;
 8005d30:	f888 4000 	strbhi.w	r4, [r8]
			TS_flushFIFO( DeviceAddr ) ;
 8005d34:	4628      	mov	r0, r5
 8005d36:	f7ff fe8a 	bl	8005a4e <TS_flushFIFO>
			stmpe811_ClearGlobalIT( DeviceAddr, status ) ;
 8005d3a:	4651      	mov	r1, sl
				stmpe811_ClearGlobalIT( DeviceAddr, status ) ;
 8005d3c:	4628      	mov	r0, r5
}
 8005d3e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
				stmpe811_ClearGlobalIT( DeviceAddr, status ) ;
 8005d42:	f7ff bdee 	b.w	8005922 <stmpe811_ClearGlobalIT>
			if ( (TS_getCurrMouseState() != TS_MOUSE_NONE) &&
 8005d46:	b14b      	cbz	r3, 8005d5c <TS_checkEvent+0xd0>
					 (ts_mouse_last_signal_delay > 80 )
 8005d48:	4e0c      	ldr	r6, [pc, #48]	; (8005d7c <TS_checkEvent+0xf0>)
 8005d4a:	6833      	ldr	r3, [r6, #0]
			if ( (TS_getCurrMouseState() != TS_MOUSE_NONE) &&
 8005d4c:	2b50      	cmp	r3, #80	; 0x50
 8005d4e:	dd05      	ble.n	8005d5c <TS_checkEvent+0xd0>
				TS_setCurrMouseState( TS_MOUSE_NONE ) ;
 8005d50:	4620      	mov	r0, r4
 8005d52:	f7ff fe8b 	bl	8005a6c <TS_setCurrMouseState>
				ts_mouse_last_signal_delay = 0 ;
 8005d56:	6034      	str	r4, [r6, #0]
				TS_flushFIFO( DeviceAddr ) ;
 8005d58:	4628      	mov	r0, r5
 8005d5a:	e7c6      	b.n	8005cea <TS_checkEvent+0x5e>
 8005d5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005d60:	20000528 	.word	0x20000528
 8005d64:	200004e8 	.word	0x200004e8
 8005d68:	20000500 	.word	0x20000500
 8005d6c:	200004c3 	.word	0x200004c3
 8005d70:	200004c2 	.word	0x200004c2
 8005d74:	20000534 	.word	0x20000534
 8005d78:	2000052c 	.word	0x2000052c
 8005d7c:	20000530 	.word	0x20000530
 8005d80:	200004e7 	.word	0x200004e7

08005d84 <usb_handleMouseNotify>:
volatile uint8_t unclick = 0;		// detect mouse unclick


void usb_handleMouseNotify( TS_mouseInputTypeDef _state_, const Point * const _inData_ ) {
	
	switch( _state_ ) {
 8005d84:	3801      	subs	r0, #1
 8005d86:	4b0c      	ldr	r3, [pc, #48]	; (8005db8 <usb_handleMouseNotify+0x34>)
 8005d88:	2803      	cmp	r0, #3
 8005d8a:	d80e      	bhi.n	8005daa <usb_handleMouseNotify+0x26>
 8005d8c:	e8df f000 	tbb	[pc, r0]
 8005d90:	0b090702 	.word	0x0b090702
		case TS_MOUSE_LEFT: 
				HID_Buffer[0] = 0x01 ;
 8005d94:	2201      	movs	r2, #1
				HID_Buffer[3] = 0x00 ; // slider off
				break ;
		case TS_MOUSE_RIGHT: 
				HID_Buffer[0] = 0x02 ;
 8005d96:	701a      	strb	r2, [r3, #0]
				HID_Buffer[3] = 0x00 ;
 8005d98:	2200      	movs	r2, #0
				break ;
		case TS_MOUSE_SLIDER_UP: 
				HID_Buffer[3] = 0x01;
				break ;
		case TS_MOUSE_SLIDER_DOWN:
				HID_Buffer[3] = 0xFF ;
 8005d9a:	70da      	strb	r2, [r3, #3]
				break ;
 8005d9c:	4770      	bx	lr
				HID_Buffer[0] = 0x02 ;
 8005d9e:	2202      	movs	r2, #2
 8005da0:	e7f9      	b.n	8005d96 <usb_handleMouseNotify+0x12>
				HID_Buffer[3] = 0x01;
 8005da2:	2201      	movs	r2, #1
 8005da4:	e7f9      	b.n	8005d9a <usb_handleMouseNotify+0x16>
				HID_Buffer[3] = 0xFF ;
 8005da6:	22ff      	movs	r2, #255	; 0xff
 8005da8:	e7f7      	b.n	8005d9a <usb_handleMouseNotify+0x16>
		default: 
				HID_Buffer[0] = 0x00 ;
 8005daa:	2200      	movs	r2, #0
 8005dac:	701a      	strb	r2, [r3, #0]
				HID_Buffer[3] = 0x00 ;
 8005dae:	70da      	strb	r2, [r3, #3]
				unclick = 1;
 8005db0:	4b02      	ldr	r3, [pc, #8]	; (8005dbc <usb_handleMouseNotify+0x38>)
 8005db2:	2201      	movs	r2, #1
 8005db4:	701a      	strb	r2, [r3, #0]
 8005db6:	4770      	bx	lr
 8005db8:	2000054c 	.word	0x2000054c
 8005dbc:	20000550 	.word	0x20000550

08005dc0 <GetGyroData>:
/**
  * @brief  Gets Gyro Data.
	* @param  pbuf_x: Pointer to axis data 
  * @retval None
  */
void GetGyroData( void ) {
 8005dc0:	b510      	push	{r4, lr}
	
	BSP_GYRO_GetXYZ(xyz_buff);
 8005dc2:	4c1b      	ldr	r4, [pc, #108]	; (8005e30 <GetGyroData+0x70>)
 8005dc4:	4620      	mov	r0, r4
 8005dc6:	f7fe fedf 	bl	8004b88 <BSP_GYRO_GetXYZ>
	
	if (xyz_buff[0] < -GYRO_SENSITIVITY)
 8005dca:	edd4 6a00 	vldr	s13, [r4]
 8005dce:	eddf 7a19 	vldr	s15, [pc, #100]	; 8005e34 <GetGyroData+0x74>
 8005dd2:	4b19      	ldr	r3, [pc, #100]	; (8005e38 <GetGyroData+0x78>)
 8005dd4:	eef4 6ae7 	vcmpe.f32	s13, s15
 8005dd8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		++ (* (pbuf + 3) );
 8005ddc:	bf48      	it	mi
 8005dde:	68da      	ldrmi	r2, [r3, #12]
 8005de0:	eeb0 7a67 	vmov.f32	s14, s15
	else 
		*(pbuf + 3) = 0;
	
	if (xyz_buff[0] > GYRO_SENSITIVITY) 
 8005de4:	eddf 7a15 	vldr	s15, [pc, #84]	; 8005e3c <GetGyroData+0x7c>
		++ (* (pbuf + 3) );
 8005de8:	bf4c      	ite	mi
 8005dea:	3201      	addmi	r2, #1
		*(pbuf + 3) = 0;
 8005dec:	2200      	movpl	r2, #0
	if (xyz_buff[0] > GYRO_SENSITIVITY) 
 8005dee:	eef4 6ae7 	vcmpe.f32	s13, s15
		*(pbuf + 3) = 0;
 8005df2:	60da      	str	r2, [r3, #12]
	if (xyz_buff[0] > GYRO_SENSITIVITY) 
 8005df4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		++( * (pbuf + 2) );
 8005df8:	bfc8      	it	gt
 8005dfa:	689a      	ldrgt	r2, [r3, #8]
	else 
		*(pbuf + 2) = 0;
	
	if (xyz_buff[1] < -GYRO_SENSITIVITY)
 8005dfc:	edd4 6a01 	vldr	s13, [r4, #4]
		++( * (pbuf + 2) );
 8005e00:	bfcc      	ite	gt
 8005e02:	3201      	addgt	r2, #1
		*(pbuf + 2) = 0;
 8005e04:	2200      	movle	r2, #0
	if (xyz_buff[1] < -GYRO_SENSITIVITY)
 8005e06:	eef4 6ac7 	vcmpe.f32	s13, s14
		*(pbuf + 2) = 0;
 8005e0a:	609a      	str	r2, [r3, #8]
	if (xyz_buff[1] < -GYRO_SENSITIVITY)
 8005e0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		++(*pbuf);
 8005e10:	bf4a      	itet	mi
 8005e12:	681a      	ldrmi	r2, [r3, #0]
	else 
		*pbuf = 0;
 8005e14:	2200      	movpl	r2, #0
		++(*pbuf);
 8005e16:	3201      	addmi	r2, #1
	
	if (xyz_buff[1] > GYRO_SENSITIVITY) 
 8005e18:	eef4 6ae7 	vcmpe.f32	s13, s15
		*pbuf = 0;
 8005e1c:	601a      	str	r2, [r3, #0]
	if (xyz_buff[1] > GYRO_SENSITIVITY) 
 8005e1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		++( * (pbuf + 1) );
 8005e22:	bfca      	itet	gt
 8005e24:	685a      	ldrgt	r2, [r3, #4]
	else
		*(pbuf + 1) = 0;
 8005e26:	2200      	movle	r2, #0
		++( * (pbuf + 1) );
 8005e28:	3201      	addgt	r2, #1
		*(pbuf + 1) = 0;
 8005e2a:	605a      	str	r2, [r3, #4]
 8005e2c:	bd10      	pop	{r4, pc}
 8005e2e:	bf00      	nop
 8005e30:	20000554 	.word	0x20000554
 8005e34:	c61c4000 	.word	0xc61c4000
 8005e38:	2000053c 	.word	0x2000053c
 8005e3c:	461c4000 	.word	0x461c4000

08005e40 <GetPointerData>:
  * @param  pbuf: Pointer to report
  * @retval None
  */
void GetPointerData( void ) {
  int8_t x = 0, y = 0;
	if (*pbuf >= GYRO_AVG)
 8005e40:	4b0f      	ldr	r3, [pc, #60]	; (8005e80 <GetPointerData+0x40>)
 8005e42:	681a      	ldr	r2, [r3, #0]
		x += CURSOR_STEP;
	if (* (pbuf + 1) >= GYRO_AVG)
 8005e44:	6859      	ldr	r1, [r3, #4]
	if (*pbuf >= GYRO_AVG)
 8005e46:	f5b2 6ffa 	cmp.w	r2, #2000	; 0x7d0
 8005e4a:	bf2c      	ite	cs
 8005e4c:	2201      	movcs	r2, #1
 8005e4e:	2200      	movcc	r2, #0
	if (* (pbuf + 1) >= GYRO_AVG)
 8005e50:	f5b1 6ffa 	cmp.w	r1, #2000	; 0x7d0
 8005e54:	4619      	mov	r1, r3
		x -= CURSOR_STEP;
	if (* (pbuf + 2) >= GYRO_AVG)
 8005e56:	689b      	ldr	r3, [r3, #8]
		y += CURSOR_STEP;
	if (* (pbuf + 3) >= GYRO_AVG)
 8005e58:	68c9      	ldr	r1, [r1, #12]
		x -= CURSOR_STEP;
 8005e5a:	bf28      	it	cs
 8005e5c:	f102 32ff 	addcs.w	r2, r2, #4294967295	; 0xffffffff
	if (* (pbuf + 2) >= GYRO_AVG)
 8005e60:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8005e64:	bf2c      	ite	cs
 8005e66:	2301      	movcs	r3, #1
 8005e68:	2300      	movcc	r3, #0
	if (* (pbuf + 3) >= GYRO_AVG)
 8005e6a:	f5b1 6ffa 	cmp.w	r1, #2000	; 0x7d0
		y -= CURSOR_STEP;
 8005e6e:	bf28      	it	cs
 8005e70:	f103 33ff 	addcs.w	r3, r3, #4294967295	; 0xffffffff
		
	HID_Buffer[1] = x;
 8005e74:	4903      	ldr	r1, [pc, #12]	; (8005e84 <GetPointerData+0x44>)
		x -= CURSOR_STEP;
 8005e76:	b252      	sxtb	r2, r2
		y -= CURSOR_STEP;
 8005e78:	b25b      	sxtb	r3, r3
	HID_Buffer[1] = x;
 8005e7a:	704a      	strb	r2, [r1, #1]
	HID_Buffer[2] = y;
 8005e7c:	708b      	strb	r3, [r1, #2]
 8005e7e:	4770      	bx	lr
 8005e80:	2000053c 	.word	0x2000053c
 8005e84:	2000054c 	.word	0x2000054c

08005e88 <SystemClockConfig_STOP>:
static void SystemClockConfig_STOP(void)
{
  /* Configures system clock after wake-up from STOP: enable HSE, PLL and select 
  PLL as system clock source (HSE and PLL are disabled in STOP mode) */
  
  __HAL_RCC_HSE_CONFIG(RCC_HSE_ON);
 8005e88:	4b0d      	ldr	r3, [pc, #52]	; (8005ec0 <SystemClockConfig_STOP+0x38>)
 8005e8a:	2201      	movs	r2, #1
 8005e8c:	701a      	strb	r2, [r3, #0]
  
  /* Wait till HSE is ready */  
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8005e8e:	3b02      	subs	r3, #2
 8005e90:	461a      	mov	r2, r3
 8005e92:	6819      	ldr	r1, [r3, #0]
 8005e94:	0389      	lsls	r1, r1, #14
 8005e96:	d5fc      	bpl.n	8005e92 <SystemClockConfig_STOP+0xa>
  {}
  
  /* Enable the main PLL. */
  __HAL_RCC_PLL_ENABLE();
 8005e98:	4b0a      	ldr	r3, [pc, #40]	; (8005ec4 <SystemClockConfig_STOP+0x3c>)
 8005e9a:	2101      	movs	r1, #1
 8005e9c:	6019      	str	r1, [r3, #0]
  
  /* Wait till PLL is ready */  
  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8005e9e:	6813      	ldr	r3, [r2, #0]
 8005ea0:	019b      	lsls	r3, r3, #6
 8005ea2:	d5fc      	bpl.n	8005e9e <SystemClockConfig_STOP+0x16>
  {}
  
  /* Select PLL as SYSCLK */
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_SYSCLKSOURCE_PLLCLK);
 8005ea4:	6893      	ldr	r3, [r2, #8]
 8005ea6:	f023 0303 	bic.w	r3, r3, #3
 8005eaa:	f043 0302 	orr.w	r3, r3, #2
 8005eae:	6093      	str	r3, [r2, #8]
  
  /* Wait till system clock switch to PLL */
  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8005eb0:	4a05      	ldr	r2, [pc, #20]	; (8005ec8 <SystemClockConfig_STOP+0x40>)
 8005eb2:	6893      	ldr	r3, [r2, #8]
 8005eb4:	f003 030c 	and.w	r3, r3, #12
 8005eb8:	2b08      	cmp	r3, #8
 8005eba:	d1fa      	bne.n	8005eb2 <SystemClockConfig_STOP+0x2a>
  {}
}
 8005ebc:	4770      	bx	lr
 8005ebe:	bf00      	nop
 8005ec0:	40023802 	.word	0x40023802
 8005ec4:	42470060 	.word	0x42470060
 8005ec8:	40023800 	.word	0x40023800

08005ecc <HAL_PCD_MspInit>:
{
 8005ecc:	b570      	push	{r4, r5, r6, lr}
  __GPIOB_CLK_ENABLE();
 8005ece:	4d16      	ldr	r5, [pc, #88]	; (8005f28 <HAL_PCD_MspInit+0x5c>)
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005ed0:	4e16      	ldr	r6, [pc, #88]	; (8005f2c <HAL_PCD_MspInit+0x60>)
  __GPIOB_CLK_ENABLE();
 8005ed2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
{
 8005ed4:	b086      	sub	sp, #24
  __GPIOB_CLK_ENABLE();
 8005ed6:	f043 0302 	orr.w	r3, r3, #2
 8005eda:	632b      	str	r3, [r5, #48]	; 0x30
  GPIO_InitStruct.Pin = GPIO_PIN_12 | GPIO_PIN_14 |GPIO_PIN_15;
 8005edc:	f44f 4350 	mov.w	r3, #53248	; 0xd000
 8005ee0:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005ee2:	2302      	movs	r3, #2
 8005ee4:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8005ee6:	2303      	movs	r3, #3
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005ee8:	2400      	movs	r4, #0
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8005eea:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005eec:	a901      	add	r1, sp, #4
  GPIO_InitStruct.Alternate = GPIO_AF12_OTG_HS_FS;
 8005eee:	230c      	movs	r3, #12
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005ef0:	4630      	mov	r0, r6
  GPIO_InitStruct.Alternate = GPIO_AF12_OTG_HS_FS;
 8005ef2:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005ef4:	9403      	str	r4, [sp, #12]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005ef6:	f7fa fdad 	bl	8000a54 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_13 ;
 8005efa:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005efe:	a901      	add	r1, sp, #4
 8005f00:	4630      	mov	r0, r6
  GPIO_InitStruct.Pin = GPIO_PIN_13 ;
 8005f02:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8005f04:	9402      	str	r4, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005f06:	9403      	str	r4, [sp, #12]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005f08:	f7fa fda4 	bl	8000a54 <HAL_GPIO_Init>
  __USB_OTG_HS_CLK_ENABLE();
 8005f0c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8005f0e:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8005f12:	632b      	str	r3, [r5, #48]	; 0x30
  HAL_NVIC_SetPriority(OTG_HS_IRQn, 5, 0);
 8005f14:	4622      	mov	r2, r4
 8005f16:	2105      	movs	r1, #5
 8005f18:	204d      	movs	r0, #77	; 0x4d
 8005f1a:	f7fa f9e9 	bl	80002f0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
 8005f1e:	204d      	movs	r0, #77	; 0x4d
 8005f20:	f7fa fa1a 	bl	8000358 <HAL_NVIC_EnableIRQ>
}
 8005f24:	b006      	add	sp, #24
 8005f26:	bd70      	pop	{r4, r5, r6, pc}
 8005f28:	40023800 	.word	0x40023800
 8005f2c:	40020400 	.word	0x40020400

08005f30 <HAL_PCD_SetupStageCallback>:
  USBD_LL_SetupStage(hpcd->pData, (uint8_t *)hpcd->Setup);
 8005f30:	f500 715f 	add.w	r1, r0, #892	; 0x37c
 8005f34:	f8d0 03ac 	ldr.w	r0, [r0, #940]	; 0x3ac
 8005f38:	f7fd bc1f 	b.w	800377a <USBD_LL_SetupStage>

08005f3c <HAL_PCD_DataOutStageCallback>:
  USBD_LL_DataOutStage(hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8005f3c:	231c      	movs	r3, #28
 8005f3e:	fb03 0301 	mla	r3, r3, r1, r0
 8005f42:	f8d0 03ac 	ldr.w	r0, [r0, #940]	; 0x3ac
 8005f46:	f8d3 21e0 	ldr.w	r2, [r3, #480]	; 0x1e0
 8005f4a:	f7fd bc43 	b.w	80037d4 <USBD_LL_DataOutStage>

08005f4e <HAL_PCD_DataInStageCallback>:
  USBD_LL_DataInStage(hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8005f4e:	231c      	movs	r3, #28
 8005f50:	fb03 0301 	mla	r3, r3, r1, r0
 8005f54:	f8d0 03ac 	ldr.w	r0, [r0, #940]	; 0x3ac
 8005f58:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8005f5a:	f7fd bc6d 	b.w	8003838 <USBD_LL_DataInStage>

08005f5e <HAL_PCD_SOFCallback>:
  USBD_LL_SOF(hpcd->pData);
 8005f5e:	f8d0 03ac 	ldr.w	r0, [r0, #940]	; 0x3ac
 8005f62:	f7fd bce0 	b.w	8003926 <USBD_LL_SOF>

08005f66 <HAL_PCD_ResetCallback>:
{   
 8005f66:	b538      	push	{r3, r4, r5, lr}
  switch(hpcd->Init.speed)
 8005f68:	68c1      	ldr	r1, [r0, #12]
{   
 8005f6a:	4604      	mov	r4, r0
    speed = USBD_SPEED_FULL;
 8005f6c:	1c0d      	adds	r5, r1, #0
 8005f6e:	bf18      	it	ne
 8005f70:	2501      	movne	r5, #1
  USBD_LL_Reset(hpcd->pData);
 8005f72:	f8d0 03ac 	ldr.w	r0, [r0, #940]	; 0x3ac
 8005f76:	f7fd fca5 	bl	80038c4 <USBD_LL_Reset>
  USBD_LL_SetSpeed(hpcd->pData, speed);
 8005f7a:	4629      	mov	r1, r5
 8005f7c:	f8d4 03ac 	ldr.w	r0, [r4, #940]	; 0x3ac
}
 8005f80:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  USBD_LL_SetSpeed(hpcd->pData, speed);
 8005f84:	f7fd bcbd 	b.w	8003902 <USBD_LL_SetSpeed>

08005f88 <HAL_PCD_SuspendCallback>:
    __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8005f88:	6802      	ldr	r2, [r0, #0]
 8005f8a:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
{
 8005f8e:	b510      	push	{r4, lr}
    __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8005f90:	f043 0301 	orr.w	r3, r3, #1
{
 8005f94:	4604      	mov	r4, r0
    __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8005f96:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
    USBD_LL_Suspend(hpcd->pData);
 8005f9a:	f8d0 03ac 	ldr.w	r0, [r0, #940]	; 0x3ac
 8005f9e:	f7fd fcb3 	bl	8003908 <USBD_LL_Suspend>
    if (hpcd->Init.low_power_enable)
 8005fa2:	6a23      	ldr	r3, [r4, #32]
 8005fa4:	b123      	cbz	r3, 8005fb0 <HAL_PCD_SuspendCallback+0x28>
      SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8005fa6:	4a03      	ldr	r2, [pc, #12]	; (8005fb4 <HAL_PCD_SuspendCallback+0x2c>)
 8005fa8:	6913      	ldr	r3, [r2, #16]
 8005faa:	f043 0306 	orr.w	r3, r3, #6
 8005fae:	6113      	str	r3, [r2, #16]
 8005fb0:	bd10      	pop	{r4, pc}
 8005fb2:	bf00      	nop
 8005fb4:	e000ed00 	.word	0xe000ed00

08005fb8 <HAL_PCD_ResumeCallback>:
  if ((hpcd->Init.low_power_enable)&&(remotewakeupon == 0))
 8005fb8:	6a03      	ldr	r3, [r0, #32]
{
 8005fba:	b510      	push	{r4, lr}
 8005fbc:	4c0c      	ldr	r4, [pc, #48]	; (8005ff0 <HAL_PCD_ResumeCallback+0x38>)
  if ((hpcd->Init.low_power_enable)&&(remotewakeupon == 0))
 8005fbe:	b143      	cbz	r3, 8005fd2 <HAL_PCD_ResumeCallback+0x1a>
 8005fc0:	6823      	ldr	r3, [r4, #0]
 8005fc2:	b933      	cbnz	r3, 8005fd2 <HAL_PCD_ResumeCallback+0x1a>
    SystemClockConfig_STOP();
 8005fc4:	f7ff ff60 	bl	8005e88 <SystemClockConfig_STOP>
    SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8005fc8:	4a0a      	ldr	r2, [pc, #40]	; (8005ff4 <HAL_PCD_ResumeCallback+0x3c>)
 8005fca:	6913      	ldr	r3, [r2, #16]
 8005fcc:	f023 0306 	bic.w	r3, r3, #6
 8005fd0:	6113      	str	r3, [r2, #16]
  __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 8005fd2:	6802      	ldr	r2, [r0, #0]
  USBD_LL_Resume(hpcd->pData);
 8005fd4:	f8d0 03ac 	ldr.w	r0, [r0, #940]	; 0x3ac
  __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 8005fd8:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 8005fdc:	f023 0301 	bic.w	r3, r3, #1
 8005fe0:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
  USBD_LL_Resume(hpcd->pData);
 8005fe4:	f7fd fc99 	bl	800391a <USBD_LL_Resume>
  remotewakeupon=0;
 8005fe8:	2300      	movs	r3, #0
 8005fea:	6023      	str	r3, [r4, #0]
 8005fec:	bd10      	pop	{r4, pc}
 8005fee:	bf00      	nop
 8005ff0:	20000560 	.word	0x20000560
 8005ff4:	e000ed00 	.word	0xe000ed00

08005ff8 <HAL_PCD_ISOOUTIncompleteCallback>:
  USBD_LL_IsoOUTIncomplete(hpcd->pData, epnum);
 8005ff8:	f8d0 03ac 	ldr.w	r0, [r0, #940]	; 0x3ac
 8005ffc:	f7fd bca1 	b.w	8003942 <USBD_LL_IsoOUTIncomplete>

08006000 <HAL_PCD_ISOINIncompleteCallback>:
  USBD_LL_IsoINIncomplete(hpcd->pData, epnum);
 8006000:	f8d0 03ac 	ldr.w	r0, [r0, #940]	; 0x3ac
 8006004:	f7fd bc9b 	b.w	800393e <USBD_LL_IsoINIncomplete>

08006008 <HAL_PCD_ConnectCallback>:
  USBD_LL_DevConnected(hpcd->pData);
 8006008:	f8d0 03ac 	ldr.w	r0, [r0, #940]	; 0x3ac
 800600c:	f7fd bc9b 	b.w	8003946 <USBD_LL_DevConnected>

08006010 <HAL_PCD_DisconnectCallback>:
  USBD_LL_DevDisconnected(hpcd->pData);
 8006010:	f8d0 03ac 	ldr.w	r0, [r0, #940]	; 0x3ac
 8006014:	f7fd bc99 	b.w	800394a <USBD_LL_DevDisconnected>

08006018 <USBD_LL_Init>:
{
 8006018:	b570      	push	{r4, r5, r6, lr}
  hpcd.Init.dev_endpoints = 6;
 800601a:	4a15      	ldr	r2, [pc, #84]	; (8006070 <USBD_LL_Init+0x58>)
  hpcd.Instance = USB_OTG_HS;
 800601c:	4c15      	ldr	r4, [pc, #84]	; (8006074 <USBD_LL_Init+0x5c>)
  hpcd.Init.dev_endpoints = 6;
 800601e:	2306      	movs	r3, #6
 8006020:	e884 000c 	stmia.w	r4, {r2, r3}
  hpcd.Init.ep0_mps = 0x40;
 8006024:	2340      	movs	r3, #64	; 0x40
  hpcd.Init.use_dedicated_ep1 = 0;
 8006026:	2500      	movs	r5, #0
  hpcd.Init.dma_enable = 1;
 8006028:	2601      	movs	r6, #1
  hpcd.pData = pdev;
 800602a:	f8c4 03ac 	str.w	r0, [r4, #940]	; 0x3ac
  hpcd.Init.ep0_mps = 0x40;
 800602e:	6163      	str	r3, [r4, #20]
  pdev->pData = &hpcd;
 8006030:	f8c0 4220 	str.w	r4, [r0, #544]	; 0x220
  hpcd.Init.phy_itface = PCD_PHY_EMBEDDED; 
 8006034:	2302      	movs	r3, #2
  HAL_PCD_Init(&hpcd);
 8006036:	4620      	mov	r0, r4
  hpcd.Init.phy_itface = PCD_PHY_EMBEDDED; 
 8006038:	61a3      	str	r3, [r4, #24]
  hpcd.Init.use_dedicated_ep1 = 0;
 800603a:	62a5      	str	r5, [r4, #40]	; 0x28
  hpcd.Init.dma_enable = 1;
 800603c:	6126      	str	r6, [r4, #16]
  hpcd.Init.low_power_enable = 0;
 800603e:	6225      	str	r5, [r4, #32]
  hpcd.Init.Sof_enable = 0;
 8006040:	61e5      	str	r5, [r4, #28]
  hpcd.Init.speed = PCD_SPEED_HIGH;
 8006042:	60e5      	str	r5, [r4, #12]
  hpcd.Init.vbus_sensing_enable = 1;
 8006044:	6266      	str	r6, [r4, #36]	; 0x24
  HAL_PCD_Init(&hpcd);
 8006046:	f7fb fa41 	bl	80014cc <HAL_PCD_Init>
  HAL_PCD_SetRxFiFo(&hpcd, 0x200);
 800604a:	f44f 7100 	mov.w	r1, #512	; 0x200
 800604e:	4620      	mov	r0, r4
 8006050:	f7fb fe18 	bl	8001c84 <HAL_PCDEx_SetRxFiFo>
  HAL_PCD_SetTxFiFo(&hpcd, 0, 0x80);
 8006054:	4629      	mov	r1, r5
 8006056:	2280      	movs	r2, #128	; 0x80
 8006058:	4620      	mov	r0, r4
 800605a:	f7fb fdf2 	bl	8001c42 <HAL_PCDEx_SetTxFiFo>
  HAL_PCD_SetTxFiFo(&hpcd, 1, 0x174);
 800605e:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8006062:	4631      	mov	r1, r6
 8006064:	4620      	mov	r0, r4
 8006066:	f7fb fdec 	bl	8001c42 <HAL_PCDEx_SetTxFiFo>
}
 800606a:	4628      	mov	r0, r5
 800606c:	bd70      	pop	{r4, r5, r6, pc}
 800606e:	bf00      	nop
 8006070:	40040000 	.word	0x40040000
 8006074:	20000878 	.word	0x20000878

08006078 <USBD_LL_Start>:
{
 8006078:	b508      	push	{r3, lr}
  HAL_PCD_Start(pdev->pData);
 800607a:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 800607e:	f7fb fa8d 	bl	800159c <HAL_PCD_Start>
}
 8006082:	2000      	movs	r0, #0
 8006084:	bd08      	pop	{r3, pc}

08006086 <USBD_LL_OpenEP>:
{
 8006086:	b510      	push	{r4, lr}
 8006088:	461c      	mov	r4, r3
  HAL_PCD_EP_Open(pdev->pData,
 800608a:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 800608e:	4613      	mov	r3, r2
 8006090:	4622      	mov	r2, r4
 8006092:	f7fb fcd6 	bl	8001a42 <HAL_PCD_EP_Open>
}
 8006096:	2000      	movs	r0, #0
 8006098:	bd10      	pop	{r4, pc}

0800609a <USBD_LL_CloseEP>:
{
 800609a:	b508      	push	{r3, lr}
  HAL_PCD_EP_Close(pdev->pData, ep_addr);
 800609c:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80060a0:	f7fb fcfd 	bl	8001a9e <HAL_PCD_EP_Close>
}
 80060a4:	2000      	movs	r0, #0
 80060a6:	bd08      	pop	{r3, pc}

080060a8 <USBD_LL_StallEP>:
{
 80060a8:	b508      	push	{r3, lr}
  HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 80060aa:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80060ae:	f7fb fd77 	bl	8001ba0 <HAL_PCD_EP_SetStall>
}
 80060b2:	2000      	movs	r0, #0
 80060b4:	bd08      	pop	{r3, pc}

080060b6 <USBD_LL_ClearStallEP>:
{
 80060b6:	b508      	push	{r3, lr}
  HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 80060b8:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80060bc:	f7fb fd9c 	bl	8001bf8 <HAL_PCD_EP_ClrStall>
}
 80060c0:	2000      	movs	r0, #0
 80060c2:	bd08      	pop	{r3, pc}

080060c4 <USBD_LL_IsStallEP>:
  if((ep_addr & 0x80) == 0x80)
 80060c4:	f011 0f80 	tst.w	r1, #128	; 0x80
  PCD_HandleTypeDef *hpcd = pdev->pData;
 80060c8:	f8d0 3220 	ldr.w	r3, [r0, #544]	; 0x220
 80060cc:	f04f 021c 	mov.w	r2, #28
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 80060d0:	bf1b      	ittet	ne
 80060d2:	f001 017f 	andne.w	r1, r1, #127	; 0x7f
 80060d6:	fb02 3101 	mlane	r1, r2, r1, r3
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 80060da:	fb02 3101 	mlaeq	r1, r2, r1, r3
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 80060de:	f891 0032 	ldrbne.w	r0, [r1, #50]	; 0x32
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 80060e2:	bf08      	it	eq
 80060e4:	f891 01d6 	ldrbeq.w	r0, [r1, #470]	; 0x1d6
}
 80060e8:	4770      	bx	lr

080060ea <USBD_LL_SetUSBAddress>:
{
 80060ea:	b508      	push	{r3, lr}
  HAL_PCD_SetAddress(pdev->pData, dev_addr);
 80060ec:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80060f0:	f7fb fc95 	bl	8001a1e <HAL_PCD_SetAddress>
}
 80060f4:	2000      	movs	r0, #0
 80060f6:	bd08      	pop	{r3, pc}

080060f8 <USBD_LL_Transmit>:
{
 80060f8:	b508      	push	{r3, lr}
  HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 80060fa:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80060fe:	f7fb fd22 	bl	8001b46 <HAL_PCD_EP_Transmit>
}
 8006102:	2000      	movs	r0, #0
 8006104:	bd08      	pop	{r3, pc}

08006106 <USBD_LL_PrepareReceive>:
{
 8006106:	b508      	push	{r3, lr}
  HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8006108:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 800610c:	f7fb fcea 	bl	8001ae4 <HAL_PCD_EP_Receive>
}
 8006110:	2000      	movs	r0, #0
 8006112:	bd08      	pop	{r3, pc}

08006114 <USBD_HID_DeviceDescriptor>:
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_HID_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_DeviceDesc);
 8006114:	2312      	movs	r3, #18
 8006116:	800b      	strh	r3, [r1, #0]
  return (uint8_t*)USBD_DeviceDesc;
}
 8006118:	4800      	ldr	r0, [pc, #0]	; (800611c <USBD_HID_DeviceDescriptor+0x8>)
 800611a:	4770      	bx	lr
 800611c:	2000019c 	.word	0x2000019c

08006120 <USBD_HID_LangIDStrDescriptor>:
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_HID_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_LangIDDesc);  
 8006120:	2304      	movs	r3, #4
 8006122:	800b      	strh	r3, [r1, #0]
  return (uint8_t*)USBD_LangIDDesc;
}
 8006124:	4800      	ldr	r0, [pc, #0]	; (8006128 <USBD_HID_LangIDStrDescriptor+0x8>)
 8006126:	4770      	bx	lr
 8006128:	200001b0 	.word	0x200001b0

0800612c <IntToUnicode>:
  */
static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
{
  uint8_t idx = 0;
  
  for( idx = 0 ; idx < len ; idx ++)
 800612c:	2300      	movs	r3, #0
{
 800612e:	b530      	push	{r4, r5, lr}
      pbuf[2* idx] = (value >> 28) + 'A' - 10; 
    }
    
    value = value << 4;
    
    pbuf[ 2* idx + 1] = 0;
 8006130:	461d      	mov	r5, r3
  for( idx = 0 ; idx < len ; idx ++)
 8006132:	b2dc      	uxtb	r4, r3
 8006134:	42a2      	cmp	r2, r4
 8006136:	d800      	bhi.n	800613a <IntToUnicode+0xe>
  }
}
 8006138:	bd30      	pop	{r4, r5, pc}
    if( ((value >> 28)) < 0xA )
 800613a:	0f04      	lsrs	r4, r0, #28
 800613c:	2c09      	cmp	r4, #9
      pbuf[ 2* idx] = (value >> 28) + '0';
 800613e:	bf94      	ite	ls
 8006140:	3430      	addls	r4, #48	; 0x30
      pbuf[2* idx] = (value >> 28) + 'A' - 10; 
 8006142:	3437      	addhi	r4, #55	; 0x37
 8006144:	f801 4013 	strb.w	r4, [r1, r3, lsl #1]
    pbuf[ 2* idx + 1] = 0;
 8006148:	eb01 0443 	add.w	r4, r1, r3, lsl #1
    value = value << 4;
 800614c:	0100      	lsls	r0, r0, #4
    pbuf[ 2* idx + 1] = 0;
 800614e:	7065      	strb	r5, [r4, #1]
 8006150:	3301      	adds	r3, #1
 8006152:	e7ee      	b.n	8006132 <IntToUnicode+0x6>

08006154 <USBD_HID_SerialStrDescriptor>:
  *length = USB_SIZ_STRING_SERIAL;
 8006154:	231a      	movs	r3, #26
{
 8006156:	b510      	push	{r4, lr}
  *length = USB_SIZ_STRING_SERIAL;
 8006158:	800b      	strh	r3, [r1, #0]
  deviceserial0 = *(uint32_t*)DEVICE_ID1;
 800615a:	4b09      	ldr	r3, [pc, #36]	; (8006180 <USBD_HID_SerialStrDescriptor+0x2c>)
 800615c:	6818      	ldr	r0, [r3, #0]
  deviceserial2 = *(uint32_t*)DEVICE_ID3;
 800615e:	3308      	adds	r3, #8
  deviceserial0 += deviceserial2;
 8006160:	681b      	ldr	r3, [r3, #0]
  if (deviceserial0 != 0)
 8006162:	18c0      	adds	r0, r0, r3
 8006164:	d00a      	beq.n	800617c <USBD_HID_SerialStrDescriptor+0x28>
  deviceserial1 = *(uint32_t*)DEVICE_ID2;
 8006166:	4b07      	ldr	r3, [pc, #28]	; (8006184 <USBD_HID_SerialStrDescriptor+0x30>)
    IntToUnicode (deviceserial0, &USBD_StringSerial[2] ,8);
 8006168:	4907      	ldr	r1, [pc, #28]	; (8006188 <USBD_HID_SerialStrDescriptor+0x34>)
  deviceserial1 = *(uint32_t*)DEVICE_ID2;
 800616a:	681c      	ldr	r4, [r3, #0]
    IntToUnicode (deviceserial0, &USBD_StringSerial[2] ,8);
 800616c:	2208      	movs	r2, #8
 800616e:	f7ff ffdd 	bl	800612c <IntToUnicode>
    IntToUnicode (deviceserial1, &USBD_StringSerial[18] ,4);
 8006172:	2204      	movs	r2, #4
 8006174:	4905      	ldr	r1, [pc, #20]	; (800618c <USBD_HID_SerialStrDescriptor+0x38>)
 8006176:	4620      	mov	r0, r4
 8006178:	f7ff ffd8 	bl	800612c <IntToUnicode>
}
 800617c:	4804      	ldr	r0, [pc, #16]	; (8006190 <USBD_HID_SerialStrDescriptor+0x3c>)
 800617e:	bd10      	pop	{r4, pc}
 8006180:	1fff7a10 	.word	0x1fff7a10
 8006184:	1fff7a14 	.word	0x1fff7a14
 8006188:	200001b6 	.word	0x200001b6
 800618c:	200001c6 	.word	0x200001c6
 8006190:	200001b4 	.word	0x200001b4

08006194 <USBD_HID_ManufacturerStrDescriptor>:
{
 8006194:	b510      	push	{r4, lr}
  USBD_GetString((uint8_t *)(uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8006196:	4c04      	ldr	r4, [pc, #16]	; (80061a8 <USBD_HID_ManufacturerStrDescriptor+0x14>)
 8006198:	4804      	ldr	r0, [pc, #16]	; (80061ac <USBD_HID_ManufacturerStrDescriptor+0x18>)
 800619a:	460a      	mov	r2, r1
 800619c:	4621      	mov	r1, r4
 800619e:	f7fd fd71 	bl	8003c84 <USBD_GetString>
}
 80061a2:	4620      	mov	r0, r4
 80061a4:	bd10      	pop	{r4, pc}
 80061a6:	bf00      	nop
 80061a8:	20000c28 	.word	0x20000c28
 80061ac:	08007f5d 	.word	0x08007f5d

080061b0 <USBD_HID_ProductStrDescriptor>:
{
 80061b0:	460a      	mov	r2, r1
 80061b2:	b508      	push	{r3, lr}
    USBD_GetString((uint8_t *)(uint8_t *)USBD_PRODUCT_HS_STRING, USBD_StrDesc, length);
 80061b4:	4904      	ldr	r1, [pc, #16]	; (80061c8 <USBD_HID_ProductStrDescriptor+0x18>)
  if(speed == 0)
 80061b6:	b920      	cbnz	r0, 80061c2 <USBD_HID_ProductStrDescriptor+0x12>
    USBD_GetString((uint8_t *)(uint8_t *)USBD_PRODUCT_HS_STRING, USBD_StrDesc, length);
 80061b8:	4804      	ldr	r0, [pc, #16]	; (80061cc <USBD_HID_ProductStrDescriptor+0x1c>)
    USBD_GetString((uint8_t *)(uint8_t *)USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);    
 80061ba:	f7fd fd63 	bl	8003c84 <USBD_GetString>
}
 80061be:	4802      	ldr	r0, [pc, #8]	; (80061c8 <USBD_HID_ProductStrDescriptor+0x18>)
 80061c0:	bd08      	pop	{r3, pc}
    USBD_GetString((uint8_t *)(uint8_t *)USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);    
 80061c2:	4803      	ldr	r0, [pc, #12]	; (80061d0 <USBD_HID_ProductStrDescriptor+0x20>)
 80061c4:	e7f9      	b.n	80061ba <USBD_HID_ProductStrDescriptor+0xa>
 80061c6:	bf00      	nop
 80061c8:	20000c28 	.word	0x20000c28
 80061cc:	08007f70 	.word	0x08007f70
 80061d0:	08007f88 	.word	0x08007f88

080061d4 <USBD_HID_ConfigStrDescriptor>:
{
 80061d4:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)(uint8_t *)USBD_CONFIGURATION_HS_STRING, USBD_StrDesc, length);
 80061d6:	4c04      	ldr	r4, [pc, #16]	; (80061e8 <USBD_HID_ConfigStrDescriptor+0x14>)
 80061d8:	4804      	ldr	r0, [pc, #16]	; (80061ec <USBD_HID_ConfigStrDescriptor+0x18>)
 80061da:	460a      	mov	r2, r1
 80061dc:	4621      	mov	r1, r4
 80061de:	f7fd fd51 	bl	8003c84 <USBD_GetString>
}
 80061e2:	4620      	mov	r0, r4
 80061e4:	bd10      	pop	{r4, pc}
 80061e6:	bf00      	nop
 80061e8:	20000c28 	.word	0x20000c28
 80061ec:	08007f44 	.word	0x08007f44

080061f0 <USBD_HID_InterfaceStrDescriptor>:
{
 80061f0:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)(uint8_t *)USBD_INTERFACE_HS_STRING, USBD_StrDesc, length);
 80061f2:	4c04      	ldr	r4, [pc, #16]	; (8006204 <USBD_HID_InterfaceStrDescriptor+0x14>)
 80061f4:	4804      	ldr	r0, [pc, #16]	; (8006208 <USBD_HID_InterfaceStrDescriptor+0x18>)
 80061f6:	460a      	mov	r2, r1
 80061f8:	4621      	mov	r1, r4
 80061fa:	f7fd fd43 	bl	8003c84 <USBD_GetString>
}
 80061fe:	4620      	mov	r0, r4
 8006200:	bd10      	pop	{r4, pc}
 8006202:	bf00      	nop
 8006204:	20000c28 	.word	0x20000c28
 8006208:	08007f4f 	.word	0x08007f4f

0800620c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler: 
  ldr   sp, =_estack       /* set stack pointer */
 800620c:	f8df d034 	ldr.w	sp, [pc, #52]	; 8006244 <LoopFillZerobss+0x14>
 
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8006210:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8006212:	e003      	b.n	800621c <LoopCopyDataInit>

08006214 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8006214:	4b0c      	ldr	r3, [pc, #48]	; (8006248 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8006216:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8006218:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800621a:	3104      	adds	r1, #4

0800621c <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800621c:	480b      	ldr	r0, [pc, #44]	; (800624c <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 800621e:	4b0c      	ldr	r3, [pc, #48]	; (8006250 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8006220:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8006222:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8006224:	d3f6      	bcc.n	8006214 <CopyDataInit>
  ldr  r2, =_sbss
 8006226:	4a0b      	ldr	r2, [pc, #44]	; (8006254 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8006228:	e002      	b.n	8006230 <LoopFillZerobss>

0800622a <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800622a:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800622c:	f842 3b04 	str.w	r3, [r2], #4

08006230 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8006230:	4b09      	ldr	r3, [pc, #36]	; (8006258 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8006232:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8006234:	d3f9      	bcc.n	800622a <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8006236:	f7f9 ffd9 	bl	80001ec <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800623a:	f000 f811 	bl	8006260 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800623e:	f7fe f929 	bl	8004494 <main>
  bx  lr    
 8006242:	4770      	bx	lr
  ldr   sp, =_estack       /* set stack pointer */
 8006244:	20030000 	.word	0x20030000
  ldr  r3, =_sidata
 8006248:	08007fa8 	.word	0x08007fa8
  ldr  r0, =_sdata
 800624c:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8006250:	20000234 	.word	0x20000234
  ldr  r2, =_sbss
 8006254:	20000234 	.word	0x20000234
  ldr  r3, = _ebss
 8006258:	20000d2c 	.word	0x20000d2c

0800625c <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800625c:	e7fe      	b.n	800625c <ADC_IRQHandler>
	...

08006260 <__libc_init_array>:
 8006260:	b570      	push	{r4, r5, r6, lr}
 8006262:	4e0d      	ldr	r6, [pc, #52]	; (8006298 <__libc_init_array+0x38>)
 8006264:	4c0d      	ldr	r4, [pc, #52]	; (800629c <__libc_init_array+0x3c>)
 8006266:	1ba4      	subs	r4, r4, r6
 8006268:	10a4      	asrs	r4, r4, #2
 800626a:	2500      	movs	r5, #0
 800626c:	42a5      	cmp	r5, r4
 800626e:	d109      	bne.n	8006284 <__libc_init_array+0x24>
 8006270:	4e0b      	ldr	r6, [pc, #44]	; (80062a0 <__libc_init_array+0x40>)
 8006272:	4c0c      	ldr	r4, [pc, #48]	; (80062a4 <__libc_init_array+0x44>)
 8006274:	f000 f8f4 	bl	8006460 <_init>
 8006278:	1ba4      	subs	r4, r4, r6
 800627a:	10a4      	asrs	r4, r4, #2
 800627c:	2500      	movs	r5, #0
 800627e:	42a5      	cmp	r5, r4
 8006280:	d105      	bne.n	800628e <__libc_init_array+0x2e>
 8006282:	bd70      	pop	{r4, r5, r6, pc}
 8006284:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8006288:	4798      	blx	r3
 800628a:	3501      	adds	r5, #1
 800628c:	e7ee      	b.n	800626c <__libc_init_array+0xc>
 800628e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8006292:	4798      	blx	r3
 8006294:	3501      	adds	r5, #1
 8006296:	e7f2      	b.n	800627e <__libc_init_array+0x1e>
 8006298:	08007fa0 	.word	0x08007fa0
 800629c:	08007fa0 	.word	0x08007fa0
 80062a0:	08007fa0 	.word	0x08007fa0
 80062a4:	08007fa4 	.word	0x08007fa4

080062a8 <malloc>:
 80062a8:	4b02      	ldr	r3, [pc, #8]	; (80062b4 <malloc+0xc>)
 80062aa:	4601      	mov	r1, r0
 80062ac:	6818      	ldr	r0, [r3, #0]
 80062ae:	f000 b859 	b.w	8006364 <_malloc_r>
 80062b2:	bf00      	nop
 80062b4:	200001d0 	.word	0x200001d0

080062b8 <free>:
 80062b8:	4b02      	ldr	r3, [pc, #8]	; (80062c4 <free+0xc>)
 80062ba:	4601      	mov	r1, r0
 80062bc:	6818      	ldr	r0, [r3, #0]
 80062be:	f000 b803 	b.w	80062c8 <_free_r>
 80062c2:	bf00      	nop
 80062c4:	200001d0 	.word	0x200001d0

080062c8 <_free_r>:
 80062c8:	b538      	push	{r3, r4, r5, lr}
 80062ca:	4605      	mov	r5, r0
 80062cc:	2900      	cmp	r1, #0
 80062ce:	d045      	beq.n	800635c <_free_r+0x94>
 80062d0:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80062d4:	1f0c      	subs	r4, r1, #4
 80062d6:	2b00      	cmp	r3, #0
 80062d8:	bfb8      	it	lt
 80062da:	18e4      	addlt	r4, r4, r3
 80062dc:	f000 f8b0 	bl	8006440 <__malloc_lock>
 80062e0:	4a1f      	ldr	r2, [pc, #124]	; (8006360 <_free_r+0x98>)
 80062e2:	6813      	ldr	r3, [r2, #0]
 80062e4:	4610      	mov	r0, r2
 80062e6:	b933      	cbnz	r3, 80062f6 <_free_r+0x2e>
 80062e8:	6063      	str	r3, [r4, #4]
 80062ea:	6014      	str	r4, [r2, #0]
 80062ec:	4628      	mov	r0, r5
 80062ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80062f2:	f000 b8a6 	b.w	8006442 <__malloc_unlock>
 80062f6:	42a3      	cmp	r3, r4
 80062f8:	d90c      	bls.n	8006314 <_free_r+0x4c>
 80062fa:	6821      	ldr	r1, [r4, #0]
 80062fc:	1862      	adds	r2, r4, r1
 80062fe:	4293      	cmp	r3, r2
 8006300:	bf04      	itt	eq
 8006302:	681a      	ldreq	r2, [r3, #0]
 8006304:	685b      	ldreq	r3, [r3, #4]
 8006306:	6063      	str	r3, [r4, #4]
 8006308:	bf04      	itt	eq
 800630a:	1852      	addeq	r2, r2, r1
 800630c:	6022      	streq	r2, [r4, #0]
 800630e:	6004      	str	r4, [r0, #0]
 8006310:	e7ec      	b.n	80062ec <_free_r+0x24>
 8006312:	4613      	mov	r3, r2
 8006314:	685a      	ldr	r2, [r3, #4]
 8006316:	b10a      	cbz	r2, 800631c <_free_r+0x54>
 8006318:	42a2      	cmp	r2, r4
 800631a:	d9fa      	bls.n	8006312 <_free_r+0x4a>
 800631c:	6819      	ldr	r1, [r3, #0]
 800631e:	1858      	adds	r0, r3, r1
 8006320:	42a0      	cmp	r0, r4
 8006322:	d10b      	bne.n	800633c <_free_r+0x74>
 8006324:	6820      	ldr	r0, [r4, #0]
 8006326:	4401      	add	r1, r0
 8006328:	1858      	adds	r0, r3, r1
 800632a:	4282      	cmp	r2, r0
 800632c:	6019      	str	r1, [r3, #0]
 800632e:	d1dd      	bne.n	80062ec <_free_r+0x24>
 8006330:	6810      	ldr	r0, [r2, #0]
 8006332:	6852      	ldr	r2, [r2, #4]
 8006334:	605a      	str	r2, [r3, #4]
 8006336:	4401      	add	r1, r0
 8006338:	6019      	str	r1, [r3, #0]
 800633a:	e7d7      	b.n	80062ec <_free_r+0x24>
 800633c:	d902      	bls.n	8006344 <_free_r+0x7c>
 800633e:	230c      	movs	r3, #12
 8006340:	602b      	str	r3, [r5, #0]
 8006342:	e7d3      	b.n	80062ec <_free_r+0x24>
 8006344:	6820      	ldr	r0, [r4, #0]
 8006346:	1821      	adds	r1, r4, r0
 8006348:	428a      	cmp	r2, r1
 800634a:	bf04      	itt	eq
 800634c:	6811      	ldreq	r1, [r2, #0]
 800634e:	6852      	ldreq	r2, [r2, #4]
 8006350:	6062      	str	r2, [r4, #4]
 8006352:	bf04      	itt	eq
 8006354:	1809      	addeq	r1, r1, r0
 8006356:	6021      	streq	r1, [r4, #0]
 8006358:	605c      	str	r4, [r3, #4]
 800635a:	e7c7      	b.n	80062ec <_free_r+0x24>
 800635c:	bd38      	pop	{r3, r4, r5, pc}
 800635e:	bf00      	nop
 8006360:	20000564 	.word	0x20000564

08006364 <_malloc_r>:
 8006364:	b570      	push	{r4, r5, r6, lr}
 8006366:	1ccd      	adds	r5, r1, #3
 8006368:	f025 0503 	bic.w	r5, r5, #3
 800636c:	3508      	adds	r5, #8
 800636e:	2d0c      	cmp	r5, #12
 8006370:	bf38      	it	cc
 8006372:	250c      	movcc	r5, #12
 8006374:	2d00      	cmp	r5, #0
 8006376:	4606      	mov	r6, r0
 8006378:	db01      	blt.n	800637e <_malloc_r+0x1a>
 800637a:	42a9      	cmp	r1, r5
 800637c:	d903      	bls.n	8006386 <_malloc_r+0x22>
 800637e:	230c      	movs	r3, #12
 8006380:	6033      	str	r3, [r6, #0]
 8006382:	2000      	movs	r0, #0
 8006384:	bd70      	pop	{r4, r5, r6, pc}
 8006386:	f000 f85b 	bl	8006440 <__malloc_lock>
 800638a:	4a23      	ldr	r2, [pc, #140]	; (8006418 <_malloc_r+0xb4>)
 800638c:	6814      	ldr	r4, [r2, #0]
 800638e:	4621      	mov	r1, r4
 8006390:	b991      	cbnz	r1, 80063b8 <_malloc_r+0x54>
 8006392:	4c22      	ldr	r4, [pc, #136]	; (800641c <_malloc_r+0xb8>)
 8006394:	6823      	ldr	r3, [r4, #0]
 8006396:	b91b      	cbnz	r3, 80063a0 <_malloc_r+0x3c>
 8006398:	4630      	mov	r0, r6
 800639a:	f000 f841 	bl	8006420 <_sbrk_r>
 800639e:	6020      	str	r0, [r4, #0]
 80063a0:	4629      	mov	r1, r5
 80063a2:	4630      	mov	r0, r6
 80063a4:	f000 f83c 	bl	8006420 <_sbrk_r>
 80063a8:	1c43      	adds	r3, r0, #1
 80063aa:	d126      	bne.n	80063fa <_malloc_r+0x96>
 80063ac:	230c      	movs	r3, #12
 80063ae:	6033      	str	r3, [r6, #0]
 80063b0:	4630      	mov	r0, r6
 80063b2:	f000 f846 	bl	8006442 <__malloc_unlock>
 80063b6:	e7e4      	b.n	8006382 <_malloc_r+0x1e>
 80063b8:	680b      	ldr	r3, [r1, #0]
 80063ba:	1b5b      	subs	r3, r3, r5
 80063bc:	d41a      	bmi.n	80063f4 <_malloc_r+0x90>
 80063be:	2b0b      	cmp	r3, #11
 80063c0:	d90f      	bls.n	80063e2 <_malloc_r+0x7e>
 80063c2:	600b      	str	r3, [r1, #0]
 80063c4:	50cd      	str	r5, [r1, r3]
 80063c6:	18cc      	adds	r4, r1, r3
 80063c8:	4630      	mov	r0, r6
 80063ca:	f000 f83a 	bl	8006442 <__malloc_unlock>
 80063ce:	f104 000b 	add.w	r0, r4, #11
 80063d2:	1d23      	adds	r3, r4, #4
 80063d4:	f020 0007 	bic.w	r0, r0, #7
 80063d8:	1ac3      	subs	r3, r0, r3
 80063da:	d01b      	beq.n	8006414 <_malloc_r+0xb0>
 80063dc:	425a      	negs	r2, r3
 80063de:	50e2      	str	r2, [r4, r3]
 80063e0:	bd70      	pop	{r4, r5, r6, pc}
 80063e2:	428c      	cmp	r4, r1
 80063e4:	bf0d      	iteet	eq
 80063e6:	6863      	ldreq	r3, [r4, #4]
 80063e8:	684b      	ldrne	r3, [r1, #4]
 80063ea:	6063      	strne	r3, [r4, #4]
 80063ec:	6013      	streq	r3, [r2, #0]
 80063ee:	bf18      	it	ne
 80063f0:	460c      	movne	r4, r1
 80063f2:	e7e9      	b.n	80063c8 <_malloc_r+0x64>
 80063f4:	460c      	mov	r4, r1
 80063f6:	6849      	ldr	r1, [r1, #4]
 80063f8:	e7ca      	b.n	8006390 <_malloc_r+0x2c>
 80063fa:	1cc4      	adds	r4, r0, #3
 80063fc:	f024 0403 	bic.w	r4, r4, #3
 8006400:	42a0      	cmp	r0, r4
 8006402:	d005      	beq.n	8006410 <_malloc_r+0xac>
 8006404:	1a21      	subs	r1, r4, r0
 8006406:	4630      	mov	r0, r6
 8006408:	f000 f80a 	bl	8006420 <_sbrk_r>
 800640c:	3001      	adds	r0, #1
 800640e:	d0cd      	beq.n	80063ac <_malloc_r+0x48>
 8006410:	6025      	str	r5, [r4, #0]
 8006412:	e7d9      	b.n	80063c8 <_malloc_r+0x64>
 8006414:	bd70      	pop	{r4, r5, r6, pc}
 8006416:	bf00      	nop
 8006418:	20000564 	.word	0x20000564
 800641c:	20000568 	.word	0x20000568

08006420 <_sbrk_r>:
 8006420:	b538      	push	{r3, r4, r5, lr}
 8006422:	4c06      	ldr	r4, [pc, #24]	; (800643c <_sbrk_r+0x1c>)
 8006424:	2300      	movs	r3, #0
 8006426:	4605      	mov	r5, r0
 8006428:	4608      	mov	r0, r1
 800642a:	6023      	str	r3, [r4, #0]
 800642c:	f000 f80a 	bl	8006444 <_sbrk>
 8006430:	1c43      	adds	r3, r0, #1
 8006432:	d102      	bne.n	800643a <_sbrk_r+0x1a>
 8006434:	6823      	ldr	r3, [r4, #0]
 8006436:	b103      	cbz	r3, 800643a <_sbrk_r+0x1a>
 8006438:	602b      	str	r3, [r5, #0]
 800643a:	bd38      	pop	{r3, r4, r5, pc}
 800643c:	20000d28 	.word	0x20000d28

08006440 <__malloc_lock>:
 8006440:	4770      	bx	lr

08006442 <__malloc_unlock>:
 8006442:	4770      	bx	lr

08006444 <_sbrk>:
 8006444:	4b04      	ldr	r3, [pc, #16]	; (8006458 <_sbrk+0x14>)
 8006446:	6819      	ldr	r1, [r3, #0]
 8006448:	4602      	mov	r2, r0
 800644a:	b909      	cbnz	r1, 8006450 <_sbrk+0xc>
 800644c:	4903      	ldr	r1, [pc, #12]	; (800645c <_sbrk+0x18>)
 800644e:	6019      	str	r1, [r3, #0]
 8006450:	6818      	ldr	r0, [r3, #0]
 8006452:	4402      	add	r2, r0
 8006454:	601a      	str	r2, [r3, #0]
 8006456:	4770      	bx	lr
 8006458:	2000056c 	.word	0x2000056c
 800645c:	20000d2c 	.word	0x20000d2c

08006460 <_init>:
 8006460:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006462:	bf00      	nop
 8006464:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006466:	bc08      	pop	{r3}
 8006468:	469e      	mov	lr, r3
 800646a:	4770      	bx	lr

0800646c <_fini>:
 800646c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800646e:	bf00      	nop
 8006470:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006472:	bc08      	pop	{r3}
 8006474:	469e      	mov	lr, r3
 8006476:	4770      	bx	lr
